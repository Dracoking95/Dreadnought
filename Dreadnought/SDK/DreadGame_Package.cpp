/**
 * Name: Dreadnought
 * Version: Latest
 */

#include "../SDK.h"

namespace CG
{
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWebImage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWebImage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWebImage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EDD0
	 * 		Name   -> Function DreadGame.YImageLoader.IsImageAvailable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYImageLoader::IsImageAvailable(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YImageLoader.IsImageAvailable");
		
		UYImageLoader_IsImageAvailable_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752A70
	 * 		Name   -> Function DreadGame.YImageLoader.GetImageTexture
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYImageLoader::GetImageTexture(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YImageLoader.GetImageTexture");
		
		UYImageLoader_GetImageTexture_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752980
	 * 		Name   -> Function DreadGame.YImageLoader.GetImage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYWebImage* UYImageLoader::GetImage(class UObject* WorldContextObject, const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YImageLoader.GetImage");
		
		UYImageLoader_GetImage_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYImageLoader.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYImageLoader::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YImageLoader");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AD90
	 * 		Name   -> Function DreadGame.DreadAsyncTaskDownloadImage.DownloadImage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYImageLoader*                               imageLoader                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDreadAsyncTaskDownloadImage* UDreadAsyncTaskDownloadImage::STATIC_DownloadImage(class UObject* WorldContextObject, class UYImageLoader* imageLoader, const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.DreadAsyncTaskDownloadImage.DownloadImage");
		
		UDreadAsyncTaskDownloadImage_DownloadImage_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.imageLoader = imageLoader;
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDreadAsyncTaskDownloadImage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDreadAsyncTaskDownloadImage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.DreadAsyncTaskDownloadImage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C1C0
	 * 		Name   -> Function DreadGame.IdleKickManager.HandlePlayerActionTaken
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UIdleKickManager::HandlePlayerActionTaken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.IdleKickManager.HandlePlayerActionTaken");
		
		UIdleKickManager_HandlePlayerActionTaken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIdleKickManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIdleKickManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.IdleKickManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULegalItemsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULegalItemsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.LegalItemsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoginGateManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoginGateManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.LoginGateManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMarketManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMarketManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.MarketManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYUIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYUIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YUIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076ABE0
	 * 		Name   -> Function DreadGame.SocialManager.OnStoredPlayersDisplayInformationUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void USocialManager::OnStoredPlayersDisplayInformationUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.SocialManager.OnStoredPlayersDisplayInformationUpdated");
		
		USocialManager_OnStoredPlayersDisplayInformationUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767C30
	 * 		Name   -> Function DreadGame.SocialManager.OnPlayerDataAvailable
	 * 		Flags  -> (Final, Native, Private)
	 */
	void USocialManager::OnPlayerDataAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.SocialManager.OnPlayerDataAvailable");
		
		USocialManager_OnPlayerDataAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USocialManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USocialManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.SocialManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWebServiceSessionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWebServiceSessionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.WebServiceSessionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B0D0
	 * 		Name   -> Function DreadGame.Widget_VerticalModuleList.GetYPosFromScrollOffset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              scrollOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              listHieght                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              itemHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              listLength                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UWidget_VerticalModuleList::GetYPosFromScrollOffset(float scrollOffset, float listHieght, float itemHeight, float listLength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.Widget_VerticalModuleList.GetYPosFromScrollOffset");
		
		UWidget_VerticalModuleList_GetYPosFromScrollOffset_Params params {};
		params.scrollOffset = scrollOffset;
		params.listHieght = listHieght;
		params.itemHeight = itemHeight;
		params.listLength = listLength;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidget_VerticalModuleList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidget_VerticalModuleList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.Widget_VerticalModuleList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UY3dArrowComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UY3dArrowComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.Y3dArrowComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YItemIDRegister.UpdateFromRegisterBuffer
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYItemIDRegister::UpdateFromRegisterBuffer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YItemIDRegister.UpdateFromRegisterBuffer");
		
		UYItemIDRegister_UpdateFromRegisterBuffer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YItemIDRegister.UpdateFromItemIDListBuffer
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYItemIDRegister::UpdateFromItemIDListBuffer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YItemIDRegister.UpdateFromItemIDListBuffer");
		
		UYItemIDRegister_UpdateFromItemIDListBuffer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YItemIDRegister.SaveToFiles
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYItemIDRegister::SaveToFiles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YItemIDRegister.SaveToFiles");
		
		UYItemIDRegister_SaveToFiles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YItemIDRegister.RepeatCheckoutRegisterFile
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYItemIDRegister::RepeatCheckoutRegisterFile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YItemIDRegister.RepeatCheckoutRegisterFile");
		
		UYItemIDRegister_RepeatCheckoutRegisterFile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YItemIDRegister.OnCheckedOutReattemptSuceeded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYItemIDRegister::OnCheckedOutReattemptSuceeded__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YItemIDRegister.OnCheckedOutReattemptSuceeded__DelegateSignature");
		
		UYItemIDRegister_OnCheckedOutReattemptSuceeded__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYItemIDRegister.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYItemIDRegister::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YItemIDRegister");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F6E0
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.IsPublicReady
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYInterface_ItemIDAsset::IsPublicReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.IsPublicReady");
		
		UYInterface_ItemIDAsset_IsPublicReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F040
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.IsInternalOnly
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYInterface_ItemIDAsset::IsInternalOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.IsInternalOnly");
		
		UYInterface_ItemIDAsset_IsInternalOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751B00
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.HasMarket3DPreview
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYInterface_ItemIDAsset::HasMarket3DPreview()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.HasMarket3DPreview");
		
		UYInterface_ItemIDAsset_HasMarket3DPreview_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759FA0
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetToolTipSubline
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UYInterface_ItemIDAsset::GetToolTipSubline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetToolTipSubline");
		
		UYInterface_ItemIDAsset_GetToolTipSubline_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759F20
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetToolTipIconPath
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class FString UYInterface_ItemIDAsset::GetToolTipIconPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetToolTipIconPath");
		
		UYInterface_ItemIDAsset_GetToolTipIconPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759EA0
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetToolTipHeadline
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UYInterface_ItemIDAsset::GetToolTipHeadline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetToolTipHeadline");
		
		UYInterface_ItemIDAsset_GetToolTipHeadline_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759E20
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetToolTipDescription
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UYInterface_ItemIDAsset::GetToolTipDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetToolTipDescription");
		
		UYInterface_ItemIDAsset_GetToolTipDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757440
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetQualityLevel
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYQualityLevel UYInterface_ItemIDAsset::GetQualityLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetQualityLevel");
		
		UYInterface_ItemIDAsset_GetQualityLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752E40
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetItemUIData
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYItemUIData UYInterface_ItemIDAsset::GetItemUIData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetItemUIData");
		
		UYInterface_ItemIDAsset_GetItemUIData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752E10
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetItemTier
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYInterface_ItemIDAsset::GetItemTier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetItemTier");
		
		UYInterface_ItemIDAsset_GetItemTier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752D40
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetItemMetaData
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYItemMetaData UYInterface_ItemIDAsset::GetItemMetaData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetItemMetaData");
		
		UYInterface_ItemIDAsset_GetItemMetaData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750D70
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetItemID
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYInterface_ItemIDAsset::GetItemID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetItemID");
		
		UYInterface_ItemIDAsset_GetItemID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752620
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetHighResIconPath
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class FString UYInterface_ItemIDAsset::GetHighResIconPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetHighResIconPath");
		
		UYInterface_ItemIDAsset_GetHighResIconPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751700
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetDetailedDescription
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UYInterface_ItemIDAsset::GetDetailedDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetDetailedDescription");
		
		UYInterface_ItemIDAsset_GetDetailedDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750210
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.GetCompatibleShipClasses
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<EYShipClass> UYInterface_ItemIDAsset::GetCompatibleShipClasses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.GetCompatibleShipClasses");
		
		UYInterface_ItemIDAsset_GetCompatibleShipClasses_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753090
	 * 		Name   -> Function DreadGame.YInterface_ItemIDAsset.BuildDebugString
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class FString UYInterface_ItemIDAsset::BuildDebugString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ItemIDAsset.BuildDebugString");
		
		UYInterface_ItemIDAsset_BuildDebugString_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInterface_ItemIDAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInterface_ItemIDAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInterface_ItemIDAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWeaponDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWeaponDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeaponDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWeapon.ReceiveReloadingStop
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYWeapon::ReceiveReloadingStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.ReceiveReloadingStop");
		
		AYWeapon_ReceiveReloadingStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWeapon.ReceiveReloadingStart
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYWeapon::ReceiveReloadingStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.ReceiveReloadingStart");
		
		AYWeapon_ReceiveReloadingStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWeapon.ReceiveReady
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYWeapon::ReceiveReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.ReceiveReady");
		
		AYWeapon_ReceiveReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWeapon.ReceiveFiring
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FYTargetInfo                                targetInfo                                                 (Parm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            randomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYWeapon::ReceiveFiring(const struct FYTargetInfo& targetInfo, int32_t randomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.ReceiveFiring");
		
		AYWeapon_ReceiveFiring_Params params {};
		params.targetInfo = targetInfo;
		params.randomSeed = randomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWeapon.ReceiveCoolingDown
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYWeapon::ReceiveCoolingDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.ReceiveCoolingDown");
		
		AYWeapon_ReceiveCoolingDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWeapon.ReceiveCharging
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYWeapon::ReceiveCharging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.ReceiveCharging");
		
		AYWeapon_ReceiveCharging_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767580
	 * 		Name   -> Function DreadGame.YWeapon.OnOwningPawnGetPossessed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      possessedPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 possessingController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYWeapon::OnOwningPawnGetPossessed(class AYPawn* possessedPawn, class AController* possessingController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.OnOwningPawnGetPossessed");
		
		AYWeapon_OnOwningPawnGetPossessed_Params params {};
		params.possessedPawn = possessedPawn;
		params.possessingController = possessingController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F480
	 * 		Name   -> Function DreadGame.YWeapon.IsOnTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYWeapon::IsOnTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.IsOnTarget");
		
		AYWeapon_IsOnTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E740
	 * 		Name   -> Function DreadGame.YWeapon.IsFiring
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYWeapon::IsFiring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.IsFiring");
		
		AYWeapon_IsFiring_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759900
	 * 		Name   -> Function DreadGame.YWeapon.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam AYWeapon::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.GetTeam");
		
		AYWeapon_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758AF0
	 * 		Name   -> Function DreadGame.YWeapon.GetShootingTransform
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform AYWeapon::GetShootingTransform(const class FName& SocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.GetShootingTransform");
		
		AYWeapon_GetShootingTransform_Params params {};
		params.SocketName = SocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755AC0
	 * 		Name   -> Function DreadGame.YWeapon.GetOwningPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPawn* AYWeapon::GetOwningPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.GetOwningPawn");
		
		AYWeapon_GetOwningPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755A60
	 * 		Name   -> Function DreadGame.YWeapon.GetOwningController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AController* AYWeapon::GetOwningController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.GetOwningController");
		
		AYWeapon_GetOwningController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750B90
	 * 		Name   -> Function DreadGame.YWeapon.GetCurrentRandomSeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYWeapon::GetCurrentRandomSeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.GetCurrentRandomSeed");
		
		AYWeapon_GetCurrentRandomSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D4B0
	 * 		Name   -> Function DreadGame.YWeapon.GetAimAtLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AYWeapon::GetAimAtLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeapon.GetAimAtLocation");
		
		AYWeapon_GetAimAtLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007828D0
	 * 		Name   -> Function DreadGame.YAbility.TriggerVOOnCooldownExpired
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYAbility::TriggerVOOnCooldownExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.TriggerVOOnCooldownExpired");
		
		UYAbility_TriggerVOOnCooldownExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781D50
	 * 		Name   -> Function DreadGame.YAbility.TriggerCameraShake
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYAbility::TriggerCameraShake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.TriggerCameraShake");
		
		UYAbility_TriggerCameraShake_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbility.OnResetAbilityVisuals
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYAbility::OnResetAbilityVisuals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnResetAbilityVisuals");
		
		UYAbility_OnResetAbilityVisuals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766DB0
	 * 		Name   -> Function DreadGame.YAbility.OnOwnerEnergyWheelFunctionActivated
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             EnergyWheelSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbility::OnOwnerEnergyWheelFunctionActivated(EYEnergyWheelSelection EnergyWheelSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnOwnerEnergyWheelFunctionActivated");
		
		UYAbility_OnOwnerEnergyWheelFunctionActivated_Params params {};
		params.EnergyWheelSelection = EnergyWheelSelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766D10
	 * 		Name   -> Function DreadGame.YAbility.OnOwnerDied
	 * 		Flags  -> (Native, Protected)
	 */
	void UYAbility::OnOwnerDied()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnOwnerDied");
		
		UYAbility_OnOwnerDied_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbility.OnInitialize
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYAbility::OnInitialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnInitialize");
		
		UYAbility_OnInitialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbility.OnCoolDownCompleted
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      PawnOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbility::OnCoolDownCompleted(class AYPawn* PawnOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnCoolDownCompleted");
		
		UYAbility_OnCoolDownCompleted_Params params {};
		params.PawnOwner = PawnOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbility.OnActorListReceived
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYAbility::OnActorListReceived(TArray<class AActor*> Actors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnActorListReceived");
		
		UYAbility_OnActorListReceived_Params params {};
		params.Actors = Actors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbility.OnAbilityDeactivated
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      PawnOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbility::OnAbilityDeactivated(class AYPawn* PawnOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnAbilityDeactivated");
		
		UYAbility_OnAbilityDeactivated_Params params {};
		params.PawnOwner = PawnOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbility.OnAbilityCanceled
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      PawnOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbility::OnAbilityCanceled(class AYPawn* PawnOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnAbilityCanceled");
		
		UYAbility_OnAbilityCanceled_Params params {};
		params.PawnOwner = PawnOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbility.OnAbilityActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      PawnOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               abilitySucceeded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYAbility::OnAbilityActivated(class AYPawn* PawnOwner, bool abilitySucceeded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.OnAbilityActivated");
		
		UYAbility_OnAbilityActivated_Params params {};
		params.PawnOwner = PawnOwner;
		params.abilitySucceeded = abilitySucceeded;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E720F0
	 * 		Name   -> Function DreadGame.YAbility.GetUnmodifiedAbilityCoolDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYAbility::GetUnmodifiedAbilityCoolDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetUnmodifiedAbilityCoolDown");
		
		UYAbility_GetUnmodifiedAbilityCoolDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759D80
	 * 		Name   -> Function DreadGame.YAbility.GetTimeActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYAbility::GetTimeActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetTimeActive");
		
		UYAbility_GetTimeActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759780
	 * 		Name   -> Function DreadGame.YAbility.GetTargets
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class AActor*> UYAbility::GetTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetTargets");
		
		UYAbility_GetTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759550
	 * 		Name   -> Function DreadGame.YAbility.GetSupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UYAbility::GetSupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetSupply");
		
		UYAbility_GetSupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755ED0
	 * 		Name   -> Function DreadGame.YAbility.GetPawnOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYPawn* UYAbility::GetPawnOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetPawnOwner");
		
		UYAbility_GetPawnOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007516E0
	 * 		Name   -> Function DreadGame.YAbility.GetDefaultSupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UYAbility::GetDefaultSupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetDefaultSupply");
		
		UYAbility_GetDefaultSupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750690
	 * 		Name   -> Function DreadGame.YAbility.GetCurrentCoolDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYAbility::GetCurrentCoolDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetCurrentCoolDown");
		
		UYAbility_GetCurrentCoolDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007503D0
	 * 		Name   -> Function DreadGame.YAbility.GetCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYAbility::GetCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetCooldown");
		
		UYAbility_GetCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CCA0
	 * 		Name   -> Function DreadGame.YAbility.GetAbilityNameInternal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName UYAbility::GetAbilityNameInternal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetAbilityNameInternal");
		
		UYAbility_GetAbilityNameInternal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CC80
	 * 		Name   -> Function DreadGame.YAbility.GetAbilityName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName UYAbility::GetAbilityName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetAbilityName");
		
		UYAbility_GetAbilityName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CB10
	 * 		Name   -> Function DreadGame.YAbility.GetAbilityClassID
	 * 		Flags  -> (Final, Native, Public)
	 */
	int32_t UYAbility::GetAbilityClassID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetAbilityClassID");
		
		UYAbility_GetAbilityClassID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CAF0
	 * 		Name   -> Function DreadGame.YAbility.GetAbilityCategory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYAbilityCategory UYAbility::GetAbilityCategory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.GetAbilityCategory");
		
		UYAbility_GetAbilityCategory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741C00
	 * 		Name   -> Function DreadGame.YAbility.AsyncLoadAssetPtr
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TAssetPtr<class UObject>                           Asset                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbility::AsyncLoadAssetPtr(TAssetPtr<class UObject> Asset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbility.AsyncLoadAssetPtr");
		
		UYAbility_AsyncLoadAssetPtr_Params params {};
		params.Asset = Asset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781D70
	 * 		Name   -> Function DreadGame.YWeaponGroup.TriggerCameraShake
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWeaponGroup::TriggerCameraShake(class UClass* Shake, float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponGroup.TriggerCameraShake");
		
		UYWeaponGroup_TriggerCameraShake_Params params {};
		params.Shake = Shake;
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWeaponGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWeaponGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeaponGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BA20
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.SetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::SetTeam(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.SetTeam");
		
		UYWeaponManagerComponent_SetTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774620
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerStopFireAllWeaponGroups
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void UYWeaponManagerComponent::ServerStopFireAllWeaponGroups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerStopFireAllWeaponGroups");
		
		UYWeaponManagerComponent_ServerStopFireAllWeaponGroups_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007745D0
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerStopFireActiveWeaponGroup
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void UYWeaponManagerComponent::ServerStopFireActiveWeaponGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerStopFireActiveWeaponGroup");
		
		UYWeaponManagerComponent_ServerStopFireActiveWeaponGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774580
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerStartReloadActiveWeaponGroup
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void UYWeaponManagerComponent::ServerStartReloadActiveWeaponGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerStartReloadActiveWeaponGroup");
		
		UYWeaponManagerComponent_ServerStartReloadActiveWeaponGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774210
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerStartFireActiveWeaponGroup
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FYTargetInfo                                targetInfo                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::ServerStartFireActiveWeaponGroup(const struct FYTargetInfo& targetInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerStartFireActiveWeaponGroup");
		
		UYWeaponManagerComponent_ServerStartFireActiveWeaponGroup_Params params {};
		params.targetInfo = targetInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773760
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerSetTargetInfo
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FYTargetInfo                                targetInfo                                                 (Parm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            weaponGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::ServerSetTargetInfo(const struct FYTargetInfo& targetInfo, int32_t weaponGroup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerSetTargetInfo");
		
		UYWeaponManagerComponent_ServerSetTargetInfo_Params params {};
		params.targetInfo = targetInfo;
		params.weaponGroup = weaponGroup;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007732B0
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerSetActiveTargetInfoUnreliable
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FYTargetInfo                                targetInfo                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::ServerSetActiveTargetInfoUnreliable(const struct FYTargetInfo& targetInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerSetActiveTargetInfoUnreliable");
		
		UYWeaponManagerComponent_ServerSetActiveTargetInfoUnreliable_Params params {};
		params.targetInfo = targetInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773100
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerSetActiveTargetInfoReliable
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FYTargetInfo                                targetInfo                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::ServerSetActiveTargetInfoReliable(const struct FYTargetInfo& targetInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerSetActiveTargetInfoReliable");
		
		UYWeaponManagerComponent_ServerSetActiveTargetInfoReliable_Params params {};
		params.targetInfo = targetInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771230
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ServerActivateWeaponGroup
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            weaponGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::ServerActivateWeaponGroup(int32_t weaponGroup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ServerActivateWeaponGroup");
		
		UYWeaponManagerComponent_ServerActivateWeaponGroup_Params params {};
		params.weaponGroup = weaponGroup;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AA10
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.OnSpreadChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              newSpread                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            GroupIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::OnSpreadChanged(float newSpread, int32_t GroupIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.OnSpreadChanged");
		
		UYWeaponManagerComponent_OnSpreadChanged_Params params {};
		params.newSpread = newSpread;
		params.GroupIndex = GroupIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769320
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.OnRep_WeaponGroupNetData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWeaponManagerComponent::OnRep_WeaponGroupNetData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.OnRep_WeaponGroupNetData");
		
		UYWeaponManagerComponent_OnRep_WeaponGroupNetData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007692E0
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.OnRep_WeaponAmmoCounter
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWeaponManagerComponent::OnRep_WeaponAmmoCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.OnRep_WeaponAmmoCounter");
		
		UYWeaponManagerComponent_OnRep_WeaponAmmoCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007691A0
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.OnRep_TargetInfo
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWeaponManagerComponent::OnRep_TargetInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.OnRep_TargetInfo");
		
		UYWeaponManagerComponent_OnRep_TargetInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768C60
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.OnRep_CurrentWeaponGroupIdx
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWeaponManagerComponent::OnRep_CurrentWeaponGroupIdx()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.OnRep_CurrentWeaponGroupIdx");
		
		UYWeaponManagerComponent_OnRep_CurrentWeaponGroupIdx_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768C40
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.OnRep_CurrentReloadingWeaponIndex
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWeaponManagerComponent::OnRep_CurrentReloadingWeaponIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.OnRep_CurrentReloadingWeaponIndex");
		
		UYWeaponManagerComponent_OnRep_CurrentReloadingWeaponIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761B80
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.NotifyAimStateServer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               moving                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               aiming                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWeaponManagerComponent::NotifyAimStateServer(bool moving, bool aiming)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.NotifyAimStateServer");
		
		UYWeaponManagerComponent_NotifyAimStateServer_Params params {};
		params.moving = moving;
		params.aiming = aiming;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F770
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.IsReloading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            weaponGroupIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYWeaponManagerComponent::IsReloading(int32_t weaponGroupIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.IsReloading");
		
		UYWeaponManagerComponent_IsReloading_Params params {};
		params.weaponGroupIdx = weaponGroupIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A670
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetWeaponName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            groupIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYWeaponManagerComponent::GetWeaponName(int32_t groupIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetWeaponName");
		
		UYWeaponManagerComponent_GetWeaponName_Params params {};
		params.groupIdx = groupIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759940
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam UYWeaponManagerComponent::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetTeam");
		
		UYWeaponManagerComponent_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758F60
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetSpread
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            groupIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UYWeaponManagerComponent::GetSpread(int32_t groupIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetSpread");
		
		UYWeaponManagerComponent_GetSpread_Params params {};
		params.groupIdx = groupIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753E10
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetMaxAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            groupIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYWeaponManagerComponent::GetMaxAmmo(int32_t groupIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetMaxAmmo");
		
		UYWeaponManagerComponent_GetMaxAmmo_Params params {};
		params.groupIdx = groupIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750C40
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetCurrentSpread
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYWeaponManagerComponent::GetCurrentSpread()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetCurrentSpread");
		
		UYWeaponManagerComponent_GetCurrentSpread_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750A30
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetCurrentMaxAmmoAmount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYWeaponManagerComponent::GetCurrentMaxAmmoAmount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetCurrentMaxAmmoAmount");
		
		UYWeaponManagerComponent_GetCurrentMaxAmmoAmount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007505E0
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetCurrentAmmoAmount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYWeaponManagerComponent::GetCurrentAmmoAmount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetCurrentAmmoAmount");
		
		UYWeaponManagerComponent_GetCurrentAmmoAmount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D630
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            groupIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYWeaponManagerComponent::GetAmmo(int32_t groupIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetAmmo");
		
		UYWeaponManagerComponent_GetAmmo_Params params {};
		params.groupIdx = groupIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CF60
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.GetActiveWeaponGroup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYWeaponManagerComponent::GetActiveWeaponGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.GetActiveWeaponGroup");
		
		UYWeaponManagerComponent_GetActiveWeaponGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746180
	 * 		Name   -> Function DreadGame.YWeaponManagerComponent.ClientOnStartReloadActiveWeaponGroup
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void UYWeaponManagerComponent::ClientOnStartReloadActiveWeaponGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWeaponManagerComponent.ClientOnStartReloadActiveWeaponGroup");
		
		UYWeaponManagerComponent_ClientOnStartReloadActiveWeaponGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWeaponManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWeaponManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeaponManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityAltWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityAltWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityAltWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D180
	 * 		Name   -> Function DreadGame.YProjectile.ShouldDamageOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYProjectile::ShouldDamageOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.ShouldDamageOwner");
		
		AYProjectile_ShouldDamageOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778DD0
	 * 		Name   -> Function DreadGame.YProjectile.SetMaxTravelDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              maxTravelDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               skipImmediateDistanceCheck                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYProjectile::SetMaxTravelDistance(float maxTravelDistance, bool skipImmediateDistanceCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.SetMaxTravelDistance");
		
		AYProjectile_SetMaxTravelDistance_Params params {};
		params.maxTravelDistance = maxTravelDistance;
		params.skipImmediateDistanceCheck = skipImmediateDistanceCheck;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnUpdateVelocity
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProjectile::OnUpdateVelocity(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnUpdateVelocity");
		
		AYProjectile_OnUpdateVelocity_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnUpdateCollision
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     deltaMovement                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProjectile::OnUpdateCollision(const struct FVector& deltaMovement, float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnUpdateCollision");
		
		AYProjectile_OnUpdateCollision_Params params {};
		params.deltaMovement = deltaMovement;
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnReachedProximityRange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectile::OnReachedProximityRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnReachedProximityRange");
		
		AYProjectile_OnReachedProximityRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnProjectileInitialized
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectile::OnProjectileInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnProjectileInitialized");
		
		AYProjectile_OnProjectileInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnMaxDistanceReached
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectile::OnMaxDistanceReached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnMaxDistanceReached");
		
		AYProjectile_OnMaxDistanceReached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnImpact
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AYProjectile::OnImpact(const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnImpact");
		
		AYProjectile_OnImpact_Params params {};
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnForceExplosion
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectile::OnForceExplosion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnForceExplosion");
		
		AYProjectile_OnForceExplosion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnExploding
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectile::OnExploding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnExploding");
		
		AYProjectile_OnExploding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnDealRadialDamageToPawn
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isShieldActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              currentExplosionLifeTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProjectile::OnDealRadialDamageToPawn(class AYPawn* Pawn, bool isShieldActive, float currentExplosionLifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnDealRadialDamageToPawn");
		
		AYProjectile_OnDealRadialDamageToPawn_Params params {};
		params.Pawn = Pawn;
		params.isShieldActive = isShieldActive;
		params.currentExplosionLifeTime = currentExplosionLifeTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectile.OnCleanUpProjectile
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectile::OnCleanUpProjectile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.OnCleanUpProjectile");
		
		AYProjectile_OnCleanUpProjectile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FB20
	 * 		Name   -> Function DreadGame.YProjectile.IsStoppingSimulation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYProjectile::IsStoppingSimulation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.IsStoppingSimulation");
		
		AYProjectile_IsStoppingSimulation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007598C0
	 * 		Name   -> Function DreadGame.YProjectile.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam AYProjectile::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.GetTeam");
		
		AYProjectile_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757270
	 * 		Name   -> Function DreadGame.YProjectile.GetProjectileOfflineData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYProjectileOfflineDataTableRow AYProjectile::GetProjectileOfflineData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.GetProjectileOfflineData");
		
		AYProjectile_GetProjectileOfflineData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754460
	 * 		Name   -> Function DreadGame.YProjectile.GetModifiedMaxTravelDistance
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AYProjectile::GetModifiedMaxTravelDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.GetModifiedMaxTravelDistance");
		
		AYProjectile_GetModifiedMaxTravelDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748730
	 * 		Name   -> Function DreadGame.YProjectile.CollideProjectile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  OutHit                                                     (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AYProjectile::CollideProjectile(const struct FHitResult& OutHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.CollideProjectile");
		
		AYProjectile_CollideProjectile_Params params {};
		params.OutHit = OutHit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744820
	 * 		Name   -> Function DreadGame.YProjectile.CleanUpProjectile
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYProjectile::CleanUpProjectile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.CleanUpProjectile");
		
		AYProjectile_CleanUpProjectile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743D00
	 * 		Name   -> Function DreadGame.YProjectile.CanBeTargeted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               canTargetDuringInstigatorIgnoreTime                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYProjectile::CanBeTargeted(bool canTargetDuringInstigatorIgnoreTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.CanBeTargeted");
		
		AYProjectile_CanBeTargeted_Params params {};
		params.canTargetDuringInstigatorIgnoreTime = canTargetDuringInstigatorIgnoreTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742CC0
	 * 		Name   -> Function DreadGame.YProjectile.CalculateDamageForDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              traveledDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AYProjectile::CalculateDamageForDistance(float traveledDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.CalculateDamageForDistance");
		
		AYProjectile_CalculateDamageForDistance_Params params {};
		params.traveledDistance = traveledDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741080
	 * 		Name   -> Function DreadGame.YProjectile.ApplyDamage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProjectile::ApplyDamage(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectile.ApplyDamage");
		
		AYProjectile_ApplyDamage_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757F80
	 * 		Name   -> Function DreadGame.YAbilityBatteringRam.GetSensorLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FVector UYAbilityBatteringRam::GetSensorLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityBatteringRam.GetSensorLocation");
		
		UYAbilityBatteringRam_GetSensorLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityBatteringRam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityBatteringRam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityBatteringRam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748710
	 * 		Name   -> Function DreadGame.YAbilityBeamModifier.CollectOwnedBeamWeapons
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAbilityBeamModifier::CollectOwnedBeamWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityBeamModifier.CollectOwnedBeamWeapons");
		
		UYAbilityBeamModifier_CollectOwnedBeamWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityBeamModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityBeamModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityBeamModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityDeployable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityDeployable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityDeployable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSoftCollisionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSoftCollisionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSoftCollisionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A880
	 * 		Name   -> Function DreadGame.YAbilityMovement.OnSoftCollisionOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		TArray<struct FYSoftCollisionOverlapResult>        overlapResults                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYAbilityMovement::OnSoftCollisionOverlap(TArray<struct FYSoftCollisionOverlapResult> overlapResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityMovement.OnSoftCollisionOverlap");
		
		UYAbilityMovement_OnSoftCollisionOverlap_Params params {};
		params.overlapResults = overlapResults;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FC60
	 * 		Name   -> Function DreadGame.YAbilityMovement.IsTurningLeft
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYAbilityMovement::IsTurningLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityMovement.IsTurningLeft");
		
		UYAbilityMovement_IsTurningLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityMovement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityMovement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityMovement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbilityPulse.OnDealDamageToPawn
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityPulse::OnDealDamageToPawn(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityPulse.OnDealDamageToPawn");
		
		UYAbilityPulse_OnDealDamageToPawn_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityPulse.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityPulse::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityPulse");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782B70
	 * 		Name   -> Function DreadGame.YAbilityWarpJump.TriggerWarpJumpTeleport
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAbilityWarpJump::TriggerWarpJumpTeleport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityWarpJump.TriggerWarpJumpTeleport");
		
		UYAbilityWarpJump_TriggerWarpJumpTeleport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782B50
	 * 		Name   -> Function DreadGame.YAbilityWarpJump.TriggerWarpJumpEnd
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAbilityWarpJump::TriggerWarpJumpEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityWarpJump.TriggerWarpJumpEnd");
		
		UYAbilityWarpJump_TriggerWarpJumpEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FCC0
	 * 		Name   -> Function DreadGame.YAbilityWarpJump.IsWarmingUp
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYAbilityWarpJump::IsWarmingUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityWarpJump.IsWarmingUp");
		
		UYAbilityWarpJump_IsWarmingUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759640
	 * 		Name   -> Function DreadGame.YAbilityWarpJump.GetTargetLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector UYAbilityWarpJump::GetTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityWarpJump.GetTargetLocation");
		
		UYAbilityWarpJump_GetTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750400
	 * 		Name   -> Function DreadGame.YAbilityWarpJump.GetCountdown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYAbilityWarpJump::GetCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityWarpJump.GetCountdown");
		
		UYAbilityWarpJump_GetCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityWarpJump.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityWarpJump::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityWarpJump");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityWithWeaponBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityWithWeaponBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityWithWeaponBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWeaponGroupAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWeaponGroupAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeaponGroupAbility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007532E0
	 * 		Name   -> Function DreadGame.YAbilityBroadSide.GetLastFiredWeapons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class AYWeapon*> UYAbilityBroadSide::GetLastFiredWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityBroadSide.GetLastFiredWeapons");
		
		UYAbilityBroadSide_GetLastFiredWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityBroadSide.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityBroadSide::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityBroadSide");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766DB0
	 * 		Name   -> Function DreadGame.YAbilityFighterDrone.OnOwnerEnergyWheelFunctionActivated
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             EnergyWheelSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityFighterDrone::OnOwnerEnergyWheelFunctionActivated(EYEnergyWheelSelection EnergyWheelSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityFighterDrone.OnOwnerEnergyWheelFunctionActivated");
		
		UYAbilityFighterDrone_OnOwnerEnergyWheelFunctionActivated_Params params {};
		params.EnergyWheelSelection = EnergyWheelSelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766D10
	 * 		Name   -> Function DreadGame.YAbilityFighterDrone.OnOwnerDied
	 * 		Flags  -> (Native, Protected)
	 */
	void UYAbilityFighterDrone::OnOwnerDied()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityFighterDrone.OnOwnerDied");
		
		UYAbilityFighterDrone_OnOwnerDied_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityFighterDrone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityFighterDrone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityFighterDrone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAbilityPerimeterDefense.TargetDamaged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 eventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYWeapon*                                    causingWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityPerimeterDefense::TargetDamaged(class AActor* DamagedActor, float BaseDamage, class AController* eventInstigator, class AYWeapon* causingWeapon, class UClass* DamageTypeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityPerimeterDefense.TargetDamaged");
		
		UYAbilityPerimeterDefense_TargetDamaged_Params params {};
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.eventInstigator = eventInstigator;
		params.causingWeapon = causingWeapon;
		params.DamageTypeClass = DamageTypeClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityPerimeterDefense.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityPerimeterDefense::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityPerimeterDefense");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007543D0
	 * 		Name   -> Function DreadGame.YAbilityRocketSwarm.GetModifiedMaxDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYAbilityRocketSwarm::GetModifiedMaxDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityRocketSwarm.GetModifiedMaxDistance");
		
		UYAbilityRocketSwarm_GetModifiedMaxDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007532B0
	 * 		Name   -> Function DreadGame.YAbilityRocketSwarm.GetLastFiredWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYWeapon* UYAbilityRocketSwarm::GetLastFiredWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityRocketSwarm.GetLastFiredWeapon");
		
		UYAbilityRocketSwarm_GetLastFiredWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityRocketSwarm.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityRocketSwarm::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityRocketSwarm");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B640
	 * 		Name   -> Function DreadGame.YAbilityManager.SetTargetActorsInRange
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		TArray<struct FAbilityPerimeterTargetInfo>         perimeterTargets                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::SetTargetActorsInRange(TArray<struct FAbilityPerimeterTargetInfo> perimeterTargets, int32_t abilityIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.SetTargetActorsInRange");
		
		UYAbilityManager_SetTargetActorsInRange_Params params {};
		params.perimeterTargets = perimeterTargets;
		params.abilityIdx = abilityIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772860
	 * 		Name   -> Function DreadGame.YAbilityManager.ServerReleaseAbility
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            AbilityId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::ServerReleaseAbility(int32_t AbilityId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.ServerReleaseAbility");
		
		UYAbilityManager_ServerReleaseAbility_Params params {};
		params.AbilityId = AbilityId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772440
	 * 		Name   -> Function DreadGame.YAbilityManager.ServerPressAbility
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            AbilityId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      lockedPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::ServerPressAbility(int32_t AbilityId, class AYPawn* lockedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.ServerPressAbility");
		
		UYAbilityManager_ServerPressAbility_Params params {};
		params.AbilityId = AbilityId;
		params.lockedPawn = lockedPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007706C0
	 * 		Name   -> Function DreadGame.YAbilityManager.SendActorList
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        abilityName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::SendActorList(TArray<class AActor*> Actors, const class FName& abilityName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.SendActorList");
		
		UYAbilityManager_SendActorList_Params params {};
		params.Actors = Actors;
		params.abilityName = abilityName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FB10
	 * 		Name   -> Function DreadGame.YAbilityManager.Reset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYAbilityManager::Reset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.Reset");
		
		UYAbilityManager_Reset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769300
	 * 		Name   -> Function DreadGame.YAbilityManager.OnRep_WeaponGroupFireInfos
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAbilityManager::OnRep_WeaponGroupFireInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.OnRep_WeaponGroupFireInfos");
		
		UYAbilityManager_OnRep_WeaponGroupFireInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768D60
	 * 		Name   -> Function DreadGame.YAbilityManager.OnRep_GlobalCooldown
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAbilityManager::OnRep_GlobalCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.OnRep_GlobalCooldown");
		
		UYAbilityManager_OnRep_GlobalCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768C00
	 * 		Name   -> Function DreadGame.YAbilityManager.OnRep_CurrentAbilities
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAbilityManager::OnRep_CurrentAbilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.OnRep_CurrentAbilities");
		
		UYAbilityManager_OnRep_CurrentAbilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768B40
	 * 		Name   -> Function DreadGame.YAbilityManager.OnRep_Abilities
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAbilityManager::OnRep_Abilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.OnRep_Abilities");
		
		UYAbilityManager_OnRep_Abilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764250
	 * 		Name   -> Function DreadGame.YAbilityManager.OnIndividualAbilityCooldownDone
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::OnIndividualAbilityCooldownDone(class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.OnIndividualAbilityCooldownDone");
		
		UYAbilityManager_OnIndividualAbilityCooldownDone_Params params {};
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762130
	 * 		Name   -> Function DreadGame.YAbilityManager.OnAbilityStartedCooldown
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::OnAbilityStartedCooldown(class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.OnAbilityStartedCooldown");
		
		UYAbilityManager_OnAbilityStartedCooldown_Params params {};
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AA50
	 * 		Name   -> Function DreadGame.YAbilityManager.MulticastAbilityCanceled
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        abilityName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::MulticastAbilityCanceled(const class FName& abilityName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.MulticastAbilityCanceled");
		
		UYAbilityManager_MulticastAbilityCanceled_Params params {};
		params.abilityName = abilityName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007521F0
	 * 		Name   -> Function DreadGame.YAbilityManager.GetGlobalDefaultCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYAbilityManager::GetGlobalDefaultCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.GetGlobalDefaultCooldown");
		
		UYAbilityManager_GetGlobalDefaultCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007521C0
	 * 		Name   -> Function DreadGame.YAbilityManager.GetGlobalCurrentCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYAbilityManager::GetGlobalCurrentCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.GetGlobalCurrentCooldown");
		
		UYAbilityManager_GetGlobalCurrentCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CBD0
	 * 		Name   -> Function DreadGame.YAbilityManager.GetAbilityItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class UYAbility*> UYAbilityManager::GetAbilityItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.GetAbilityItems");
		
		UYAbilityManager_GetAbilityItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007478D0
	 * 		Name   -> Function DreadGame.YAbilityManager.ClientTriggerPulseVisualAndSoundActorList
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        abilityName                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::ClientTriggerPulseVisualAndSoundActorList(TArray<class AActor*> Actors, const class FName& abilityName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.ClientTriggerPulseVisualAndSoundActorList");
		
		UYAbilityManager_ClientTriggerPulseVisualAndSoundActorList_Params params {};
		params.Actors = Actors;
		params.abilityName = abilityName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745A00
	 * 		Name   -> Function DreadGame.YAbilityManager.ClientNotifyDeactivation
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        abilityName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               wasInterrupted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               triggerVO                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::ClientNotifyDeactivation(const class FName& abilityName, bool wasInterrupted, bool triggerVO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.ClientNotifyDeactivation");
		
		UYAbilityManager_ClientNotifyDeactivation_Params params {};
		params.abilityName = abilityName;
		params.wasInterrupted = wasInterrupted;
		params.triggerVO = triggerVO;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745800
	 * 		Name   -> Function DreadGame.YAbilityManager.ClientNotifyActivation
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		bool                                               abilitySucceeded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        abilityName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::ClientNotifyActivation(bool abilitySucceeded, const class FName& abilityName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.ClientNotifyActivation");
		
		UYAbilityManager_ClientNotifyActivation_Params params {};
		params.abilitySucceeded = abilitySucceeded;
		params.abilityName = abilityName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B560
	 * 		Name   -> Function DreadGame.YAbilityManager.ClientCooldownCompleted
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        abilityName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAbilityManager::ClientCooldownCompleted(const class FName& abilityName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAbilityManager.ClientCooldownCompleted");
		
		UYAbilityManager_ClientCooldownCompleted_Params params {};
		params.abilityName = abilityName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAbilityManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAbilityManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAbilityManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAchievementManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAchievementManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAchievementManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757090
	 * 		Name   -> Function DreadGame.YActorPoolManager.GetPooledActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      objectClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* UYActorPoolManager::STATIC_GetPooledActor(class UObject* WorldContext, class UClass* objectClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YActorPoolManager.GetPooledActor");
		
		UYActorPoolManager_GetPooledActor_Params params {};
		params.WorldContext = WorldContext;
		params.objectClass = objectClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYActorPoolManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYActorPoolManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YActorPoolManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAICollisionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAICollisionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAICollisionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E2C0
	 * 		Name   -> Function DreadGame.YCreepNavigation.IsBlockedByPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYCreepNavigation::IsBlockedByPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepNavigation.IsBlockedByPawn");
		
		AYCreepNavigation_IsBlockedByPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCreepNavigation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCreepNavigation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCreepNavigation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D2F0
	 * 		Name   -> Function DreadGame.YScoringDataManager.Initialize
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYScoringDataManager::Initialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YScoringDataManager.Initialize");
		
		UYScoringDataManager_Initialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringDataManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringDataManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringDataManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode.OnPlayerKilled
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode::OnPlayerKilled(class AYPawn* Killer, class AYPawn* victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode.OnPlayerKilled");
		
		AYGameMode_OnPlayerKilled_Params params {};
		params.Killer = Killer;
		params.victim = victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYNPCState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYNPCState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YNPCState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterAssetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterAssetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterAssetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784400
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.WasHealedWithinTimeFrame
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		float                                              timeFrame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Player                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYInterface_PlayerScore::WasHealedWithinTimeFrame(float timeFrame, const class FName& Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.WasHealedWithinTimeFrame");
		
		UYInterface_PlayerScore_WasHealedWithinTimeFrame_Params params {};
		params.timeFrame = timeFrame;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783680
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.UpdateHealingInfo
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        healerPlayer                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::UpdateHealingInfo(const class FName& healerPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.UpdateHealingInfo");
		
		UYInterface_PlayerScore_UpdateHealingInfo_Params params {};
		params.healerPlayer = healerPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007830B0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.UpdateDamageInfo
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        damagedPlayer                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::UpdateDamageInfo(const class FName& damagedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.UpdateDamageInfo");
		
		UYInterface_PlayerScore_UpdateDamageInfo_Params params {};
		params.damagedPlayer = damagedPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A9B0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.SetScore
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::SetScore(int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.SetScore");
		
		UYInterface_PlayerScore_SetScore_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007705E0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreMutualSquadAssist
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ScoreMutualSquadAssist()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreMutualSquadAssist");
		
		UYInterface_PlayerScore_ScoreMutualSquadAssist_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007705C0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreKillWhileDead
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ScoreKillWhileDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreKillWhileDead");
		
		UYInterface_PlayerScore_ScoreKillWhileDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007705A0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreKillSecondaryWeapon
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ScoreKillSecondaryWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreKillSecondaryWeapon");
		
		UYInterface_PlayerScore_ScoreKillSecondaryWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770580
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreKillPrimaryWeapon
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ScoreKillPrimaryWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreKillPrimaryWeapon");
		
		UYInterface_PlayerScore_ScoreKillPrimaryWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007704F0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreKill
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class AController*                                 killed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::ScoreKill(class AController* killed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreKill");
		
		UYInterface_PlayerScore_ScoreKill_Params params {};
		params.killed = killed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007704D0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreFighterJetDeath
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ScoreFighterJetDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreFighterJetDeath");
		
		UYInterface_PlayerScore_ScoreFighterJetDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770380
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreDeath
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::ScoreDeath(class AController* Killer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreDeath");
		
		UYInterface_PlayerScore_ScoreDeath_Params params {};
		params.Killer = Killer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770360
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ScoreAssist
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ScoreAssist()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ScoreAssist");
		
		UYInterface_PlayerScore_ScoreAssist_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759A10
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetTeamIPS
	 * 		Flags  -> (Native, Public, Const)
	 */
	EYTeam UYInterface_PlayerScore::GetTeamIPS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetTeamIPS");
		
		UYInterface_PlayerScore_GetTeamIPS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757A50
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetRawDamageReceivedTotal
	 * 		Flags  -> (Native, Public)
	 */
	float UYInterface_PlayerScore::GetRawDamageReceivedTotal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetRawDamageReceivedTotal");
		
		UYInterface_PlayerScore_GetRawDamageReceivedTotal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757990
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetRawDamageReceivedThisLife
	 * 		Flags  -> (Native, Public)
	 */
	float UYInterface_PlayerScore::GetRawDamageReceivedThisLife()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetRawDamageReceivedThisLife");
		
		UYInterface_PlayerScore_GetRawDamageReceivedThisLife_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757830
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetRampageCounter
	 * 		Flags  -> (Native, Public, Const)
	 */
	int32_t UYInterface_PlayerScore::GetRampageCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetRampageCounter");
		
		UYInterface_PlayerScore_GetRampageCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756D70
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetPlayerName
	 * 		Flags  -> (Native, Public, Const)
	 */
	class FString UYInterface_PlayerScore::GetPlayerName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetPlayerName");
		
		UYInterface_PlayerScore_GetPlayerName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753650
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetLastTimeDamagedEnemy
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        Enemy                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UYInterface_PlayerScore::GetLastTimeDamagedEnemy(const class FName& Enemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetLastTimeDamagedEnemy");
		
		UYInterface_PlayerScore_GetLastTimeDamagedEnemy_Params params {};
		params.Enemy = Enemy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753400
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetLastKill
	 * 		Flags  -> (Native, Public, Const)
	 */
	struct FYEventInfo UYInterface_PlayerScore::GetLastKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetLastKill");
		
		UYInterface_PlayerScore_GetLastKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753240
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetLastDeath
	 * 		Flags  -> (Native, Public, Const)
	 */
	struct FYEventInfo UYInterface_PlayerScore::GetLastDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetLastDeath");
		
		UYInterface_PlayerScore_GetLastDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753090
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetKillsList
	 * 		Flags  -> (Native, Public, Const)
	 */
	TArray<struct FYEventInfo> UYInterface_PlayerScore::GetKillsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetKillsList");
		
		UYInterface_PlayerScore_GetKillsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752F10
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetKills
	 * 		Flags  -> (Native, Public)
	 */
	int32_t UYInterface_PlayerScore::GetKills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetKills");
		
		UYInterface_PlayerScore_GetKills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752510
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetHealingDone
	 * 		Flags  -> (Native, Public)
	 */
	float UYInterface_PlayerScore::GetHealingDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetHealingDone");
		
		UYInterface_PlayerScore_GetHealingDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751590
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetDeathsList
	 * 		Flags  -> (Native, Public, Const)
	 */
	TArray<struct FYEventInfo> UYInterface_PlayerScore::GetDeathsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetDeathsList");
		
		UYInterface_PlayerScore_GetDeathsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751380
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetDamageReceivedOnShieldThisLife
	 * 		Flags  -> (Native, Public)
	 */
	float UYInterface_PlayerScore::GetDamageReceivedOnShieldThisLife()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetDamageReceivedOnShieldThisLife");
		
		UYInterface_PlayerScore_GetDamageReceivedOnShieldThisLife_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751260
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetDamageDealtWithWeapons
	 * 		Flags  -> (Native, Public)
	 */
	float UYInterface_PlayerScore::GetDamageDealtWithWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetDamageDealtWithWeapons");
		
		UYInterface_PlayerScore_GetDamageDealtWithWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007511A0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetDamageDealtWithAbilities
	 * 		Flags  -> (Native, Public)
	 */
	float UYInterface_PlayerScore::GetDamageDealtWithAbilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetDamageDealtWithAbilities");
		
		UYInterface_PlayerScore_GetDamageDealtWithAbilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D4F0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.GetAllHealersWithinTimeFrame
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<class FName>                                outHealers                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		float                                              timeFrame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::GetAllHealersWithinTimeFrame(TArray<class FName>* outHealers, float timeFrame)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.GetAllHealersWithinTimeFrame");
		
		UYInterface_PlayerScore_GetAllHealersWithinTimeFrame_Params params {};
		params.timeFrame = timeFrame;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outHealers != nullptr)
			*outHealers = params.outHealers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749990
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.DeactivateRampageCounter
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::DeactivateRampageCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.DeactivateRampageCounter");
		
		UYInterface_PlayerScore_DeactivateRampageCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749970
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.DeactivateMayhamEvent
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::DeactivateMayhamEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.DeactivateMayhamEvent");
		
		UYInterface_PlayerScore_DeactivateMayhamEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743EE0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.CanScoreMayham
	 * 		Flags  -> (Native, Public, Const)
	 */
	bool UYInterface_PlayerScore::CanScoreMayham()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.CanScoreMayham");
		
		UYInterface_PlayerScore_CanScoreMayham_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741FC0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AwardMVP
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::AwardMVP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AwardMVP");
		
		UYInterface_PlayerScore_AwardMVP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740740
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AddScore
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYReputationPoolType                               reputationSourceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::AddScore(int32_t Score, EYReputationPoolType reputationSourceType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AddScore");
		
		UYInterface_PlayerScore_AddScore_Params params {};
		params.Score = Score;
		params.reputationSourceType = reputationSourceType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007405A0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AddRawDamageReceived
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              currentHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::AddRawDamageReceived(float DamageAmount, float currentHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AddRawDamageReceived");
		
		UYInterface_PlayerScore_AddRawDamageReceived_Params params {};
		params.DamageAmount = DamageAmount;
		params.currentHealth = currentHealth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F010
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AddHealingDone
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              healingAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::AddHealingDone(float healingAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AddHealingDone");
		
		UYInterface_PlayerScore_AddHealingDone_Params params {};
		params.healingAmount = healingAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073ECA0
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AddDamageReceivedOnShield
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::AddDamageReceivedOnShield(float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AddDamageReceivedOnShield");
		
		UYInterface_PlayerScore_AddDamageReceivedOnShield_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073EC20
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AddDamageReceived
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::AddDamageReceived(float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AddDamageReceived");
		
		UYInterface_PlayerScore_AddDamageReceived_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073EB50
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AddDamageDealtWithWeapons
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 enemyController                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::AddDamageDealtWithWeapons(float DamageAmount, class AController* enemyController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AddDamageDealtWithWeapons");
		
		UYInterface_PlayerScore_AddDamageDealtWithWeapons_Params params {};
		params.DamageAmount = DamageAmount;
		params.enemyController = enemyController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073EA80
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.AddDamageDealtWithAbilities
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 enemyController                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_PlayerScore::AddDamageDealtWithAbilities(float DamageAmount, class AController* enemyController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.AddDamageDealtWithAbilities");
		
		UYInterface_PlayerScore_AddDamageDealtWithAbilities_Params params {};
		params.DamageAmount = DamageAmount;
		params.enemyController = enemyController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D630
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ActivateRampageCounter
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ActivateRampageCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ActivateRampageCounter");
		
		UYInterface_PlayerScore_ActivateRampageCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D220
	 * 		Name   -> Function DreadGame.YInterface_PlayerScore.ActivateMayhamEvent
	 * 		Flags  -> (Native, Public)
	 */
	void UYInterface_PlayerScore::ActivateMayhamEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerScore.ActivateMayhamEvent");
		
		UYInterface_PlayerScore_ActivateMayhamEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInterface_PlayerScore.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInterface_PlayerScore::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInterface_PlayerScore");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783300
	 * 		Name   -> Function DreadGame.YPawn.UpdateEnergyWheelOnWeapons
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             activeEnergyWheelFunction                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::UpdateEnergyWheelOnWeapons(EYEnergyWheelSelection activeEnergyWheelFunction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.UpdateEnergyWheelOnWeapons");
		
		AYPawn_UpdateEnergyWheelOnWeapons_Params params {};
		params.activeEnergyWheelFunction = activeEnergyWheelFunction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782D00
	 * 		Name   -> Function DreadGame.YPawn.TurnRightInputChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              turnRightInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::TurnRightInputChanged(float turnRightInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.TurnRightInputChanged");
		
		AYPawn_TurnRightInputChanged_Params params {};
		params.turnRightInput = turnRightInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782C60
	 * 		Name   -> Function DreadGame.YPawn.TriggerWwiseEvent
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UAkAudioEvent*                               audioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::TriggerWwiseEvent(class UAkAudioEvent* audioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.TriggerWwiseEvent");
		
		AYPawn_TriggerWwiseEvent_Params params {};
		params.audioEvent = audioEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782850
	 * 		Name   -> Function DreadGame.YPawn.TriggerShipSound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::TriggerShipSound(class UAkAudioEvent* Sound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.TriggerShipSound");
		
		AYPawn_TriggerShipSound_Params params {};
		params.Sound = Sound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782460
	 * 		Name   -> Function DreadGame.YPawn.TriggerKillCameraSequence
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPawn::TriggerKillCameraSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.TriggerKillCameraSequence");
		
		AYPawn_TriggerKillCameraSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781590
	 * 		Name   -> Function DreadGame.YPawn.ToggleSoftCollision
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPawn::ToggleSoftCollision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ToggleSoftCollision");
		
		AYPawn_ToggleSoftCollision_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781320
	 * 		Name   -> Function DreadGame.YPawn.ToggleHitMaskAddColor
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPawn::ToggleHitMaskAddColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ToggleHitMaskAddColor");
		
		AYPawn_ToggleHitMaskAddColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781300
	 * 		Name   -> Function DreadGame.YPawn.ToggleHitMask
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPawn::ToggleHitMask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ToggleHitMask");
		
		AYPawn_ToggleHitMask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780D60
	 * 		Name   -> Function DreadGame.YPawn.TeleportIntoLevel
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
	 * Parameters:
	 * 		float                                              randomJumpInTiming                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     teleportingLoc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    teleportingRot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::TeleportIntoLevel(float randomJumpInTiming, const struct FVector& teleportingLoc, const struct FRotator& teleportingRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.TeleportIntoLevel");
		
		AYPawn_TeleportIntoLevel_Params params {};
		params.randomJumpInTiming = randomJumpInTiming;
		params.teleportingLoc = teleportingLoc;
		params.teleportingRot = teleportingRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007809B0
	 * 		Name   -> Function DreadGame.YPawn.SwitchForwardAxisToggle
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPawn::SwitchForwardAxisToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SwitchForwardAxisToggle");
		
		AYPawn_SwitchForwardAxisToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780430
	 * 		Name   -> Function DreadGame.YPawn.StopShipMovements
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDeactivateConstantForce                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::StopShipMovements(bool bDeactivateConstantForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.StopShipMovements");
		
		AYPawn_StopShipMovements_Params params {};
		params.bDeactivateConstantForce = bDeactivateConstantForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8E0
	 * 		Name   -> Function DreadGame.YPawn.StartDebrisDetachment
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            debrisAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              detachingInterval                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::StartDebrisDetachment(int32_t debrisAmount, float detachingInterval)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.StartDebrisDetachment");
		
		AYPawn_StartDebrisDetachment_Params params {};
		params.debrisAmount = debrisAmount;
		params.detachingInterval = detachingInterval;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E490
	 * 		Name   -> Function DreadGame.YPawn.ShowThruster
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AYPawn::ShowThruster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ShowThruster");
		
		AYPawn_ShowThruster_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077DBD0
	 * 		Name   -> Function DreadGame.YPawn.ShowMaxPitchRoll
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPawn::ShowMaxPitchRoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ShowMaxPitchRoll");
		
		AYPawn_ShowMaxPitchRoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B920
	 * 		Name   -> Function DreadGame.YPawn.SetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetTeam(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetTeam");
		
		AYPawn_SetTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B8A0
	 * 		Name   -> Function DreadGame.YPawn.SetTargetVolMult
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              newMult                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetTargetVolMult(float newMult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetTargetVolMult");
		
		AYPawn_SetTargetVolMult_Params params {};
		params.newMult = newMult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B470
	 * 		Name   -> Function DreadGame.YPawn.SetState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipState                                        State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetState(EYShipState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetState");
		
		AYPawn_SetState_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AD70
	 * 		Name   -> Function DreadGame.YPawn.SetShipHidden
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               hidden                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetShipHidden(bool hidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetShipHidden");
		
		AYPawn_SetShipHidden_Params params {};
		params.hidden = hidden;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778880
	 * 		Name   -> Function DreadGame.YPawn.SetLoadout
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYShipLoadout*                               loadout                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetLoadout(class UYShipLoadout* loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetLoadout");
		
		AYPawn_SetLoadout_Params params {};
		params.loadout = loadout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007787C0
	 * 		Name   -> Function DreadGame.YPawn.SetLevelDampingOverwrite
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetLevelDampingOverwrite(float Roll, float Pitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetLevelDampingOverwrite");
		
		AYPawn_SetLevelDampingOverwrite_Params params {};
		params.Roll = Roll;
		params.Pitch = Pitch;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778440
	 * 		Name   -> Function DreadGame.YPawn.SetIgnoredByAI
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               weapons                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               babilities                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behavior                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetIgnoredByAI(bool weapons, bool babilities, bool behavior)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetIgnoredByAI");
		
		AYPawn_SetIgnoredByAI_Params params {};
		params.weapons = weapons;
		params.babilities = babilities;
		params.behavior = behavior;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776090
	 * 		Name   -> Function DreadGame.YPawn.SetCanBeTargeted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               newTargeted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetCanBeTargeted(bool newTargeted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetCanBeTargeted");
		
		AYPawn_SetCanBeTargeted_Params params {};
		params.newTargeted = newTargeted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007754B0
	 * 		Name   -> Function DreadGame.YPawn.SetAIControlled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               isControlledByAI                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetAIControlled(bool isControlledByAI)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetAIControlled");
		
		AYPawn_SetAIControlled_Params params {};
		params.isControlledByAI = isControlledByAI;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007756D0
	 * 		Name   -> Function DreadGame.YPawn.SetActiveEnergyWheelFunction
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             activeEnergyWheelFunction                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::SetActiveEnergyWheelFunction(EYEnergyWheelSelection activeEnergyWheelFunction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.SetActiveEnergyWheelFunction");
		
		AYPawn_SetActiveEnergyWheelFunction_Params params {};
		params.activeEnergyWheelFunction = activeEnergyWheelFunction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007749F0
	 * 		Name   -> Function DreadGame.YPawn.ServerToggleSoftCollision
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPawn::ServerToggleSoftCollision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ServerToggleSoftCollision");
		
		AYPawn_ServerToggleSoftCollision_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007729E0
	 * 		Name   -> Function DreadGame.YPawn.ServerRequestProjectilesInRange
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              squaredRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYProjectileRangeFilter                            filterType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ServerRequestProjectilesInRange(const struct FVector& Location, float squaredRange, EYProjectileRangeFilter filterType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ServerRequestProjectilesInRange");
		
		AYPawn_ServerRequestProjectilesInRange_Params params {};
		params.Location = Location;
		params.squaredRange = squaredRange;
		params.filterType = filterType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772200
	 * 		Name   -> Function DreadGame.YPawn.ServerOnFeat
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            nr                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ServerOnFeat(int32_t nr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ServerOnFeat");
		
		AYPawn_ServerOnFeat_Params params {};
		params.nr = nr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E740
	 * 		Name   -> Function DreadGame.YPawn.RecreatePhysicState
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::RecreatePhysicState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.RecreatePhysicState");
		
		AYPawn_RecreatePhysicState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.ReceiveShieldSpawnedAndAttached
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYPawn::ReceiveShieldSpawnedAndAttached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ReceiveShieldSpawnedAndAttached");
		
		AYPawn_ReceiveShieldSpawnedAndAttached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.ReceiveAnyHealth
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              HealthAmt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      HealthCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ReceiveAnyHealth(float HealthAmt, class AController* InstigatedBy, class AActor* HealthCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ReceiveAnyHealth");
		
		AYPawn_ReceiveAnyHealth_Params params {};
		params.HealthAmt = HealthAmt;
		params.InstigatedBy = InstigatedBy;
		params.HealthCauser = HealthCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.ReceiveActiveWeaponGroupChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYPawn::ReceiveActiveWeaponGroupChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ReceiveActiveWeaponGroupChanged");
		
		AYPawn_ReceiveActiveWeaponGroupChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DE30
	 * 		Name   -> Function DreadGame.YPawn.PredictPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            iterations                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AYPawn::PredictPosition(float DeltaTime, int32_t iterations)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.PredictPosition");
		
		AYPawn_PredictPosition_Params params {};
		params.DeltaTime = DeltaTime;
		params.iterations = iterations;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D910
	 * 		Name   -> Function DreadGame.YPawn.PlayWarpJumpWarmUp
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     warpTargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::PlayWarpJumpWarmUp(const struct FVector& warpTargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.PlayWarpJumpWarmUp");
		
		AYPawn_PlayWarpJumpWarmUp_Params params {};
		params.warpTargetLocation = warpTargetLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D770
	 * 		Name   -> Function DreadGame.YPawn.PlayWarpJumpOut
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsInOrbit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               suppressGenericAudio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::PlayWarpJumpOut(bool IsInOrbit, bool suppressGenericAudio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.PlayWarpJumpOut");
		
		AYPawn_PlayWarpJumpOut_Params params {};
		params.IsInOrbit = IsInOrbit;
		params.suppressGenericAudio = suppressGenericAudio;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D5D0
	 * 		Name   -> Function DreadGame.YPawn.PlayWarpJumpIn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsInOrbit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               suppressGenericAudio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::PlayWarpJumpIn(bool IsInOrbit, bool suppressGenericAudio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.PlayWarpJumpIn");
		
		AYPawn_PlayWarpJumpIn_Params params {};
		params.IsInOrbit = IsInOrbit;
		params.suppressGenericAudio = suppressGenericAudio;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnTurnRightInputChanged
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              turnRightInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnTurnRightInputChanged(float turnRightInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnTurnRightInputChanged");
		
		AYPawn_OnTurnRightInputChanged_Params params {};
		params.turnRightInput = turnRightInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnResetAbilityVisuals
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYPawn::OnResetAbilityVisuals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnResetAbilityVisuals");
		
		AYPawn_OnResetAbilityVisuals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007691C0
	 * 		Name   -> Function DreadGame.YPawn.OnRep_Team
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYPawn::OnRep_Team()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnRep_Team");
		
		AYPawn_OnRep_Team_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769080
	 * 		Name   -> Function DreadGame.YPawn.OnRep_Shield
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::OnRep_Shield()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnRep_Shield");
		
		AYPawn_OnRep_Shield_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768E80
	 * 		Name   -> Function DreadGame.YPawn.OnRep_NPCState
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYPawn::OnRep_NPCState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnRep_NPCState");
		
		AYPawn_OnRep_NPCState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768C80
	 * 		Name   -> Function DreadGame.YPawn.OnRep_DeathData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::OnRep_DeathData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnRep_DeathData");
		
		AYPawn_OnRep_DeathData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnReadyToInitHitmask
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 */
	void AYPawn::OnReadyToInitHitmask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnReadyToInitHitmask");
		
		AYPawn_OnReadyToInitHitmask_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnPlayFinalDeathExplosion
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 */
	void AYPawn::OnPlayFinalDeathExplosion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnPlayFinalDeathExplosion");
		
		AYPawn_OnPlayFinalDeathExplosion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnPlayerDying
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Momentum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnPlayerDying(float Damage, class APawn* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UDamageType* DamageType, const struct FHitResult& HitInfo, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnPlayerDying");
		
		AYPawn_OnPlayerDying_Params params {};
		params.Damage = Damage;
		params.InstigatedBy = InstigatedBy;
		params.HitLocation = HitLocation;
		params.Momentum = Momentum;
		params.DamageType = DamageType;
		params.HitInfo = HitInfo;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnMoveUpInputChanged
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              moveUpInput                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnMoveUpInputChanged(float moveUpInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnMoveUpInputChanged");
		
		AYPawn_OnMoveUpInputChanged_Params params {};
		params.moveUpInput = moveUpInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnMoveRightInputChanged
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              moveRightInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnMoveRightInputChanged(float moveRightInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnMoveRightInputChanged");
		
		AYPawn_OnMoveRightInputChanged_Params params {};
		params.moveRightInput = moveRightInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnMoveForwardInputChanged
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              moveForwardInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnMoveForwardInputChanged(float moveForwardInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnMoveForwardInputChanged");
		
		AYPawn_OnMoveForwardInputChanged_Params params {};
		params.moveForwardInput = moveForwardInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnHitzoneDestroyed
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            groupID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnHitzoneDestroyed(int32_t groupID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnHitzoneDestroyed");
		
		AYPawn_OnHitzoneDestroyed_Params params {};
		params.groupID = groupID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnFinishPlayerDeathAnimation
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 */
	void AYPawn::OnFinishPlayerDeathAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnFinishPlayerDeathAnimation");
		
		AYPawn_OnFinishPlayerDeathAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763DF0
	 * 		Name   -> Function DreadGame.YPawn.OnFeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            nr                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnFeat(int32_t nr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnFeat");
		
		AYPawn_OnFeat_Params params {};
		params.nr = nr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawn.OnDetachDebris
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              totalDetachingDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnDetachDebris(float totalDetachingDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnDetachDebris");
		
		AYPawn_OnDetachDebris_Params params {};
		params.totalDetachingDuration = totalDetachingDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762030
	 * 		Name   -> Function DreadGame.YPawn.OnAbilityCooldownFinished
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::OnAbilityCooldownFinished(class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.OnAbilityCooldownFinished");
		
		AYPawn_OnAbilityCooldownFinished_Params params {};
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761E80
	 * 		Name   -> Function DreadGame.YPawn.NotifyOwnerOfHit
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     damageDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::NotifyOwnerOfHit(const struct FVector& damageDirection, float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.NotifyOwnerOfHit");
		
		AYPawn_NotifyOwnerOfHit_Params params {};
		params.damageDirection = damageDirection;
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761770
	 * 		Name   -> Function DreadGame.YPawn.MulticastToggleSoftCollision
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AYPawn::MulticastToggleSoftCollision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.MulticastToggleSoftCollision");
		
		AYPawn_MulticastToggleSoftCollision_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761310
	 * 		Name   -> Function DreadGame.YPawn.MulticastOnFeat
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		int32_t                                            nr                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::MulticastOnFeat(int32_t nr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.MulticastOnFeat");
		
		AYPawn_MulticastOnFeat_Params params {};
		params.nr = nr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007611F0
	 * 		Name   -> Function DreadGame.YPawn.MoveUpInputChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              moveUpInput                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::MoveUpInputChanged(float moveUpInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.MoveUpInputChanged");
		
		AYPawn_MoveUpInputChanged_Params params {};
		params.moveUpInput = moveUpInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761170
	 * 		Name   -> Function DreadGame.YPawn.MoveRightInputChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              moveRightInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::MoveRightInputChanged(float moveRightInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.MoveRightInputChanged");
		
		AYPawn_MoveRightInputChanged_Params params {};
		params.moveRightInput = moveRightInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007610F0
	 * 		Name   -> Function DreadGame.YPawn.MoveForwardInputChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              moveForwardInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::MoveForwardInputChanged(float moveForwardInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.MoveForwardInputChanged");
		
		AYPawn_MoveForwardInputChanged_Params params {};
		params.moveForwardInput = moveForwardInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760F60
	 * 		Name   -> Function DreadGame.YPawn.ModifyEnergy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              energyModifier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ModifyEnergy(float energyModifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ModifyEnergy");
		
		AYPawn_ModifyEnergy_Params params {};
		params.energyModifier = energyModifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007605F0
	 * 		Name   -> Function DreadGame.YPawn.LoadLoadoutAssets
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               asyncLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYPawn::LoadLoadoutAssets(bool asyncLoad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.LoadLoadoutAssets");
		
		AYPawn_LoadLoadoutAssets_Params params {};
		params.asyncLoad = asyncLoad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760000
	 * 		Name   -> Function DreadGame.YPawn.ItemsAsyncLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::ItemsAsyncLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ItemsAsyncLoaded");
		
		AYPawn_ItemsAsyncLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FBA0
	 * 		Name   -> Function DreadGame.YPawn.IsTeammateOfLocalPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPawn::IsTeammateOfLocalPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsTeammateOfLocalPlayer");
		
		AYPawn_IsTeammateOfLocalPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F840
	 * 		Name   -> Function DreadGame.YPawn.IsRendered
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYPawn::IsRendered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsRendered");
		
		AYPawn_IsRendered_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F5A0
	 * 		Name   -> Function DreadGame.YPawn.IsPlayingWarpJump
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYPawn::IsPlayingWarpJump()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsPlayingWarpJump");
		
		AYPawn_IsPlayingWarpJump_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EDA0
	 * 		Name   -> Function DreadGame.YPawn.IsIgnoredByAIWeapons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPawn::IsIgnoredByAIWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsIgnoredByAIWeapons");
		
		AYPawn_IsIgnoredByAIWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ED70
	 * 		Name   -> Function DreadGame.YPawn.IsIgnoredByAIBehaviour
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPawn::IsIgnoredByAIBehaviour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsIgnoredByAIBehaviour");
		
		AYPawn_IsIgnoredByAIBehaviour_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ED40
	 * 		Name   -> Function DreadGame.YPawn.IsIgnoredByAIAbilities
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPawn::IsIgnoredByAIAbilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsIgnoredByAIAbilities");
		
		AYPawn_IsIgnoredByAIAbilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E540
	 * 		Name   -> Function DreadGame.YPawn.IsDead
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYPawn::IsDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsDead");
		
		AYPawn_IsDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DF70
	 * 		Name   -> Function DreadGame.YPawn.IsAbilityTargeted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYPawn::IsAbilityTargeted(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.IsAbilityTargeted");
		
		AYPawn_IsAbilityTargeted_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D0A0
	 * 		Name   -> Function DreadGame.YPawn.InitShipCustomisation
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::InitShipCustomisation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.InitShipCustomisation");
		
		AYPawn_InitShipCustomisation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D080
	 * 		Name   -> Function DreadGame.YPawn.InitOfficers
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::InitOfficers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.InitOfficers");
		
		AYPawn_InitOfficers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DA40
	 * 		Name   -> Function DreadGame.YPawn.InitializeWeaponsOnManager
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYPawn::InitializeWeaponsOnManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.InitializeWeaponsOnManager");
		
		AYPawn_InitializeWeaponsOnManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D620
	 * 		Name   -> Function DreadGame.YPawn.InitializeHitMask
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::InitializeHitMask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.InitializeHitMask");
		
		AYPawn_InitializeHitMask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D060
	 * 		Name   -> Function DreadGame.YPawn.InitHud
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::InitHud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.InitHud");
		
		AYPawn_InitHud_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CEA0
	 * 		Name   -> Function DreadGame.YPawn.InitAbilities
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPawn::InitAbilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.InitAbilities");
		
		AYPawn_InitAbilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E5F250
	 * 		Name   -> Function DreadGame.YPawn.HideThruster
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AYPawn::HideThruster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.HideThruster");
		
		AYPawn_HideThruster_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C4C0
	 * 		Name   -> Function DreadGame.YPawn.HasLoadoutInfo
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	bool AYPawn::HasLoadoutInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.HasLoadoutInfo");
		
		AYPawn_HasLoadoutInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075AAF0
	 * 		Name   -> Function DreadGame.YPawn.GetWorldTimeSeconds
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetWorldTimeSeconds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetWorldTimeSeconds");
		
		AYPawn_GetWorldTimeSeconds_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A650
	 * 		Name   -> Function DreadGame.YPawn.GetWeaponManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYWeaponManagerComponent* AYPawn::GetWeaponManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetWeaponManager");
		
		AYPawn_GetWeaponManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A470
	 * 		Name   -> Function DreadGame.YPawn.GetVerticalInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetVerticalInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetVerticalInput");
		
		AYPawn_GetVerticalInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759D50
	 * 		Name   -> Function DreadGame.YPawn.GetThrottleInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetThrottleInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetThrottleInput");
		
		AYPawn_GetThrottleInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759C00
	 * 		Name   -> Function DreadGame.YPawn.GetTerritory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetTerritory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetTerritory");
		
		AYPawn_GetTerritory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759840
	 * 		Name   -> Function DreadGame.YPawn.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam AYPawn::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetTeam");
		
		AYPawn_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759700
	 * 		Name   -> Function DreadGame.YPawn.GetTargetedByList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class AActor*> AYPawn::GetTargetedByList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetTargetedByList");
		
		AYPawn_GetTargetedByList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759460
	 * 		Name   -> Function DreadGame.YPawn.GetSteeringInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetSteeringInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetSteeringInput");
		
		AYPawn_GetSteeringInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758490
	 * 		Name   -> Function DreadGame.YPawn.GetState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYShipState AYPawn::GetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetState");
		
		AYPawn_GetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758940
	 * 		Name   -> Function DreadGame.YPawn.GetShipTier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPawn::GetShipTier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetShipTier");
		
		AYPawn_GetShipTier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758910
	 * 		Name   -> Function DreadGame.YPawn.GetShipSoundComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UAkComponent* AYPawn::GetShipSoundComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetShipSoundComponent");
		
		AYPawn_GetShipSoundComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007588A0
	 * 		Name   -> Function DreadGame.YPawn.GetShipHidden
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYPawn::GetShipHidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetShipHidden");
		
		AYPawn_GetShipHidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758410
	 * 		Name   -> Function DreadGame.YPawn.GetShipClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYShipClass AYPawn::GetShipClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetShipClass");
		
		AYPawn_GetShipClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007581D0
	 * 		Name   -> Function DreadGame.YPawn.GetShieldMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetShieldMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetShieldMaxHealth");
		
		AYPawn_GetShieldMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007581A0
	 * 		Name   -> Function DreadGame.YPawn.GetShieldHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetShieldHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetShieldHealth");
		
		AYPawn_GetShieldHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757B70
	 * 		Name   -> Function DreadGame.YPawn.GetRenderedPawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class AYPawn*> AYPawn::GetRenderedPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetRenderedPawns");
		
		AYPawn_GetRenderedPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757150
	 * 		Name   -> Function DreadGame.YPawn.GetPrecastLoadoutID
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	int32_t AYPawn::GetPrecastLoadoutID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetPrecastLoadoutID");
		
		AYPawn_GetPrecastLoadoutID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756CF0
	 * 		Name   -> Function DreadGame.YPawn.GetPlayerName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString AYPawn::GetPlayerName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetPlayerName");
		
		AYPawn_GetPlayerName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754400
	 * 		Name   -> Function DreadGame.YPawn.GetModifiedMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetModifiedMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetModifiedMaxHealth");
		
		AYPawn_GetModifiedMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754310
	 * 		Name   -> Function DreadGame.YPawn.GetModifiedFuelConsumption
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              unmodifiedValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AYPawn::GetModifiedFuelConsumption(float unmodifiedValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetModifiedFuelConsumption");
		
		AYPawn_GetModifiedFuelConsumption_Params params {};
		params.unmodifiedValue = unmodifiedValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753CA0
	 * 		Name   -> Function DreadGame.YPawn.GetMIDs
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UMaterialInstanceDynamic*>            pawnMIDs                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::GetMIDs(TArray<class UMaterialInstanceDynamic*>* pawnMIDs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetMIDs");
		
		AYPawn_GetMIDs_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (pawnMIDs != nullptr)
			*pawnMIDs = params.pawnMIDs;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753FA0
	 * 		Name   -> Function DreadGame.YPawn.GetMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetMaxHealth");
		
		AYPawn_GetMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753F10
	 * 		Name   -> Function DreadGame.YPawn.GetMaxEnergy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetMaxEnergy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetMaxEnergy");
		
		AYPawn_GetMaxEnergy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753A60
	 * 		Name   -> Function DreadGame.YPawn.GetLoadoutInfoCopy
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	struct FYShipLoadoutInfo AYPawn::GetLoadoutInfoCopy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetLoadoutInfoCopy");
		
		AYPawn_GetLoadoutInfoCopy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753A20
	 * 		Name   -> Function DreadGame.YPawn.GetLoadoutInfo
	 * 		Flags  -> (Final, Native, Public)
	 */
	struct FYShipLoadoutInfo AYPawn::GetLoadoutInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetLoadoutInfo");
		
		AYPawn_GetLoadoutInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753760
	 * 		Name   -> Function DreadGame.YPawn.GetLevelDampingOverwriteRoll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPawn::GetLevelDampingOverwriteRoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetLevelDampingOverwriteRoll");
		
		AYPawn_GetLevelDampingOverwriteRoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753730
	 * 		Name   -> Function DreadGame.YPawn.GetLevelDampingOverwritePitch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPawn::GetLevelDampingOverwritePitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetLevelDampingOverwritePitch");
		
		AYPawn_GetLevelDampingOverwritePitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753450
	 * 		Name   -> Function DreadGame.YPawn.GetLastRenderTimeFromPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetLastRenderTimeFromPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetLastRenderTimeFromPawn");
		
		AYPawn_GetLastRenderTimeFromPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753280
	 * 		Name   -> Function DreadGame.YPawn.GetLastFiredAtPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYPawn* AYPawn::GetLastFiredAtPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetLastFiredAtPawn");
		
		AYPawn_GetLastFiredAtPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007525D0
	 * 		Name   -> Function DreadGame.YPawn.GetHealthComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYHealthComponent* AYPawn::GetHealthComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetHealthComponent");
		
		AYPawn_GetHealthComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007525A0
	 * 		Name   -> Function DreadGame.YPawn.GetHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetHealth");
		
		AYPawn_GetHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007519F0
	 * 		Name   -> Function DreadGame.YPawn.GetFeatsComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYFeatsComponent* AYPawn::GetFeatsComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetFeatsComponent");
		
		AYPawn_GetFeatsComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007517F0
	 * 		Name   -> Function DreadGame.YPawn.GetEnergy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYPawn::GetEnergy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetEnergy");
		
		AYPawn_GetEnergy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750F30
	 * 		Name   -> Function DreadGame.YPawn.GetCustomizationComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYShipCustomizationComponent* AYPawn::GetCustomizationComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetCustomizationComponent");
		
		AYPawn_GetCustomizationComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750ED0
	 * 		Name   -> Function DreadGame.YPawn.GetCurrentWeaponSpread
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPawn::GetCurrentWeaponSpread()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetCurrentWeaponSpread");
		
		AYPawn_GetCurrentWeaponSpread_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750660
	 * 		Name   -> Function DreadGame.YPawn.GetCurrentCapturePoint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYCapturePoint* AYPawn::GetCurrentCapturePoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetCurrentCapturePoint");
		
		AYPawn_GetCurrentCapturePoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EE20
	 * 		Name   -> Function DreadGame.YPawn.GetClosestFlank
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     fromHere                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              flankDistance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AYPawn::GetClosestFlank(const struct FVector& fromHere, float flankDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetClosestFlank");
		
		AYPawn_GetClosestFlank_Params params {};
		params.fromHere = fromHere;
		params.flankDistance = flankDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E050
	 * 		Name   -> Function DreadGame.YPawn.GetBuffsComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYBuffsComponent* AYPawn::GetBuffsComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetBuffsComponent");
		
		AYPawn_GetBuffsComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DB90
	 * 		Name   -> Function DreadGame.YPawn.GetBackPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              backDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AYPawn::GetBackPosition(float backDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetBackPosition");
		
		AYPawn_GetBackPosition_Params params {};
		params.backDistance = backDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D8F0
	 * 		Name   -> Function DreadGame.YPawn.GetAttachments
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::GetAttachments(TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetAttachments");
		
		AYPawn_GetAttachments_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CF30
	 * 		Name   -> Function DreadGame.YPawn.GetActiveWeaponGroup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYPawn::GetActiveWeaponGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetActiveWeaponGroup");
		
		AYPawn_GetActiveWeaponGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CCC0
	 * 		Name   -> Function DreadGame.YPawn.GetActiveEnergyWheelFunction
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	EYEnergyWheelSelection AYPawn::GetActiveEnergyWheelFunction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetActiveEnergyWheelFunction");
		
		AYPawn_GetActiveEnergyWheelFunction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CC50
	 * 		Name   -> Function DreadGame.YPawn.GetAbilityManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYAbilityManager* AYPawn::GetAbilityManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.GetAbilityManager");
		
		AYPawn_GetAbilityManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPawn.EnergyRegenerated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPawn::EnergyRegenerated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.EnergyRegenerated");
		
		AYPawn_EnergyRegenerated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BA70
	 * 		Name   -> Function DreadGame.YPawn.EnergyDepleted
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPawn::EnergyDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.EnergyDepleted");
		
		AYPawn_EnergyDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B7A0
	 * 		Name   -> Function DreadGame.YPawn.EnableWarpJumpOnDeath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::EnableWarpJumpOnDeath(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.EnableWarpJumpOnDeath");
		
		AYPawn_EnableWarpJumpOnDeath_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B6D0
	 * 		Name   -> Function DreadGame.YPawn.EnableShipHighlighting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPawn::EnableShipHighlighting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.EnableShipHighlighting");
		
		AYPawn_EnableShipHighlighting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B5F0
	 * 		Name   -> Function DreadGame.YPawn.EnableGravity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPawn::EnableGravity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.EnableGravity");
		
		AYPawn_EnableGravity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B310
	 * 		Name   -> Function DreadGame.YPawn.DumpAllHitMask
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPawn::DumpAllHitMask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.DumpAllHitMask");
		
		AYPawn_DumpAllHitMask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AB30
	 * 		Name   -> Function DreadGame.YPawn.DisableShipHighlighting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPawn::DisableShipHighlighting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.DisableShipHighlighting");
		
		AYPawn_DisableShipHighlighting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AAE0
	 * 		Name   -> Function DreadGame.YPawn.DisableGravity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPawn::DisableGravity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.DisableGravity");
		
		AYPawn_DisableGravity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A880
	 * 		Name   -> Function DreadGame.YPawn.DevSetIgnoredByAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               weapons                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               babilities                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behavior                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::DevSetIgnoredByAI(bool weapons, bool babilities, bool behavior)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.DevSetIgnoredByAI");
		
		AYPawn_DevSetIgnoredByAI_Params params {};
		params.weapons = weapons;
		params.babilities = babilities;
		params.behavior = behavior;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YPawn.DevSetCanBeTargeted
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               newTargeted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::DevSetCanBeTargeted(bool newTargeted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.DevSetCanBeTargeted");
		
		AYPawn_DevSetCanBeTargeted_Params params {};
		params.newTargeted = newTargeted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A700
	 * 		Name   -> Function DreadGame.YPawn.DetachCameraUponDeath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPawn::DetachCameraUponDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.DetachCameraUponDeath");
		
		AYPawn_DetachCameraUponDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007498A0
	 * 		Name   -> Function DreadGame.YPawn.DeactivateCloakMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AYPawn::DeactivateCloakMulticast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.DeactivateCloakMulticast");
		
		AYPawn_DeactivateCloakMulticast_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747790
	 * 		Name   -> Function DreadGame.YPawn.ClientTriggerDamageFeedback
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class AActor*                                      hitActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageAmount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     impactLocation                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               damageFromAbility                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ClientTriggerDamageFeedback(class AActor* hitActor, float DamageAmount, const struct FVector& impactLocation, bool damageFromAbility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ClientTriggerDamageFeedback");
		
		AYPawn_ClientTriggerDamageFeedback_Params params {};
		params.hitActor = hitActor;
		params.DamageAmount = DamageAmount;
		params.impactLocation = impactLocation;
		params.damageFromAbility = damageFromAbility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746340
	 * 		Name   -> Function DreadGame.YPawn.ClientReceiveProjectilesInRange
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FYProjectileServerData>              projectileServerData                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ClientReceiveProjectilesInRange(TArray<struct FYProjectileServerData> projectileServerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ClientReceiveProjectilesInRange");
		
		AYPawn_ClientReceiveProjectilesInRange_Params params {};
		params.projectileServerData = projectileServerData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007458D0
	 * 		Name   -> Function DreadGame.YPawn.ClientNotifyDamageLocation
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     damageVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     damageLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<int32_t>                                    hitzonesDestroyed                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ClientNotifyDamageLocation(const struct FVector& damageVector, const struct FVector& damageLocation, TArray<int32_t> hitzonesDestroyed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ClientNotifyDamageLocation");
		
		AYPawn_ClientNotifyDamageLocation_Params params {};
		params.damageVector = damageVector;
		params.damageLocation = damageLocation;
		params.hitzonesDestroyed = hitzonesDestroyed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007451E0
	 * 		Name   -> Function DreadGame.YPawn.ClientEnergyDepleted
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 */
	void AYPawn::ClientEnergyDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ClientEnergyDepleted");
		
		AYPawn_ClientEnergyDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745110
	 * 		Name   -> Function DreadGame.YPawn.ClientEnemyGotHit
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		EYHitIndicatorType                                 Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isBeamWeapon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::ClientEnemyGotHit(EYHitIndicatorType Type, bool isBeamWeapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.ClientEnemyGotHit");
		
		AYPawn_ClientEnemyGotHit_Params params {};
		params.Type = Type;
		params.isBeamWeapon = isBeamWeapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743CD0
	 * 		Name   -> Function DreadGame.YPawn.CanBeTargeted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPawn::CanBeTargeted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.CanBeTargeted");
		
		AYPawn_CanBeTargeted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742D50
	 * 		Name   -> Function DreadGame.YPawn.CallTeleportIntoLevel
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		float                                              randomJumpInTiming                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     teleportingLoc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    teleportingRot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPawn::CallTeleportIntoLevel(float randomJumpInTiming, const struct FVector& teleportingLoc, const struct FRotator& teleportingRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawn.CallTeleportIntoLevel");
		
		AYPawn_CallTeleportIntoLevel_Params params {};
		params.randomJumpInTiming = randomJumpInTiming;
		params.teleportingLoc = teleportingLoc;
		params.teleportingRot = teleportingRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007701C0
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.RetrieveYPawn
	 * 		Flags  -> (Native, Public, Const)
	 */
	class AYPawn* UYInterface_PlayerInfo::RetrieveYPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.RetrieveYPawn");
		
		UYInterface_PlayerInfo_RetrieveYPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759B10
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetTeam_IPI
	 * 		Flags  -> (Native, Public)
	 */
	EYTeam UYInterface_PlayerInfo::GetTeam_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetTeam_IPI");
		
		UYInterface_PlayerInfo_GetTeam_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007588D0
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetShipLoadoutInfo_IPI
	 * 		Flags  -> (Native, Public)
	 */
	struct FYShipLoadoutInfo UYInterface_PlayerInfo::GetShipLoadoutInfo_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetShipLoadoutInfo_IPI");
		
		UYInterface_PlayerInfo_GetShipLoadoutInfo_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758860
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetShipClass_IPI
	 * 		Flags  -> (Native, Public)
	 */
	EYShipClass UYInterface_PlayerInfo::GetShipClass_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetShipClass_IPI");
		
		UYInterface_PlayerInfo_GetShipClass_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757E00
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetScore_IPI
	 * 		Flags  -> (Native, Public)
	 */
	int32_t UYInterface_PlayerInfo::GetScore_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetScore_IPI");
		
		UYInterface_PlayerInfo_GetScore_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757C20
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetReputationManager_IPI
	 * 		Flags  -> (Native, Public)
	 */
	class UYReputationManager* UYInterface_PlayerInfo::GetReputationManager_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetReputationManager_IPI");
		
		UYInterface_PlayerInfo_GetReputationManager_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757180
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetPrecastLoadoutID_IPI
	 * 		Flags  -> (Native, Public)
	 */
	int32_t UYInterface_PlayerInfo::GetPrecastLoadoutID_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetPrecastLoadoutID_IPI");
		
		UYInterface_PlayerInfo_GetPrecastLoadoutID_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751590
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetPlayerUniqueID_IPI
	 * 		Flags  -> (Native, Public)
	 */
	class FString UYInterface_PlayerInfo::GetPlayerUniqueID_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetPlayerUniqueID_IPI");
		
		UYInterface_PlayerInfo_GetPlayerUniqueID_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755150
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetNextShipLoadoutInfo_IPI
	 * 		Flags  -> (Native, Public)
	 */
	struct FYShipLoadoutInfo UYInterface_PlayerInfo::GetNextShipLoadoutInfo_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetNextShipLoadoutInfo_IPI");
		
		UYInterface_PlayerInfo_GetNextShipLoadoutInfo_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755120
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetNextPrecastLoadoutID_IPI
	 * 		Flags  -> (Native, Public)
	 */
	int32_t UYInterface_PlayerInfo::GetNextPrecastLoadoutID_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetNextPrecastLoadoutID_IPI");
		
		UYInterface_PlayerInfo_GetNextPrecastLoadoutID_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007550E0
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetName_IPI
	 * 		Flags  -> (Native, Public)
	 */
	class FString UYInterface_PlayerInfo::GetName_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetName_IPI");
		
		UYInterface_PlayerInfo_GetName_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751B00
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetFinishedOrbitSelection_IPI
	 * 		Flags  -> (Native, Public)
	 */
	bool UYInterface_PlayerInfo::GetFinishedOrbitSelection_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetFinishedOrbitSelection_IPI");
		
		UYInterface_PlayerInfo_GetFinishedOrbitSelection_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E2E0
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetCaptainIconPath_IPI
	 * 		Flags  -> (Native, Public, Const)
	 */
	class FString UYInterface_PlayerInfo::GetCaptainIconPath_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetCaptainIconPath_IPI");
		
		UYInterface_PlayerInfo_GetCaptainIconPath_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E2A0
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetCaptainDisplayInformation_IPI
	 * 		Flags  -> (Native, Public)
	 */
	class FString UYInterface_PlayerInfo::GetCaptainDisplayInformation_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetCaptainDisplayInformation_IPI");
		
		UYInterface_PlayerInfo_GetCaptainDisplayInformation_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E420
	 * 		Name   -> Function DreadGame.YInterface_PlayerInfo.GetCaptain_IPI
	 * 		Flags  -> (Native, Public)
	 */
	class UYCaptain* UYInterface_PlayerInfo::GetCaptain_IPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_PlayerInfo.GetCaptain_IPI");
		
		UYInterface_PlayerInfo_GetCaptain_IPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInterface_PlayerInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInterface_PlayerInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInterface_PlayerInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityAssetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityAssetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityAssetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityMeshPart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityMeshPart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityMeshPart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783AE0
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.UpdatePattern
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYShipVanityPattern*                         Pattern                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::UpdatePattern(class UYShipVanityPattern* Pattern)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.UpdatePattern");
		
		UYShipCustomizationComponent_UpdatePattern_Params params {};
		params.Pattern = Pattern;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783A60
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.UpdatePaint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYShipVanityPaint*                           paint                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::UpdatePaint(class UYShipVanityPaint* paint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.UpdatePaint");
		
		UYShipCustomizationComponent_UpdatePaint_Params params {};
		params.paint = paint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007837E0
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.UpdateHeroMeshes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UYShipVanityMeshPart*>                parts                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               enqueue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::UpdateHeroMeshes(TArray<class UYShipVanityMeshPart*> parts, bool enqueue, class UObject* context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.UpdateHeroMeshes");
		
		UYShipCustomizationComponent_UpdateHeroMeshes_Params params {};
		params.parts = parts;
		params.enqueue = enqueue;
		params.context = context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783710
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.UpdateHeroMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYMeshPartType                                     meshType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYShipVanityMeshPart*                        meshPart                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::UpdateHeroMesh(EYMeshPartType meshType, class UYShipVanityMeshPart* meshPart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.UpdateHeroMesh");
		
		UYShipCustomizationComponent_UpdateHeroMesh_Params params {};
		params.meshType = meshType;
		params.meshPart = meshPart;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783280
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.UpdateEmblem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYShipVanityEmblem*                          emblem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::UpdateEmblem(class UYShipVanityEmblem* emblem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.UpdateEmblem");
		
		UYShipCustomizationComponent_UpdateEmblem_Params params {};
		params.emblem = emblem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783160
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.UpdateDecal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYShipVanityDecal*                           decal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::UpdateDecal(class UYShipVanityDecal* decal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.UpdateDecal");
		
		UYShipCustomizationComponent_UpdateDecal_Params params {};
		params.decal = decal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AEC0
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.SetShipMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::SetShipMesh(class USkeletalMeshComponent* MeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.SetShipMesh");
		
		UYShipCustomizationComponent_SetShipMesh_Params params {};
		params.MeshComponent = MeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YShipCustomizationComponent.OnPhysicStateChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYShipCustomizationComponent::OnPhysicStateChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YShipCustomizationComponent.OnPhysicStateChanged__DelegateSignature");
		
		UYShipCustomizationComponent_OnPhysicStateChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CBE0
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.ImportPaintFromShipMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMesh*                               shipMesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::ImportPaintFromShipMesh(class USkeletalMesh* shipMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.ImportPaintFromShipMesh");
		
		UYShipCustomizationComponent_ImportPaintFromShipMesh_Params params {};
		params.shipMesh = shipMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CB00
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.ImportFromShipAppereance
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYShipAppeareaceContainer                   shipAppeareaceContainer                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::ImportFromShipAppereance(struct FYShipAppeareaceContainer* shipAppeareaceContainer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.ImportFromShipAppereance");
		
		UYShipCustomizationComponent_ImportFromShipAppereance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (shipAppeareaceContainer != nullptr)
			*shipAppeareaceContainer = params.shipAppeareaceContainer;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CA10
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.ImportFromDisplayInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      importString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::ImportFromDisplayInfo(const class FString& importString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.ImportFromDisplayInfo");
		
		UYShipCustomizationComponent_ImportFromDisplayInfo_Params params {};
		params.importString = importString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C6F0
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.HasShipMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYShipCustomizationComponent::HasShipMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.HasShipMesh");
		
		UYShipCustomizationComponent_HasShipMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BC20
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.ExportToDisplayInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString UYShipCustomizationComponent::ExportToDisplayInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.ExportToDisplayInfo");
		
		UYShipCustomizationComponent_ExportToDisplayInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007424D0
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.BroadcastApperance
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FYShipAppeareaceContainer                   m_appearance                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::BroadcastApperance(const struct FYShipAppeareaceContainer& m_appearance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.BroadcastApperance");
		
		UYShipCustomizationComponent_BroadcastApperance_Params params {};
		params.m_appearance = m_appearance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E080
	 * 		Name   -> Function DreadGame.YShipCustomizationComponent.AddAdditionalMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipCustomizationComponent::AddAdditionalMesh(class USkeletalMeshComponent* MeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationComponent.AddAdditionalMesh");
		
		UYShipCustomizationComponent_AddAdditionalMesh_Params params {};
		params.MeshComponent = MeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipCustomizationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipCustomizationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipCustomizationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipLoadout.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipLoadout::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipLoadout");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770BD0
	 * 		Name   -> Function DreadGame.YLocalServerDataManager.SendOTSDataBunch
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYLocalServerDataManager::SendOTSDataBunch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLocalServerDataManager.SendOTSDataBunch");
		
		UYLocalServerDataManager_SendOTSDataBunch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYLocalServerDataManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYLocalServerDataManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLocalServerDataManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C790
	 * 		Name   -> Function DreadGame.YDreadnoughtExternalFunctions.ForceUpdateComponentToWorld
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYDreadnoughtExternalFunctions::STATIC_ForceUpdateComponentToWorld(class USceneComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadnoughtExternalFunctions.ForceUpdateComponentToWorld");
		
		UYDreadnoughtExternalFunctions_ForceUpdateComponentToWorld_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDreadnoughtExternalFunctions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDreadnoughtExternalFunctions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDreadnoughtExternalFunctions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerMatchStatisticsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerMatchStatisticsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerMatchStatisticsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerMatchStatisticsTestUtils.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerMatchStatisticsTestUtils::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerMatchStatisticsTestUtils");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783D00
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.UpdateTeammatesList
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerReplicationInfo::UpdateTeammatesList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.UpdateTeammatesList");
		
		AYPlayerReplicationInfo_UpdateTeammatesList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007726A0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.ServerReceiveLocalServerOTSData
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		TArray<struct FYJsonObjectRep>                     Data                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EYTuneRepState                                     State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo::ServerReceiveLocalServerOTSData(TArray<struct FYJsonObjectRep> Data, EYTuneRepState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.ServerReceiveLocalServerOTSData");
		
		AYPlayerReplicationInfo_ServerReceiveLocalServerOTSData_Params params {};
		params.Data = Data;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771E20
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.ServerInitializeScoringData
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		TArray<struct FYScoringEvent>                      scoringEvents                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo::ServerInitializeScoringData(TArray<struct FYScoringEvent> scoringEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.ServerInitializeScoringData");
		
		AYPlayerReplicationInfo_ServerInitializeScoringData_Params params {};
		params.scoringEvents = scoringEvents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769200
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_Team
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo::OnRep_Team()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_Team");
		
		AYPlayerReplicationInfo_OnRep_Team_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769120
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_Spotted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerReplicationInfo::OnRep_Spotted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_Spotted");
		
		AYPlayerReplicationInfo_OnRep_Spotted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768CA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_ShipClass
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo::OnRep_ShipClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_ShipClass");
		
		AYPlayerReplicationInfo_OnRep_ShipClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768CA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_Kills
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo::OnRep_Kills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_Kills");
		
		AYPlayerReplicationInfo_OnRep_Kills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768D40
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_FinishedOrbitSelection
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerReplicationInfo::OnRep_FinishedOrbitSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_FinishedOrbitSelection");
		
		AYPlayerReplicationInfo_OnRep_FinishedOrbitSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768CA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_Deaths
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo::OnRep_Deaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_Deaths");
		
		AYPlayerReplicationInfo_OnRep_Deaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768BE0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_Credits
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo::OnRep_Credits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_Credits");
		
		AYPlayerReplicationInfo_OnRep_Credits_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768BA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_CaptainData
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo::OnRep_CaptainData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_CaptainData");
		
		AYPlayerReplicationInfo_OnRep_CaptainData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768CA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.OnRep_Assists
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo::OnRep_Assists()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.OnRep_Assists");
		
		AYPlayerReplicationInfo_OnRep_Assists_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerReplicationInfo.OnPlayerUniqueNetIDSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerReplicationInfo::OnPlayerUniqueNetIDSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerReplicationInfo.OnPlayerUniqueNetIDSignature__DelegateSignature");
		
		AYPlayerReplicationInfo_OnPlayerUniqueNetIDSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758410
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam AYPlayerReplicationInfo::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetTeam");
		
		AYPlayerReplicationInfo_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758490
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetShipClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYShipClass AYPlayerReplicationInfo::GetShipClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetShipClass");
		
		AYPlayerReplicationInfo_GetShipClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757CD0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerReplicationInfo::GetScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetScore");
		
		AYPlayerReplicationInfo_GetScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757A10
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetRawDamageReceivedTotal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerReplicationInfo::GetRawDamageReceivedTotal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetRawDamageReceivedTotal");
		
		AYPlayerReplicationInfo_GetRawDamageReceivedTotal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757950
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetRawDamageReceivedThisLife
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerReplicationInfo::GetRawDamageReceivedThisLife()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetRawDamageReceivedThisLife");
		
		AYPlayerReplicationInfo_GetRawDamageReceivedThisLife_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007577F0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetRampageCounter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYPlayerReplicationInfo::GetRampageCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetRampageCounter");
		
		AYPlayerReplicationInfo_GetRampageCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007535A0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetLastTimeDamagedEnemy
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        enemyDamaged                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AYPlayerReplicationInfo::GetLastTimeDamagedEnemy(const class FName& enemyDamaged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetLastTimeDamagedEnemy");
		
		AYPlayerReplicationInfo_GetLastTimeDamagedEnemy_Params params {};
		params.enemyDamaged = enemyDamaged;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007533B0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetLastKill
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYEventInfo AYPlayerReplicationInfo::GetLastKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetLastKill");
		
		AYPlayerReplicationInfo_GetLastKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007531F0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetLastDeath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYEventInfo AYPlayerReplicationInfo::GetLastDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetLastDeath");
		
		AYPlayerReplicationInfo_GetLastDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753000
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetKillsList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FYEventInfo> AYPlayerReplicationInfo::GetKillsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetKillsList");
		
		AYPlayerReplicationInfo_GetKillsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752ED0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetKills
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerReplicationInfo::GetKills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetKills");
		
		AYPlayerReplicationInfo_GetKills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752870
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetHumanReadableName
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString AYPlayerReplicationInfo::GetHumanReadableName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetHumanReadableName");
		
		AYPlayerReplicationInfo_GetHumanReadableName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007524D0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetHealingDone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerReplicationInfo::GetHealingDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetHealingDone");
		
		AYPlayerReplicationInfo_GetHealingDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751AA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetFighterJetKills
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerReplicationInfo::GetFighterJetKills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetFighterJetKills");
		
		AYPlayerReplicationInfo_GetFighterJetKills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751A40
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetFighterJetDeaths
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerReplicationInfo::GetFighterJetDeaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetFighterJetDeaths");
		
		AYPlayerReplicationInfo_GetFighterJetDeaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751500
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetDeathsList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FYEventInfo> AYPlayerReplicationInfo::GetDeathsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetDeathsList");
		
		AYPlayerReplicationInfo_GetDeathsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751410
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetDeaths
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerReplicationInfo::GetDeaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetDeaths");
		
		AYPlayerReplicationInfo_GetDeaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751340
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetDamageReceivedOnShieldThisLife
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerReplicationInfo::GetDamageReceivedOnShieldThisLife()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetDamageReceivedOnShieldThisLife");
		
		AYPlayerReplicationInfo_GetDamageReceivedOnShieldThisLife_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007512D0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetDamageReceived
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerReplicationInfo::GetDamageReceived()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetDamageReceived");
		
		AYPlayerReplicationInfo_GetDamageReceived_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751220
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetDamageDealtWithWeapons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerReplicationInfo::GetDamageDealtWithWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetDamageDealtWithWeapons");
		
		AYPlayerReplicationInfo_GetDamageDealtWithWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751160
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetDamageDealtWithAbilities
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerReplicationInfo::GetDamageDealtWithAbilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetDamageDealtWithAbilities");
		
		AYPlayerReplicationInfo_GetDamageDealtWithAbilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D890
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.GetAssists
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerReplicationInfo::GetAssists()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.GetAssists");
		
		AYPlayerReplicationInfo_GetAssists_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747180
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.ClientSetTopPlayerMatchStats
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FYPlayerMatchStat>                   playerMatchStats                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo::ClientSetTopPlayerMatchStats(TArray<struct FYPlayerMatchStat> playerMatchStats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.ClientSetTopPlayerMatchStats");
		
		AYPlayerReplicationInfo_ClientSetTopPlayerMatchStats_Params params {};
		params.playerMatchStats = playerMatchStats;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746A00
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.ClientSetEliteSharePlayers
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<class FString>                              playerNames                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo::ClientSetEliteSharePlayers(TArray<class FString> playerNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.ClientSetEliteSharePlayers");
		
		AYPlayerReplicationInfo_ClientSetEliteSharePlayers_Params params {};
		params.playerNames = playerNames;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746790
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.ClientSetActiveBoosterIDs
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<int32_t>                                    activeBoosterIDs                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo::ClientSetActiveBoosterIDs(TArray<int32_t> activeBoosterIDs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.ClientSetActiveBoosterIDs");
		
		AYPlayerReplicationInfo_ClientSetActiveBoosterIDs_Params params {};
		params.activeBoosterIDs = activeBoosterIDs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768700
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.ClientRequestOTSBunch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AYPlayerReplicationInfo::ClientRequestOTSBunch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.ClientRequestOTSBunch");
		
		AYPlayerReplicationInfo_ClientRequestOTSBunch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745200
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo.ClientEventResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		struct FYEventResponse                             response                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo::ClientEventResult(const struct FYEventResponse& response)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo.ClientEventResult");
		
		AYPlayerReplicationInfo_ClientEventResult_Params params {};
		params.response = response;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerReplicationInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerReplicationInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerReplicationInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769000
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_Team
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYNPCReplicationInfo::OnRep_Team()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_Team");
		
		AYNPCReplicationInfo_OnRep_Team_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769100
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_Spotted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYNPCReplicationInfo::OnRep_Spotted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_Spotted");
		
		AYNPCReplicationInfo_OnRep_Spotted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007690A0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_ShipClass
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYNPCReplicationInfo::OnRep_ShipClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_ShipClass");
		
		AYNPCReplicationInfo_OnRep_ShipClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769000
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_Score
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYNPCReplicationInfo::OnRep_Score()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_Score");
		
		AYNPCReplicationInfo_OnRep_Score_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768E60
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_NPCFinishedOrbitSelection
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYNPCReplicationInfo::OnRep_NPCFinishedOrbitSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_NPCFinishedOrbitSelection");
		
		AYNPCReplicationInfo_OnRep_NPCFinishedOrbitSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769000
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_Kills
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYNPCReplicationInfo::OnRep_Kills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_Kills");
		
		AYNPCReplicationInfo_OnRep_Kills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769000
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_Deaths
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYNPCReplicationInfo::OnRep_Deaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_Deaths");
		
		AYNPCReplicationInfo_OnRep_Deaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768B80
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_CaptainData
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYNPCReplicationInfo::OnRep_CaptainData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_CaptainData");
		
		AYNPCReplicationInfo_OnRep_CaptainData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769000
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.OnRep_Assists
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYNPCReplicationInfo::OnRep_Assists()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.OnRep_Assists");
		
		AYNPCReplicationInfo_OnRep_Assists_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759800
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam AYNPCReplicationInfo::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetTeam");
		
		AYNPCReplicationInfo_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757CA0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYNPCReplicationInfo::GetScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetScore");
		
		AYNPCReplicationInfo_GetScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007579D0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetRawDamageReceivedTotal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYNPCReplicationInfo::GetRawDamageReceivedTotal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetRawDamageReceivedTotal");
		
		AYNPCReplicationInfo_GetRawDamageReceivedTotal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757910
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetRawDamageReceivedThisLife
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYNPCReplicationInfo::GetRawDamageReceivedThisLife()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetRawDamageReceivedThisLife");
		
		AYNPCReplicationInfo_GetRawDamageReceivedThisLife_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007577B0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetRampageCounter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYNPCReplicationInfo::GetRampageCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetRampageCounter");
		
		AYNPCReplicationInfo_GetRampageCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753360
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetLastKill
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYEventInfo AYNPCReplicationInfo::GetLastKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetLastKill");
		
		AYNPCReplicationInfo_GetLastKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007531A0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetLastDeath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYEventInfo AYNPCReplicationInfo::GetLastDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetLastDeath");
		
		AYNPCReplicationInfo_GetLastDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752F70
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetKillsList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FYEventInfo> AYNPCReplicationInfo::GetKillsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetKillsList");
		
		AYNPCReplicationInfo_GetKillsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752E90
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetKills
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYNPCReplicationInfo::GetKills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetKills");
		
		AYNPCReplicationInfo_GetKills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752870
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetHumanReadableName
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString AYNPCReplicationInfo::GetHumanReadableName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetHumanReadableName");
		
		AYNPCReplicationInfo_GetHumanReadableName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752490
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetHealingDone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYNPCReplicationInfo::GetHealingDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetHealingDone");
		
		AYNPCReplicationInfo_GetHealingDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751A70
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetFighterJetKills
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYNPCReplicationInfo::GetFighterJetKills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetFighterJetKills");
		
		AYNPCReplicationInfo_GetFighterJetKills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751A10
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetFighterJetDeaths
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYNPCReplicationInfo::GetFighterJetDeaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetFighterJetDeaths");
		
		AYNPCReplicationInfo_GetFighterJetDeaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751470
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetDeathsList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FYEventInfo> AYNPCReplicationInfo::GetDeathsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetDeathsList");
		
		AYNPCReplicationInfo_GetDeathsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007513E0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetDeaths
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYNPCReplicationInfo::GetDeaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetDeaths");
		
		AYNPCReplicationInfo_GetDeaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751300
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetDamageReceivedOnShieldThisLife
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYNPCReplicationInfo::GetDamageReceivedOnShieldThisLife()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetDamageReceivedOnShieldThisLife");
		
		AYNPCReplicationInfo_GetDamageReceivedOnShieldThisLife_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007512A0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetDamageReceived
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYNPCReplicationInfo::GetDamageReceived()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetDamageReceived");
		
		AYNPCReplicationInfo_GetDamageReceived_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007511E0
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetDamageDealtWithWeapons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYNPCReplicationInfo::GetDamageDealtWithWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetDamageDealtWithWeapons");
		
		AYNPCReplicationInfo_GetDamageDealtWithWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751120
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetDamageDealtWithAbilities
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYNPCReplicationInfo::GetDamageDealtWithAbilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetDamageDealtWithAbilities");
		
		AYNPCReplicationInfo_GetDamageDealtWithAbilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D860
	 * 		Name   -> Function DreadGame.YNPCReplicationInfo.GetAssists
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYNPCReplicationInfo::GetAssists()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCReplicationInfo.GetAssists");
		
		AYNPCReplicationInfo_GetAssists_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYNPCReplicationInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYNPCReplicationInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YNPCReplicationInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F870
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.StandaloneStartCombat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYAICombatSceneManager::StandaloneStartCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.StandaloneStartCombat");
		
		AYAICombatSceneManager_StandaloneStartCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F4D0
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.SpawnTurret
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      turretClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            scriptId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* AYAICombatSceneManager::SpawnTurret(const struct FVector& Location, class UClass* turretClass, EYTeam Team, int32_t scriptId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.SpawnTurret");
		
		AYAICombatSceneManager_SpawnTurret_Params params {};
		params.Location = Location;
		params.turretClass = turretClass;
		params.Team = Team;
		params.scriptId = scriptId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077EB10
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.SpawnCreep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      creepClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYCreepNavigation*                           spawnPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYAICombatSceneManager::SpawnCreep(class UClass* creepClass, class AYCreepNavigation* spawnPoint, EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.SpawnCreep");
		
		AYAICombatSceneManager_SpawnCreep_Params params {};
		params.creepClass = creepClass;
		params.spawnPoint = spawnPoint;
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D800
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.ShowHUDNPCs
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<int32_t> AYAICombatSceneManager::ShowHUDNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.ShowHUDNPCs");
		
		AYAICombatSceneManager_ShowHUDNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779630
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.SetOnlyTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      turretActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYAICombatSceneManager::SetOnlyTarget(class AActor* targetActor, class AActor* turretActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.SetOnlyTarget");
		
		AYAICombatSceneManager_SetOnlyTarget_Params params {};
		params.targetActor = targetActor;
		params.turretActor = turretActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777F60
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.SetHUDmisc
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            npcIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        mistText                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYAICombatSceneManager::SetHUDmisc(int32_t npcIndex, const class FName& mistText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.SetHUDmisc");
		
		AYAICombatSceneManager_SetHUDmisc_Params params {};
		params.npcIndex = npcIndex;
		params.mistText = mistText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777470
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.SetFavorTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      turretActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYAICombatSceneManager::SetFavorTarget(class AActor* targetActor, class AActor* turretActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.SetFavorTarget");
		
		AYAICombatSceneManager_SetFavorTarget_Params params {};
		params.targetActor = targetActor;
		params.turretActor = turretActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770E30
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.SendTeamShortCommand
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      commander                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUIShortCommands                                  shortCommandId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            desiredComplyCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              desiredComplyDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AController*> AYAICombatSceneManager::SendTeamShortCommand(class AActor* commander, EYUIShortCommands shortCommandId, class AYPawn* targetPawn, EYTeam Team, int32_t Priority, int32_t desiredComplyCount, float desiredComplyDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.SendTeamShortCommand");
		
		AYAICombatSceneManager_SendTeamShortCommand_Params params {};
		params.commander = commander;
		params.shortCommandId = shortCommandId;
		params.targetPawn = targetPawn;
		params.Team = Team;
		params.Priority = Priority;
		params.desiredComplyCount = desiredComplyCount;
		params.desiredComplyDuration = desiredComplyDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F2D0
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.ReplacePawnNPCBehaviours
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FYCombatSceneBehaviorData>           newBehaviors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               disabeBehaviourTree                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYAICombatSceneManager::ReplacePawnNPCBehaviours(class AYPawn* Pawn, TArray<struct FYCombatSceneBehaviorData> newBehaviors, bool disabeBehaviourTree)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.ReplacePawnNPCBehaviours");
		
		AYAICombatSceneManager_ReplacePawnNPCBehaviours_Params params {};
		params.Pawn = Pawn;
		params.newBehaviors = newBehaviors;
		params.disabeBehaviourTree = disabeBehaviourTree;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F130
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.ReplaceNPCBehaviours
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FYCombatSceneBehaviorData>           newBehaviors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               disabeBehaviourTree                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYAICombatSceneManager::ReplaceNPCBehaviours(int32_t ID, TArray<struct FYCombatSceneBehaviorData> newBehaviors, bool disabeBehaviourTree)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.ReplaceNPCBehaviours");
		
		AYAICombatSceneManager_ReplaceNPCBehaviours_Params params {};
		params.ID = ID;
		params.newBehaviors = newBehaviors;
		params.disabeBehaviourTree = disabeBehaviourTree;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762780
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.OnAsyncLoadedNPCSet
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYAICombatSceneManager::OnAsyncLoadedNPCSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.OnAsyncLoadedNPCSet");
		
		AYAICombatSceneManager_OnAsyncLoadedNPCSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760680
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.LoadNPCSet
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               loadAsync                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYAICombatSceneManager::LoadNPCSet(bool loadAsync)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.LoadNPCSet");
		
		AYAICombatSceneManager_LoadNPCSet_Params params {};
		params.loadAsync = loadAsync;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F300
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.IsNPCDead
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYAICombatSceneManager::IsNPCDead(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.IsNPCDead");
		
		AYAICombatSceneManager_IsNPCDead_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DC60
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.InstancedTeamNPCs
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<int32_t> AYAICombatSceneManager::InstancedTeamNPCs(int32_t Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.InstancedTeamNPCs");
		
		AYAICombatSceneManager_InstancedTeamNPCs_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DBE0
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.InstancedNPCs
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<int32_t> AYAICombatSceneManager::InstancedNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.InstancedNPCs");
		
		AYAICombatSceneManager_InstancedNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755000
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.GetNPCLoadoutUINameByDataset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        pawnid                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString AYAICombatSceneManager::GetNPCLoadoutUINameByDataset(const class FName& pawnid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.GetNPCLoadoutUINameByDataset");
		
		AYAICombatSceneManager_GetNPCLoadoutUINameByDataset_Params params {};
		params.pawnid = pawnid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754F70
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.GetNPCId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYAICombatSceneManager::GetNPCId(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.GetNPCId");
		
		AYAICombatSceneManager_GetNPCId_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754EE0
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.GetNPC
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYAICombatSceneManager::GetNPC(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.GetNPC");
		
		AYAICombatSceneManager_GetNPC_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007522A0
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.GetHUDNPC
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            npcIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FYnpcHUD AYAICombatSceneManager::GetHUDNPC(int32_t npcIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.GetHUDNPC");
		
		AYAICombatSceneManager_GetHUDNPC_Params params {};
		params.npcIndex = npcIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744840
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.Cleanup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYAICombatSceneManager::Cleanup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.Cleanup");
		
		AYAICombatSceneManager_Cleanup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FC20
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.AddNPCSpawnByDataset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        pawnid                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        spawnName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      spawnPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        uiName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYAICombatSceneManager::AddNPCSpawnByDataset(const class FName& pawnid, const class FName& spawnName, class AActor* spawnPoint, EYTeam Team, const class FName& uiName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.AddNPCSpawnByDataset");
		
		AYAICombatSceneManager_AddNPCSpawnByDataset_Params params {};
		params.pawnid = pawnid;
		params.spawnName = spawnName;
		params.spawnPoint = spawnPoint;
		params.Team = Team;
		params.uiName = uiName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FAE0
	 * 		Name   -> Function DreadGame.YAICombatSceneManager.AddNPCSpawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FYCombatSceneSpawnData                      spawnData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	int32_t AYAICombatSceneManager::AddNPCSpawn(const struct FYCombatSceneSpawnData& spawnData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAICombatSceneManager.AddNPCSpawn");
		
		AYAICombatSceneManager_AddNPCSpawn_Params params {};
		params.spawnData = spawnData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYAICombatSceneManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYAICombatSceneManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAICombatSceneManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765420
	 * 		Name   -> Function DreadGame.YAimAssistComponent.OnMovementInput
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAimAssistComponent::OnMovementInput(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAimAssistComponent.OnMovementInput");
		
		UYAimAssistComponent_OnMovementInput_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAimAssistComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAimAssistComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAimAssistComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FF50
	 * 		Name   -> Function DreadGame.YAnimInstanceCharacter.RetrieveEndOfMatchAnimations
	 * 		Flags  -> (Final, Native, Public)
	 */
	TArray<TAssetPtr<class UAnimSequence>> UYAnimInstanceCharacter::RetrieveEndOfMatchAnimations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnimInstanceCharacter.RetrieveEndOfMatchAnimations");
		
		UYAnimInstanceCharacter_RetrieveEndOfMatchAnimations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769FC0
	 * 		Name   -> Function DreadGame.YAnimInstanceCharacter.OnSelectAnimationSequencesForEndOfMatch
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UAnimSequence*>                       outAnimationSequences                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYAnimInstanceCharacter::OnSelectAnimationSequencesForEndOfMatch(int32_t index, TArray<class UAnimSequence*>* outAnimationSequences)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnimInstanceCharacter.OnSelectAnimationSequencesForEndOfMatch");
		
		UYAnimInstanceCharacter_OnSelectAnimationSequencesForEndOfMatch_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outAnimationSequences != nullptr)
			*outAnimationSequences = params.outAnimationSequences;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769CD0
	 * 		Name   -> Function DreadGame.YAnimInstanceCharacter.OnRetriveAnimationsFromEndOfMatchEntry
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYAnimationsForEndOfMatchEntry              entry                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UAnimSequence*>                       outAnimationSequences                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYAnimInstanceCharacter::OnRetriveAnimationsFromEndOfMatchEntry(const struct FYAnimationsForEndOfMatchEntry& entry, TArray<class UAnimSequence*>* outAnimationSequences)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnimInstanceCharacter.OnRetriveAnimationsFromEndOfMatchEntry");
		
		UYAnimInstanceCharacter_OnRetriveAnimationsFromEndOfMatchEntry_Params params {};
		params.entry = entry;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outAnimationSequences != nullptr)
			*outAnimationSequences = params.outAnimationSequences;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YAnimInstanceCharacter.OnPlayFacialAnimation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UAnimSequence*                               AnimSequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AnimProgress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAnimInstanceCharacter::OnPlayFacialAnimation(class UAnimSequence* AnimSequence, float AnimProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnimInstanceCharacter.OnPlayFacialAnimation");
		
		UYAnimInstanceCharacter_OnPlayFacialAnimation_Params params {};
		params.AnimSequence = AnimSequence;
		params.AnimProgress = AnimProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAnimInstanceCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAnimInstanceCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAnimInstanceCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BBF0
	 * 		Name   -> Function DreadGame.YContractsManager.HandleOnPlayerControllerSet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPlayerControllerBase*                      PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYContractsManager::HandleOnPlayerControllerSet(class AYPlayerControllerBase* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YContractsManager.HandleOnPlayerControllerSet");
		
		UYContractsManager_HandleOnPlayerControllerSet_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BB50
	 * 		Name   -> Function DreadGame.YContractsManager.HandleOnPlayerContractsUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYContractsManager::HandleOnPlayerContractsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YContractsManager.HandleOnPlayerContractsUpdated");
		
		UYContractsManager_HandleOnPlayerContractsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYContractsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYContractsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YContractsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C260
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleRefreshGoalAnnouncements
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAnnouncementManager::HandleRefreshGoalAnnouncements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleRefreshGoalAnnouncements");
		
		UYAnnouncementManager_HandleRefreshGoalAnnouncements_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C120
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleOnSquadInvitesUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAnnouncementManager::HandleOnSquadInvitesUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleOnSquadInvitesUpdated");
		
		UYAnnouncementManager_HandleOnSquadInvitesUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BFC0
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleOnRewardUpdated
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               succeed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAnnouncementManager::HandleOnRewardUpdated(const class FName& goalId, bool succeed, const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleOnRewardUpdated");
		
		UYAnnouncementManager_HandleOnRewardUpdated_Params params {};
		params.goalId = goalId;
		params.succeed = succeed;
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BE70
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleOnPlayerDataLoaded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAnnouncementManager::HandleOnPlayerDataLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleOnPlayerDataLoaded");
		
		UYAnnouncementManager_HandleOnPlayerDataLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BB70
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleOnPlayerControllerSet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPlayerControllerBase*                      PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYAnnouncementManager::HandleOnPlayerControllerSet(class AYPlayerControllerBase* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleOnPlayerControllerSet");
		
		UYAnnouncementManager_HandleOnPlayerControllerSet_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BA50
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleOnFriendlistRefreshed
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAnnouncementManager::HandleOnFriendlistRefreshed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleOnFriendlistRefreshed");
		
		UYAnnouncementManager_HandleOnFriendlistRefreshed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B950
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleOnCustomMatchInviteListRefreshed
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FYCustomMatchInvite>                 invites                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYAnnouncementManager::HandleOnCustomMatchInviteListRefreshed(TArray<struct FYCustomMatchInvite> invites)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleOnCustomMatchInviteListRefreshed");
		
		UYAnnouncementManager_HandleOnCustomMatchInviteListRefreshed_Params params {};
		params.invites = invites;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B930
	 * 		Name   -> Function DreadGame.YAnnouncementManager.HandleOnCompletedContractsFromRecentGame
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYAnnouncementManager::HandleOnCompletedContractsFromRecentGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YAnnouncementManager.HandleOnCompletedContractsFromRecentGame");
		
		UYAnnouncementManager_HandleOnCompletedContractsFromRecentGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAnnouncementManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAnnouncementManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAnnouncementManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAnnouncementManagerPS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAnnouncementManagerPS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAnnouncementManagerPS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAssetLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAssetLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAssetLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYAStar.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYAStar::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAStar");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076CE50
	 * 		Name   -> Function DreadGame.YBaseCharacter.PlayAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimationAsset*                             anim                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               initAnim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYBaseCharacter::PlayAnimation(class UAnimationAsset* anim, bool bLooping, bool initAnim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBaseCharacter.PlayAnimation");
		
		AYBaseCharacter_PlayAnimation_Params params {};
		params.anim = anim;
		params.bLooping = bLooping;
		params.initAnim = initAnim;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762700
	 * 		Name   -> Function DreadGame.YBaseCharacter.OnAsyncLoadCharacterItemsDone
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            loadRequestID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBaseCharacter::OnAsyncLoadCharacterItemsDone(int32_t loadRequestID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBaseCharacter.OnAsyncLoadCharacterItemsDone");
		
		AYBaseCharacter_OnAsyncLoadCharacterItemsDone_Params params {};
		params.loadRequestID = loadRequestID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741060
	 * 		Name   -> Function DreadGame.YBaseCharacter.ApplyCharacterAppearance
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYBaseCharacter::ApplyCharacterAppearance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBaseCharacter.ApplyCharacterAppearance");
		
		AYBaseCharacter_ApplyCharacterAppearance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYBaseCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYBaseCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBaseCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752140
	 * 		Name   -> Function DreadGame.YCharacterTemplate.GetGenderTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName UYCharacterTemplate::GetGenderTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterTemplate.GetGenderTag");
		
		UYCharacterTemplate_GetGenderTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterTemplate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterTemplate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterTemplate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770010
	 * 		Name   -> Function DreadGame.YInterface_Character.RetrieveMesh
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USkeletalMesh* UYInterface_Character::RetrieveMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Character.RetrieveMesh");
		
		UYInterface_Character_RetrieveMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C4F0
	 * 		Name   -> Function DreadGame.YInterface_Character.HasOnlySubtitlesInComWindow
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYInterface_Character::HasOnlySubtitlesInComWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Character.HasOnlySubtitlesInComWindow");
		
		UYInterface_Character_HasOnlySubtitlesInComWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007520C0
	 * 		Name   -> Function DreadGame.YInterface_Character.GetGender
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UYInterface_Character::GetGender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Character.GetGender");
		
		UYInterface_Character_GetGender_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074ED80
	 * 		Name   -> Function DreadGame.YInterface_Character.GetCharacterTag
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UYInterface_Character::GetCharacterTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Character.GetCharacterTag");
		
		UYInterface_Character_GetCharacterTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EBC0
	 * 		Name   -> Function DreadGame.YInterface_Character.GetCharacterName
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UYInterface_Character::GetCharacterName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Character.GetCharacterName");
		
		UYInterface_Character_GetCharacterName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EB50
	 * 		Name   -> Function DreadGame.YInterface_Character.GetCharacterImage
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTexture* UYInterface_Character::GetCharacterImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Character.GetCharacterImage");
		
		UYInterface_Character_GetCharacterImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E720
	 * 		Name   -> Function DreadGame.YInterface_Character.GetCharacterAppearance
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYCharacterAppearance UYInterface_Character::GetCharacterAppearance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Character.GetCharacterAppearance");
		
		UYInterface_Character_GetCharacterAppearance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInterface_Character.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInterface_Character::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInterface_Character");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYStaticCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYStaticCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YStaticCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E6C0
	 * 		Name   -> Function DreadGame.YDeployableActor.ReceiveOnRepTeamID
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYTeam                                             teamID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYDeployableActor::ReceiveOnRepTeamID(EYTeam teamID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDeployableActor.ReceiveOnRepTeamID");
		
		AYDeployableActor_ReceiveOnRepTeamID_Params params {};
		params.teamID = teamID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769220
	 * 		Name   -> Function DreadGame.YDeployableActor.OnRep_TeamID
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYDeployableActor::OnRep_TeamID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDeployableActor.OnRep_TeamID");
		
		AYDeployableActor_OnRep_TeamID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766E40
	 * 		Name   -> Function DreadGame.YDeployableActor.OnOwningActorDeath
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYDeployableActor::OnOwningActorDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDeployableActor.OnOwningActorDeath");
		
		AYDeployableActor_OnOwningActorDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766D30
	 * 		Name   -> Function DreadGame.YDeployableActor.OnOwnerEnergyWheelFunctionActivated
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             EnergyWheelSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYDeployableActor::OnOwnerEnergyWheelFunctionActivated(EYEnergyWheelSelection EnergyWheelSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDeployableActor.OnOwnerEnergyWheelFunctionActivated");
		
		AYDeployableActor_OnOwnerEnergyWheelFunctionActivated_Params params {};
		params.EnergyWheelSelection = EnergyWheelSelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752550
	 * 		Name   -> Function DreadGame.YDeployableActor.GetHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYDeployableActor::GetHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDeployableActor.GetHealth");
		
		AYDeployableActor_GetHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYDeployableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYDeployableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDeployableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YSupportStationActor.OnHealWaveTriggered
	 * 		Flags  -> (BlueprintCosmetic, Event, Protected, BlueprintEvent)
	 */
	void AYSupportStationActor::OnHealWaveTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSupportStationActor.OnHealWaveTriggered");
		
		AYSupportStationActor_OnHealWaveTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYSupportStationActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYSupportStationActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSupportStationActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A1A0
	 * 		Name   -> Function DreadGame.YSettingsDataAsset.GetUniqueSettingValue
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYUIUserSetting                             userSetting                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UYSettingsDataAsset::GetUniqueSettingValue(const struct FYUIUserSetting& userSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSettingsDataAsset.GetUniqueSettingValue");
		
		UYSettingsDataAsset_GetUniqueSettingValue_Params params {};
		params.userSetting = userSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A0A0
	 * 		Name   -> Function DreadGame.YSettingsDataAsset.GetUniqueSettingByCategory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUISettingCategory                                Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUISettingCategory                                uniqueCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FYUIUserSetting UYSettingsDataAsset::GetUniqueSettingByCategory(EYUISettingCategory Category, EYUISettingCategory uniqueCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSettingsDataAsset.GetUniqueSettingByCategory");
		
		UYSettingsDataAsset_GetUniqueSettingByCategory_Params params {};
		params.Category = Category;
		params.uniqueCategory = uniqueCategory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSettingsDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSettingsDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSettingsDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCustomMatchSettingsDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCustomMatchSettingsDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCustomMatchSettingsDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YDreadGameUserSettings.YDreadGameUserSettingsAndValueDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UYDreadGameUserSettings*                     source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYDreadGameUserSettings::YDreadGameUserSettingsAndValueDelegate__DelegateSignature(class UYDreadGameUserSettings* source, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YDreadGameUserSettings.YDreadGameUserSettingsAndValueDelegate__DelegateSignature");
		
		UYDreadGameUserSettings_YDreadGameUserSettingsAndValueDelegate__DelegateSignature_Params params {};
		params.source = source;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F130
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.IsMinimapRotationAllowed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYDreadGameUserSettings::IsMinimapRotationAllowed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.IsMinimapRotationAllowed");
		
		UYDreadGameUserSettings_IsMinimapRotationAllowed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A860
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetWeaponShootSoundRelevancyDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetWeaponShootSoundRelevancyDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetWeaponShootSoundRelevancyDistance");
		
		UYDreadGameUserSettings_GetWeaponShootSoundRelevancyDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758C90
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetShowSubtitles
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYDreadGameUserSettings::GetShowSubtitles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetShowSubtitles");
		
		UYDreadGameUserSettings_GetShowSubtitles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758C60
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetShowAimVignette
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYDreadGameUserSettings::GetShowAimVignette()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetShowAimVignette");
		
		UYDreadGameUserSettings_GetShowAimVignette_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757E60
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetScreenResolution
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UYDreadGameUserSettings::GetScreenResolution()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetScreenResolution");
		
		UYDreadGameUserSettings_GetScreenResolution_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007573F0
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyMedium
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetProjectileTickFrequencyMedium()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyMedium");
		
		UYDreadGameUserSettings_GetProjectileTickFrequencyMedium_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007573C0
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyFar
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetProjectileTickFrequencyFar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyFar");
		
		UYDreadGameUserSettings_GetProjectileTickFrequencyFar_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757390
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyDistanceMedium
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetProjectileTickFrequencyDistanceMedium()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyDistanceMedium");
		
		UYDreadGameUserSettings_GetProjectileTickFrequencyDistanceMedium_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757360
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyDistanceFar
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetProjectileTickFrequencyDistanceFar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetProjectileTickFrequencyDistanceFar");
		
		UYDreadGameUserSettings_GetProjectileTickFrequencyDistanceFar_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757330
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetProjectileThrusterSoundRelevancyDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetProjectileThrusterSoundRelevancyDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetProjectileThrusterSoundRelevancyDistance");
		
		UYDreadGameUserSettings_GetProjectileThrusterSoundRelevancyDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757240
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetProjectileForceUpdateOnDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetProjectileForceUpdateOnDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetProjectileForceUpdateOnDistance");
		
		UYDreadGameUserSettings_GetProjectileForceUpdateOnDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756950
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetPeripheralEffects
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYDreadGameUserSettings::GetPeripheralEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetPeripheralEffects");
		
		UYDreadGameUserSettings_GetPeripheralEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754EB0
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetMuzzleFXCullDist
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetMuzzleFXCullDist()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetMuzzleFXCullDist");
		
		UYDreadGameUserSettings_GetMuzzleFXCullDist_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752B20
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetImpactFxRelevancyDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetImpactFxRelevancyDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetImpactFxRelevancyDistance");
		
		UYDreadGameUserSettings_GetImpactFxRelevancyDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007526E0
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetHitMaskRelevancyDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetHitMaskRelevancyDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetHitMaskRelevancyDistance");
		
		UYDreadGameUserSettings_GetHitMaskRelevancyDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751AD0
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetFilterChat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYDreadGameUserSettings::GetFilterChat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetFilterChat");
		
		UYDreadGameUserSettings_GetFilterChat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751640
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetDecalRelevancyDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYDreadGameUserSettings::GetDecalRelevancyDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetDecalRelevancyDistance");
		
		UYDreadGameUserSettings_GetDecalRelevancyDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007513C0
	 * 		Name   -> Function DreadGame.YDreadGameUserSettings.GetDataAsset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYSettingsDataAsset* UYDreadGameUserSettings::GetDataAsset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDreadGameUserSettings.GetDataAsset");
		
		UYDreadGameUserSettings_GetDataAsset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDreadGameUserSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDreadGameUserSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDreadGameUserSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784B70
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.YLineTraceSingle
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bDrawDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      IgnoreActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_YLineTraceSingle(const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, bool bDrawDebug, struct FHitResult* OutHit, class AActor* IgnoreActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.YLineTraceSingle");
		
		UYBlueprintLibrary_YLineTraceSingle_Params params {};
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.bDrawDebug = bDrawDebug;
		params.IgnoreActor = IgnoreActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784860
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.YApplyRadialDamage
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 eventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ignoreShield                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 * 		bool                                               friendlyFire                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 damageDistanceCurve                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      directHitActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               exactHitDetection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_YApplyRadialDamage(const struct FVector& Origin, float BaseDamage, float Radius, class AController* eventInstigator, class UObject* DamageCauser, class UClass* DamageTypeClass, bool ignoreShield, bool friendlyFire, class UCurveFloat* damageDistanceCurve, class AActor* directHitActor, bool exactHitDetection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.YApplyRadialDamage");
		
		UYBlueprintLibrary_YApplyRadialDamage_Params params {};
		params.Origin = Origin;
		params.BaseDamage = BaseDamage;
		params.Radius = Radius;
		params.eventInstigator = eventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;
		params.ignoreShield = ignoreShield;
		params.friendlyFire = friendlyFire;
		params.damageDistanceCurve = damageDistanceCurve;
		params.directHitActor = directHitActor;
		params.exactHitDetection = exactHitDetection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784620
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.YApplyDamage
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 eventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ignoreShield                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 * 		bool                                               friendlyFire                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 * 		bool                                               radial                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_YApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* eventInstigator, class UObject* DamageCauser, class UClass* DamageTypeClass, bool ignoreShield, bool friendlyFire, bool radial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.YApplyDamage");
		
		UYBlueprintLibrary_YApplyDamage_Params params {};
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.eventInstigator = eventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;
		params.ignoreShield = ignoreShield;
		params.friendlyFire = friendlyFire;
		params.radial = radial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782A10
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.TriggerVoiceLineByID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            uid                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, AdvancedDisplay, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_TriggerVoiceLineByID(int32_t uid, class AYPlayerController* Player, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.TriggerVoiceLineByID");
		
		UYBlueprintLibrary_TriggerVoiceLineByID_Params params {};
		params.uid = uid;
		params.Player = Player;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007828F0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.TriggerVoiceLine
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYVoiceLineUnique*                           voiceLine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, AdvancedDisplay, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_TriggerVoiceLine(class UYVoiceLineUnique* voiceLine, class AYPlayerController* Player, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.TriggerVoiceLine");
		
		UYBlueprintLibrary_TriggerVoiceLine_Params params {};
		params.voiceLine = voiceLine;
		params.Player = Player;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781CA0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.TriggerAudioFeedbackOnPlayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        voiceID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_TriggerAudioFeedbackOnPlayer(const class FName& voiceID, class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.TriggerAudioFeedbackOnPlayer");
		
		UYBlueprintLibrary_TriggerAudioFeedbackOnPlayer_Params params {};
		params.voiceID = voiceID;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781BA0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.TriggerAudioFeedbackOnAllPlayerTeamBased
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             teamFriendly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        voiceIDFriendly                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        voiceIDEnemy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_TriggerAudioFeedbackOnAllPlayerTeamBased(EYTeam teamFriendly, const class FName& voiceIDFriendly, const class FName& voiceIDEnemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.TriggerAudioFeedbackOnAllPlayerTeamBased");
		
		UYBlueprintLibrary_TriggerAudioFeedbackOnAllPlayerTeamBased_Params params {};
		params.teamFriendly = teamFriendly;
		params.voiceIDFriendly = voiceIDFriendly;
		params.voiceIDEnemy = voiceIDEnemy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781B30
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.TriggerAudioFeedbackOnAllPlayer
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        voiceID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_TriggerAudioFeedbackOnAllPlayer(const class FName& voiceID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.TriggerAudioFeedbackOnAllPlayer");
		
		UYBlueprintLibrary_TriggerAudioFeedbackOnAllPlayer_Params params {};
		params.voiceID = voiceID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007817A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.TravelBackToOutpost
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPlayerController*                          owningController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_TravelBackToOutpost(class AYPlayerController* owningController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.TravelBackToOutpost");
		
		UYBlueprintLibrary_TravelBackToOutpost_Params params {};
		params.owningController = owningController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780730
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.StringReplaceUnderscoreWithSpace
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      inString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYBlueprintLibrary::STATIC_StringReplaceUnderscoreWithSpace(const class FString& inString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.StringReplaceUnderscoreWithSpace");
		
		UYBlueprintLibrary_StringReplaceUnderscoreWithSpace_Params params {};
		params.inString = inString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F020
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.SpawnProjectile
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBlueprint*                                  projectileBlueprint                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        projectileDataRowName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               loadContent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  projectileTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AYWeapon*                                    firingWeapon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            projectileID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYCachedDamageModifierData                  damageModifierData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            randomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYProjectile* UYBlueprintLibrary::STATIC_SpawnProjectile(class UObject* WorldContextObject, class UBlueprint* projectileBlueprint, const class FName& projectileDataRowName, bool loadContent, const struct FTransform& projectileTransform, class AYWeapon* firingWeapon, int32_t projectileID, const struct FYCachedDamageModifierData& damageModifierData, int32_t randomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.SpawnProjectile");
		
		UYBlueprintLibrary_SpawnProjectile_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.projectileBlueprint = projectileBlueprint;
		params.projectileDataRowName = projectileDataRowName;
		params.loadContent = loadContent;
		params.projectileTransform = projectileTransform;
		params.firingWeapon = firingWeapon;
		params.projectileID = projectileID;
		params.damageModifierData = damageModifierData;
		params.randomSeed = randomSeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077ED70
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.SpawnDecalAtLocationReturnActor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBlueprint*                                  decalBlueprint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AActor* UYBlueprintLibrary::STATIC_SpawnDecalAtLocationReturnActor(class UObject* WorldContextObject, class UBlueprint* decalBlueprint, const struct FVector& Location, const struct FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.SpawnDecalAtLocationReturnActor");
		
		UYBlueprintLibrary_SpawnDecalAtLocationReturnActor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.decalBlueprint = decalBlueprint;
		params.Location = Location;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077EC20
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.SpawnDecalAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBlueprint*                                  decalBlueprint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_SpawnDecalAtLocation(class UObject* WorldContextObject, class UBlueprint* decalBlueprint, const struct FVector& Location, const struct FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.SpawnDecalAtLocation");
		
		UYBlueprintLibrary_SpawnDecalAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.decalBlueprint = decalBlueprint;
		params.Location = Location;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E890
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.SizeSquared
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     inVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UYBlueprintLibrary::STATIC_SizeSquared(const struct FVector& inVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.SizeSquared");
		
		UYBlueprintLibrary_SizeSquared_Params params {};
		params.inVector = inVector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D6A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ShowHUDMessageForController
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              TimeSeconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      headLine                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPlayerControllerBase*                      onlyThisController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_ShowHUDMessageForController(float TimeSeconds, const class FString& headLine, const class FString& message, class AYPlayerControllerBase* onlyThisController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ShowHUDMessageForController");
		
		UYBlueprintLibrary_ShowHUDMessageForController_Params params {};
		params.TimeSeconds = TimeSeconds;
		params.headLine = headLine;
		params.message = message;
		params.onlyThisController = onlyThisController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D1A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ShouldTickProjectile
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              timeSinceLastTick                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              distanceSinceLastUpdate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_ShouldTickProjectile(const struct FVector& Location, float timeSinceLastTick, float distanceSinceLastUpdate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ShouldTickProjectile");
		
		UYBlueprintLibrary_ShouldTickProjectile_Params params {};
		params.Location = Location;
		params.timeSinceLastTick = timeSinceLastTick;
		params.distanceSinceLastUpdate = distanceSinceLastUpdate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CD30
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.SetWwiseAudioEnabled
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               turnOn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_SetWwiseAudioEnabled(bool turnOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.SetWwiseAudioEnabled");
		
		UYBlueprintLibrary_SetWwiseAudioEnabled_Params params {};
		params.turnOn = turnOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779770
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.SetPPF
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        progressionFlagName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_SetPPF(const class FName& progressionFlagName, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.SetPPF");
		
		UYBlueprintLibrary_SetPPF_Params params {};
		params.progressionFlagName = progressionFlagName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778900
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.SetLoadoutFilterForPlayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYLoadoutFilter*                             loadoutFilter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_SetLoadoutFilterForPlayer(class UYLoadoutFilter* loadoutFilter, class APlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.SetLoadoutFilterForPlayer");
		
		UYBlueprintLibrary_SetLoadoutFilterForPlayer_Params params {};
		params.loadoutFilter = loadoutFilter;
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E590
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.QuickOverlapTest
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      actorToCheck                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              radiusSqr                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYPawn* UYBlueprintLibrary::STATIC_QuickOverlapTest(class AActor* actorToCheck, float radiusSqr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.QuickOverlapTest");
		
		UYBlueprintLibrary_QuickOverlapTest_Params params {};
		params.actorToCheck = actorToCheck;
		params.radiusSqr = radiusSqr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E480
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.QuickOverlapAllTest
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      actorToCheck                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              radiusSqr                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> UYBlueprintLibrary::STATIC_QuickOverlapAllTest(class AActor* actorToCheck, float radiusSqr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.QuickOverlapAllTest");
		
		UYBlueprintLibrary_QuickOverlapAllTest_Params params {};
		params.actorToCheck = actorToCheck;
		params.radiusSqr = radiusSqr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C600
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.OpenLoadingScreen
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        titleText                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        descriptionText                                            (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        gameModeText                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_OpenLoadingScreen(class UTexture2D* Texture, const class FText& titleText, const class FText& descriptionText, const class FText& gameModeText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.OpenLoadingScreen");
		
		UYBlueprintLibrary_OpenLoadingScreen_Params params {};
		params.Texture = Texture;
		params.titleText = titleText;
		params.descriptionText = descriptionText;
		params.gameModeText = gameModeText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761AC0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.NetModeIsStandalone
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_NetModeIsStandalone(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.NetModeIsStandalone");
		
		UYBlueprintLibrary_NetModeIsStandalone_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761A40
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.NetModeIsServer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_NetModeIsServer(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.NetModeIsServer");
		
		UYBlueprintLibrary_NetModeIsServer_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007619C0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.NetModeIsListen
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_NetModeIsListen(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.NetModeIsListen");
		
		UYBlueprintLibrary_NetModeIsListen_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761940
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.NetModeIsDedicatedServerWorld
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_NetModeIsDedicatedServerWorld(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.NetModeIsDedicatedServerWorld");
		
		UYBlueprintLibrary_NetModeIsDedicatedServerWorld_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761940
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.NetModeIsDedicatedServer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_NetModeIsDedicatedServer(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.NetModeIsDedicatedServer");
		
		UYBlueprintLibrary_NetModeIsDedicatedServer_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007618C0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.NetModeIsClientOrStandalone
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_NetModeIsClientOrStandalone(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.NetModeIsClientOrStandalone");
		
		UYBlueprintLibrary_NetModeIsClientOrStandalone_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761840
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.NetModeIsClient
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_NetModeIsClient(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.NetModeIsClient");
		
		UYBlueprintLibrary_NetModeIsClient_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007609D0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.MakeTargetInfo
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     StartLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     endLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               hasHit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FYTargetInfo UYBlueprintLibrary::STATIC_MakeTargetInfo(class AActor* Actor, const struct FVector& StartLocation, const struct FVector& endLocation, bool hasHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.MakeTargetInfo");
		
		UYBlueprintLibrary_MakeTargetInfo_Params params {};
		params.Actor = Actor;
		params.StartLocation = StartLocation;
		params.endLocation = endLocation;
		params.hasHit = hasHit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760180
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.LinebreakString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      str                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              targetWidth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> UYBlueprintLibrary::STATIC_LinebreakString(const class FString& str, float targetWidth, class UFont* Font, float Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.LinebreakString");
		
		UYBlueprintLibrary_LinebreakString_Params params {};
		params.str = str;
		params.targetWidth = targetWidth;
		params.Font = Font;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FE00
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsWeaponShootSoundRelevant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsWeaponShootSoundRelevant(const struct FVector& SpawnLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsWeaponShootSoundRelevant");
		
		UYBlueprintLibrary_IsWeaponShootSoundRelevant_Params params {};
		params.SpawnLocation = SpawnLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F600
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsProjectileThrusterSoundRelevant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsProjectileThrusterSoundRelevant(const struct FVector& SpawnLocation, class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsProjectileThrusterSoundRelevant");
		
		UYBlueprintLibrary_IsProjectileThrusterSoundRelevant_Params params {};
		params.SpawnLocation = SpawnLocation;
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F390
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsNearlyEqual
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              ValueA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ValueB                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsNearlyEqual(float ValueA, float ValueB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsNearlyEqual");
		
		UYBlueprintLibrary_IsNearlyEqual_Params params {};
		params.ValueA = ValueA;
		params.ValueB = ValueB;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F1C0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsMuzzleFlashRelevant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsMuzzleFlashRelevant(const struct FVector& SpawnLocation, class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsMuzzleFlashRelevant");
		
		UYBlueprintLibrary_IsMuzzleFlashRelevant_Params params {};
		params.SpawnLocation = SpawnLocation;
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F190
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsMultiplayerGame
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	bool UYBlueprintLibrary::STATIC_IsMultiplayerGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsMultiplayerGame");
		
		UYBlueprintLibrary_IsMultiplayerGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EE80
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsImpactFxRelevant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsImpactFxRelevant(const struct FVector& SpawnLocation, class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsImpactFxRelevant");
		
		UYBlueprintLibrary_IsImpactFxRelevant_Params params {};
		params.SpawnLocation = SpawnLocation;
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EC20
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsHitMaskRelevant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsHitMaskRelevant(const struct FVector& SpawnLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsHitMaskRelevant");
		
		UYBlueprintLibrary_IsHitMaskRelevant_Params params {};
		params.SpawnLocation = SpawnLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ECB0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsHitmaskEnabled
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYBlueprintLibrary::STATIC_IsHitmaskEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsHitmaskEnabled");
		
		UYBlueprintLibrary_IsHitmaskEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E8E0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsFriendlyTeam
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             teamOne                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             teamTwo                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsFriendlyTeam(EYTeam teamOne, EYTeam teamTwo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsFriendlyTeam");
		
		UYBlueprintLibrary_IsFriendlyTeam_Params params {};
		params.teamOne = teamOne;
		params.teamTwo = teamTwo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E820
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsFriendly
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      pawnOne                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      pawnTwo                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsFriendly(class AYPawn* pawnOne, class AYPawn* pawnTwo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsFriendly");
		
		UYBlueprintLibrary_IsFriendly_Params params {};
		params.pawnOne = pawnOne;
		params.pawnTwo = pawnTwo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E5A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsDecalRelevant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_IsDecalRelevant(const struct FVector& SpawnLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsDecalRelevant");
		
		UYBlueprintLibrary_IsDecalRelevant_Params params {};
		params.SpawnLocation = SpawnLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DDA0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsAVSMSupported
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYBlueprintLibrary::STATIC_IsAVSMSupported()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsAVSMSupported");
		
		UYBlueprintLibrary_IsAVSMSupported_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DD70
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.IsAVSMEnabled
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYBlueprintLibrary::STATIC_IsAVSMEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.IsAVSMEnabled");
		
		UYBlueprintLibrary_IsAVSMEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B030
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetYPlayerControllerList
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class AYPlayerController*> UYBlueprintLibrary::STATIC_GetYPlayerControllerList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetYPlayerControllerList");
		
		UYBlueprintLibrary_GetYPlayerControllerList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ADB0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetYPawnsInRange
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      contextActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             excludeTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               includeRespawnJets                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCreeps                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> UYBlueprintLibrary::STATIC_GetYPawnsInRange(class AActor* contextActor, const struct FVector& Location, float Radius, EYTeam Team, EYTeam excludeTeam, bool includeRespawnJets, bool includeCreeps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetYPawnsInRange");
		
		UYBlueprintLibrary_GetYPawnsInRange_Params params {};
		params.contextActor = contextActor;
		params.Location = Location;
		params.Radius = Radius;
		params.Team = Team;
		params.excludeTeam = excludeTeam;
		params.includeRespawnJets = includeRespawnJets;
		params.includeCreeps = includeCreeps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075AC10
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetYPawns
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      contextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               includeFighterJets                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCreeps                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> UYBlueprintLibrary::STATIC_GetYPawns(class AActor* contextObject, EYTeam Team, bool includeFighterJets, bool includeCreeps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetYPawns");
		
		UYBlueprintLibrary_GetYPawns_Params params {};
		params.contextObject = contextObject;
		params.Team = Team;
		params.includeFighterJets = includeFighterJets;
		params.includeCreeps = includeCreeps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ABB0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetYMenu
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class AYMenu* UYBlueprintLibrary::STATIC_GetYMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetYMenu");
		
		UYBlueprintLibrary_GetYMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075AA60
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetWorldGravityZ
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      referenceActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UYBlueprintLibrary::STATIC_GetWorldGravityZ(class AActor* referenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetWorldGravityZ");
		
		UYBlueprintLibrary_GetWorldGravityZ_Params params {};
		params.referenceActor = referenceActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A9B0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetWorldGravityVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      referenceActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UYBlueprintLibrary::STATIC_GetWorldGravityVector(class AActor* referenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetWorldGravityVector");
		
		UYBlueprintLibrary_GetWorldGravityVector_Params params {};
		params.referenceActor = referenceActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A920
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetWorldFromActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      referenceActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWorld* UYBlueprintLibrary::STATIC_GetWorldFromActor(class AActor* referenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetWorldFromActor");
		
		UYBlueprintLibrary_GetWorldFromActor_Params params {};
		params.referenceActor = referenceActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759CB0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetTexture2DFromPath
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Path                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYBlueprintLibrary::STATIC_GetTexture2DFromPath(const class FString& Path)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetTexture2DFromPath");
		
		UYBlueprintLibrary_GetTexture2DFromPath_Params params {};
		params.Path = Path;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759580
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetSupportStationList
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class AYSupportStationActor*> UYBlueprintLibrary::STATIC_GetSupportStationList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetSupportStationList");
		
		UYBlueprintLibrary_GetSupportStationList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007591F0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetSquaredDistToShield
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AYEnergyShield*                              shieldToCheck                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     checkLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               exactCheck                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UYBlueprintLibrary::STATIC_GetSquaredDistToShield(class AYEnergyShield* shieldToCheck, const struct FVector& checkLocation, bool exactCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetSquaredDistToShield");
		
		UYBlueprintLibrary_GetSquaredDistToShield_Params params {};
		params.shieldToCheck = shieldToCheck;
		params.checkLocation = checkLocation;
		params.exactCheck = exactCheck;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007590E0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetSquaredDistToPawn
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      pawnToCheck                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     checkLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               exactCheck                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UYBlueprintLibrary::STATIC_GetSquaredDistToPawn(class AYPawn* pawnToCheck, const struct FVector& checkLocation, bool exactCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetSquaredDistToPawn");
		
		UYBlueprintLibrary_GetSquaredDistToPawn_Params params {};
		params.pawnToCheck = pawnToCheck;
		params.checkLocation = checkLocation;
		params.exactCheck = exactCheck;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759020
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetSquadList
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	TArray<struct FYSquadUserDataBP> UYBlueprintLibrary::STATIC_GetSquadList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetSquadList");
		
		UYBlueprintLibrary_GetSquadList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007589A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetShipVanityTypeAsText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYVanityItemMenuCategorie                          shipVanityItemCategory                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYBlueprintLibrary::STATIC_GetShipVanityTypeAsText(EYVanityItemMenuCategorie shipVanityItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetShipVanityTypeAsText");
		
		UYBlueprintLibrary_GetShipVanityTypeAsText_Params params {};
		params.shipVanityItemCategory = shipVanityItemCategory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007587A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetShipClassNameAsText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipClass                                        shipSubClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYBlueprintLibrary::STATIC_GetShipClassNameAsText(EYShipClass shipSubClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetShipClassNameAsText");
		
		UYBlueprintLibrary_GetShipClassNameAsText_Params params {};
		params.shipSubClass = shipSubClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007586E0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetShipClassName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipClass                                        shipSubClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYBlueprintLibrary::STATIC_GetShipClassName(EYShipClass shipSubClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetShipClassName");
		
		UYBlueprintLibrary_GetShipClassName_Params params {};
		params.shipSubClass = shipSubClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758350
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetShipBaseClassNameAsText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipBaseClass                                    shipBaseClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYBlueprintLibrary::STATIC_GetShipBaseClassNameAsText(EYShipBaseClass shipBaseClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetShipBaseClassNameAsText");
		
		UYBlueprintLibrary_GetShipBaseClassNameAsText_Params params {};
		params.shipBaseClass = shipBaseClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758290
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetShipBaseClassName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipBaseClass                                    shipBaseClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYBlueprintLibrary::STATIC_GetShipBaseClassName(EYShipBaseClass shipBaseClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetShipBaseClassName");
		
		UYBlueprintLibrary_GetShipBaseClassName_Params params {};
		params.shipBaseClass = shipBaseClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758200
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetShipBaseClassForShipClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipClass                                        shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYShipBaseClass UYBlueprintLibrary::STATIC_GetShipBaseClassForShipClass(EYShipClass shipclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetShipBaseClassForShipClass");
		
		UYBlueprintLibrary_GetShipBaseClassForShipClass_Params params {};
		params.shipclass = shipclass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755B70
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetPPF
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        progressionFlagName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_GetPPF(const class FName& progressionFlagName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetPPF");
		
		UYBlueprintLibrary_GetPPF_Params params {};
		params.progressionFlagName = progressionFlagName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007569F0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetPerkManager
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYPerkManager* UYBlueprintLibrary::STATIC_GetPerkManager(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetPerkManager");
		
		UYBlueprintLibrary_GetPerkManager_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755DB0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetPawnList
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class APawn*> UYBlueprintLibrary::STATIC_GetPawnList(const struct FVector& Location, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetPawnList");
		
		UYBlueprintLibrary_GetPawnList_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007558B0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetOnlineFriendList
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	TArray<struct FYFriendDataBP> UYBlueprintLibrary::STATIC_GetOnlineFriendList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetOnlineFriendList");
		
		UYBlueprintLibrary_GetOnlineFriendList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755780
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetOfficerManager
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYOfficerManager* UYBlueprintLibrary::STATIC_GetOfficerManager(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetOfficerManager");
		
		UYBlueprintLibrary_GetOfficerManager_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007556A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetOfficerClassName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYOfficerType                                      officerType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYBlueprintLibrary::STATIC_GetOfficerClassName(EYOfficerType officerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetOfficerClassName");
		
		UYBlueprintLibrary_GetOfficerClassName_Params params {};
		params.officerType = officerType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755620
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetOfficerByType
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYOfficerType                                      Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYOfficer* UYBlueprintLibrary::STATIC_GetOfficerByType(EYOfficerType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetOfficerByType");
		
		UYBlueprintLibrary_GetOfficerByType_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755360
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetObjectiveComponent
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYObjectiveComponent*                        objectiveComponent                                         (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isExist                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_GetObjectiveComponent(class AActor* Actor, class UYObjectiveComponent** objectiveComponent, bool* isExist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetObjectiveComponent");
		
		UYBlueprintLibrary_GetObjectiveComponent_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (objectiveComponent != nullptr)
			*objectiveComponent = params.objectiveComponent;
		if (isExist != nullptr)
			*isExist = params.isExist;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754210
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetMediumShipClassForShipBaseClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipBaseClass                                    shipBaseClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYShipClass UYBlueprintLibrary::STATIC_GetMediumShipClassForShipBaseClass(EYShipBaseClass shipBaseClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetMediumShipClassForShipBaseClass");
		
		UYBlueprintLibrary_GetMediumShipClassForShipBaseClass_Params params {};
		params.shipBaseClass = shipBaseClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754000
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetMaxInitialDeathDebris
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t UYBlueprintLibrary::STATIC_GetMaxInitialDeathDebris()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetMaxInitialDeathDebris");
		
		UYBlueprintLibrary_GetMaxInitialDeathDebris_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752CC0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetIsInSquad
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	bool UYBlueprintLibrary::STATIC_GetIsInSquad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetIsInSquad");
		
		UYBlueprintLibrary_GetIsInSquad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751FC0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetFriendList
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	TArray<struct FYFriendDataBP> UYBlueprintLibrary::STATIC_GetFriendList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetFriendList");
		
		UYBlueprintLibrary_GetFriendList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007519C0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetFPS
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYBlueprintLibrary::STATIC_GetFPS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetFPS");
		
		UYBlueprintLibrary_GetFPS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751CC0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetFleetTypeName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYFleetType                                        fleetType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYBlueprintLibrary::STATIC_GetFleetTypeName(EYFleetType fleetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetFleetTypeName");
		
		UYBlueprintLibrary_GetFleetTypeName_Params params {};
		params.fleetType = fleetType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751BB0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetFirstLocalPlayerControllerInWorld
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerController* UYBlueprintLibrary::STATIC_GetFirstLocalPlayerControllerInWorld(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetFirstLocalPlayerControllerInWorld");
		
		UYBlueprintLibrary_GetFirstLocalPlayerControllerInWorld_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751B30
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetFirstLocalPlayerController
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerController* UYBlueprintLibrary::STATIC_GetFirstLocalPlayerController(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetFirstLocalPlayerController");
		
		UYBlueprintLibrary_GetFirstLocalPlayerController_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750F70
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetDamagableActorList
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      referenceActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               exactHitDetection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<struct FYDamageableActorInfo> UYBlueprintLibrary::STATIC_GetDamagableActorList(class AActor* referenceActor, const struct FVector& Location, float Radius, bool exactHitDetection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetDamagableActorList");
		
		UYBlueprintLibrary_GetDamagableActorList_Params params {};
		params.referenceActor = referenceActor;
		params.Location = Location;
		params.Radius = Radius;
		params.exactHitDetection = exactHitDetection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750B20
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetCurrentPlayerPID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class FName UYBlueprintLibrary::STATIC_GetCurrentPlayerPID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetCurrentPlayerPID");
		
		UYBlueprintLibrary_GetCurrentPlayerPID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750000
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetCombatSceneManager
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class AYAICombatSceneManager* UYBlueprintLibrary::STATIC_GetCombatSceneManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetCombatSceneManager");
		
		UYBlueprintLibrary_GetCombatSceneManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074FC30
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetClosestPointOnLineSegment
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     testPos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LineStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LineEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FVector UYBlueprintLibrary::STATIC_GetClosestPointOnLineSegment(const struct FVector& testPos, const struct FVector& LineStart, const struct FVector& LineEnd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetClosestPointOnLineSegment");
		
		UYBlueprintLibrary_GetClosestPointOnLineSegment_Params params {};
		params.testPos = testPos;
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EF10
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetClosestPair
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AYPawn*>                              Actors                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> UYBlueprintLibrary::STATIC_GetClosestPair(TArray<class AYPawn*> Actors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetClosestPair");
		
		UYBlueprintLibrary_GetClosestPair_Params params {};
		params.Actors = Actors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074ED40
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetCharacterRenderingLOD
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	EYCharacterRenderingLOD UYBlueprintLibrary::STATIC_GetCharacterRenderingLOD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetCharacterRenderingLOD");
		
		UYBlueprintLibrary_GetCharacterRenderingLOD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E360
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetCaptainVanityTypeAsText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYCharacterVanityItemMenuCategory                  characterVanityItemCategory                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYBlueprintLibrary::STATIC_GetCaptainVanityTypeAsText(EYCharacterVanityItemMenuCategory characterVanityItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetCaptainVanityTypeAsText");
		
		UYBlueprintLibrary_GetCaptainVanityTypeAsText_Params params {};
		params.characterVanityItemCategory = characterVanityItemCategory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E240
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetCaptain
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class UYCaptain* UYBlueprintLibrary::STATIC_GetCaptain()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetCaptain");
		
		UYBlueprintLibrary_GetCaptain_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E120
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetCappedByTierAbility
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            maxTier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               mustFind                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UClass* UYBlueprintLibrary::STATIC_GetCappedByTierAbility(int32_t maxTier, class UClass* ability, bool mustFind)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetCappedByTierAbility");
		
		UYBlueprintLibrary_GetCappedByTierAbility_Params params {};
		params.maxTier = maxTier;
		params.ability = ability;
		params.mustFind = mustFind;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DDF0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetBestMatchingString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FString>                              sourceStrings                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      stringToTest                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYBlueprintLibrary::STATIC_GetBestMatchingString(TArray<class FString> sourceStrings, const class FString& stringToTest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetBestMatchingString");
		
		UYBlueprintLibrary_GetBestMatchingString_Params params {};
		params.sourceStrings = sourceStrings;
		params.stringToTest = stringToTest;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D5F0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetAllPawns
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class APawn*> UYBlueprintLibrary::STATIC_GetAllPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetAllPawns");
		
		UYBlueprintLibrary_GetAllPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D270
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetActorListByDistanceAndClass
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      cls                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AActor*> UYBlueprintLibrary::STATIC_GetActorListByDistanceAndClass(const struct FVector& Location, float Radius, class UClass* cls)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetActorListByDistanceAndClass");
		
		UYBlueprintLibrary_GetActorListByDistanceAndClass_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		params.cls = cls;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D1A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetActorListByClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      cls                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AActor*> UYBlueprintLibrary::STATIC_GetActorListByClass(class UClass* cls)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetActorListByClass");
		
		UYBlueprintLibrary_GetActorListByClass_Params params {};
		params.cls = cls;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D080
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.GetActorList
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AActor*> UYBlueprintLibrary::STATIC_GetActorList(const struct FVector& Location, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.GetActorList");
		
		UYBlueprintLibrary_GetActorList_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C600
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.FlushAnalyticsEvents
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYBlueprintLibrary::STATIC_FlushAnalyticsEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.FlushAnalyticsEvents");
		
		UYBlueprintLibrary_FlushAnalyticsEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C3C0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.FinishedLoading
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYBlueprintLibrary::STATIC_FinishedLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.FinishedLoading");
		
		UYBlueprintLibrary_FinishedLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BD90
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ExtractClassStringFromPath
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Path                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYBlueprintLibrary::STATIC_ExtractClassStringFromPath(const class FString& Path)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ExtractClassStringFromPath");
		
		UYBlueprintLibrary_ExtractClassStringFromPath_Params params {};
		params.Path = Path;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BCA0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ExtractClassFromPath
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Path                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYShipBaseClass UYBlueprintLibrary::STATIC_ExtractClassFromPath(const class FString& Path)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ExtractClassFromPath");
		
		UYBlueprintLibrary_ExtractClassFromPath_Params params {};
		params.Path = Path;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BB30
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ExitGame
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPlayerController*                          owningController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_ExitGame(class AYPlayerController* owningController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ExitGame");
		
		UYBlueprintLibrary_ExitGame_Params params {};
		params.owningController = owningController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AC20
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.DotShipAndRay
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      pawnToCheck                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     rayOrigin                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     normalizedRayDirection                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              outDotProduct                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_DotShipAndRay(class AYPawn* pawnToCheck, const struct FVector& rayOrigin, const struct FVector& normalizedRayDirection, float* outDotProduct)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.DotShipAndRay");
		
		UYBlueprintLibrary_DotShipAndRay_Params params {};
		params.pawnToCheck = pawnToCheck;
		params.rayOrigin = rayOrigin;
		params.normalizedRayDirection = normalizedRayDirection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outDotProduct != nullptr)
			*outDotProduct = params.outDotProduct;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A9C0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.DisableAllPS4Callouts
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYBlueprintLibrary::STATIC_DisableAllPS4Callouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.DisableAllPS4Callouts");
		
		UYBlueprintLibrary_DisableAllPS4Callouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748B10
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.Conv_StringToTextNonPlayerFacing
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      inString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYBlueprintLibrary::STATIC_Conv_StringToTextNonPlayerFacing(const class FString& inString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.Conv_StringToTextNonPlayerFacing");
		
		UYBlueprintLibrary_Conv_StringToTextNonPlayerFacing_Params params {};
		params.inString = inString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748A40
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.Conv_NameToTextNonPlayerFacing
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYBlueprintLibrary::STATIC_Conv_NameToTextNonPlayerFacing(const class FName& InName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.Conv_NameToTextNonPlayerFacing");
		
		UYBlueprintLibrary_Conv_NameToTextNonPlayerFacing_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007488B0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ComponentIsVisibleFrom
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         VictimComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      IgnoredActor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHitResult                                               (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_ComponentIsVisibleFrom(class UPrimitiveComponent* VictimComp, const struct FVector& Origin, class AActor* IgnoredActor, struct FHitResult* OutHitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ComponentIsVisibleFrom");
		
		UYBlueprintLibrary_ComponentIsVisibleFrom_Params params {};
		params.VictimComp = VictimComp;
		params.Origin = Origin;
		params.IgnoredActor = IgnoredActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResult != nullptr)
			*OutHitResult = params.OutHitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748650
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CloseLoadingScreen
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
	 */
	void UYBlueprintLibrary::STATIC_CloseLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CloseLoadingScreen");
		
		UYBlueprintLibrary_CloseLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007448C0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ClearLoadoutFilterForPlayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_ClearLoadoutFilterForPlayer(class APlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ClearLoadoutFilterForPlayer");
		
		UYBlueprintLibrary_ClearLoadoutFilterForPlayer_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743BB0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonEnableSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUILoadoutItemType                                loadoutType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYButtonStateAfterClick                            handleClickState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               preserveScreenLockState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutButtonEnableSlot(EYUILoadoutItemType loadoutType, EYButtonStateAfterClick handleClickState, bool preserveScreenLockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonEnableSlot");
		
		UYBlueprintLibrary_CalloutButtonEnableSlot_Params params {};
		params.loadoutType = loadoutType;
		params.handleClickState = handleClickState;
		params.preserveScreenLockState = preserveScreenLockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743A50
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYButtonStateAfterClick                            handleClickState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               preserveScreenLockState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutButtonEnableByString(const class FString& Name, EYButtonStateAfterClick handleClickState, bool preserveScreenLockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByString");
		
		UYBlueprintLibrary_CalloutButtonEnableByString_Params params {};
		params.Name = Name;
		params.handleClickState = handleClickState;
		params.preserveScreenLockState = preserveScreenLockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743960
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYUINavigationElement*                       element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYButtonStateAfterClick                            handleClickState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               preserveScreenLockState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutButtonEnableByName(class UYUINavigationElement* element, EYButtonStateAfterClick handleClickState, bool preserveScreenLockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByName");
		
		UYBlueprintLibrary_CalloutButtonEnableByName_Params params {};
		params.element = element;
		params.handleClickState = handleClickState;
		params.preserveScreenLockState = preserveScreenLockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743870
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByIDWithoutInflatedIDs
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYButtonStateAfterClick                            handleClickState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               preserveScreenLockState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutButtonEnableByIDWithoutInflatedIDs(class UClass* element, EYButtonStateAfterClick handleClickState, bool preserveScreenLockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByIDWithoutInflatedIDs");
		
		UYBlueprintLibrary_CalloutButtonEnableByIDWithoutInflatedIDs_Params params {};
		params.element = element;
		params.handleClickState = handleClickState;
		params.preserveScreenLockState = preserveScreenLockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743780
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYButtonStateAfterClick                            handleClickState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               preserveScreenLockState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutButtonEnableByID(class UClass* element, EYButtonStateAfterClick handleClickState, bool preserveScreenLockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonEnableByID");
		
		UYBlueprintLibrary_CalloutButtonEnableByID_Params params {};
		params.element = element;
		params.handleClickState = handleClickState;
		params.preserveScreenLockState = preserveScreenLockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007436A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutButtonDisableByString(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByString");
		
		UYBlueprintLibrary_CalloutButtonDisableByString_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743590
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYUINavigationElement*                       element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutButtonDisableByName(class UYUINavigationElement* element)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByName");
		
		UYBlueprintLibrary_CalloutButtonDisableByName_Params params {};
		params.element = element;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743520
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByIntegerItemID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutButtonDisableByIntegerItemID(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByIntegerItemID");
		
		UYBlueprintLibrary_CalloutButtonDisableByIntegerItemID_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743430
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutButtonDisableByID(class UClass* element)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonDisableByID");
		
		UYBlueprintLibrary_CalloutButtonDisableByID_Params params {};
		params.element = element;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743340
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonByIntegerItemID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYButtonStateAfterClick                            handleClickState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               preserveScreenLockState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutButtonByIntegerItemID(int32_t itemID, EYButtonStateAfterClick handleClickState, bool preserveScreenLockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonByIntegerItemID");
		
		UYBlueprintLibrary_CalloutButtonByIntegerItemID_Params params {};
		params.itemID = itemID;
		params.handleClickState = handleClickState;
		params.preserveScreenLockState = preserveScreenLockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007432D0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutButtonByHowToStepEnum
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYCareerProgressionHowToStepEnum_PS4               howToStep                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutButtonByHowToStepEnum(EYCareerProgressionHowToStepEnum_PS4 howToStep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutButtonByHowToStepEnum");
		
		UYBlueprintLibrary_CalloutButtonByHowToStepEnum_Params params {};
		params.howToStep = howToStep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743250
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonEnableSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUILoadoutItemType                                loadoutType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonEnableSlot(EYUILoadoutItemType loadoutType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonEnableSlot");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonEnableSlot_Params params {};
		params.loadoutType = loadoutType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743170
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonEnableByString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonEnableByString(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonEnableByString");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonEnableByString_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743140
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonEnableAddLoadout
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	int32_t UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonEnableAddLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonEnableAddLoadout");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonEnableAddLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007430D0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUILoadoutItemType                                loadoutType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonDisableSlot(EYUILoadoutItemType loadoutType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableSlot");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonDisableSlot_Params params {};
		params.loadoutType = loadoutType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742FF0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableByString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonDisableByString(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableByString");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonDisableByString_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742F80
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYUINavigationElement*                       element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonDisableByName(class UYUINavigationElement* element)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableByName");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonDisableByName_Params params {};
		params.element = element;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742F10
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableByID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonDisableByID(class UClass* element)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableByID");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonDisableByID_Params params {};
		params.element = element;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E70
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableAddLoadout
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYBlueprintLibrary::STATIC_CalloutAlwaysUnlockButtonDisableAddLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.CalloutAlwaysUnlockButtonDisableAddLoadout");
		
		UYBlueprintLibrary_CalloutAlwaysUnlockButtonDisableAddLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742280
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.BreakTargetInfo
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FYTargetInfo                                targetInfo                                                 (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     StartLocation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     endLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               hasHit                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_BreakTargetInfo(const struct FYTargetInfo& targetInfo, class AActor** Actor, struct FVector* StartLocation, struct FVector* endLocation, bool* hasHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.BreakTargetInfo");
		
		UYBlueprintLibrary_BreakTargetInfo_Params params {};
		params.targetInfo = targetInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Actor != nullptr)
			*Actor = params.Actor;
		if (StartLocation != nullptr)
			*StartLocation = params.StartLocation;
		if (endLocation != nullptr)
			*endLocation = params.endLocation;
		if (hasHit != nullptr)
			*hasHit = params.hasHit;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007416F0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ApplyRadialHealth
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseHealth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      HealingCauser                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedByController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDoFullHealing                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UYBlueprintLibrary::STATIC_ApplyRadialHealth(class UObject* WorldContextObject, float BaseHealth, const struct FVector& Origin, float HealthRadius, class UClass* DamageTypeClass, class AActor* HealingCauser, class AController* InstigatedByController, bool bDoFullHealing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ApplyRadialHealth");
		
		UYBlueprintLibrary_ApplyRadialHealth_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BaseHealth = BaseHealth;
		params.Origin = Origin;
		params.HealthRadius = HealthRadius;
		params.DamageTypeClass = DamageTypeClass;
		params.HealingCauser = HealingCauser;
		params.InstigatedByController = InstigatedByController;
		params.bDoFullHealing = bDoFullHealing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007414B0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ApplyPointHealth
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      HealedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseHealth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HealFromDirection                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AController*                                 eventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      HealCauser                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_ApplyPointHealth(class AActor* HealedActor, float BaseHealth, const struct FVector& HealFromDirection, const struct FHitResult& HitInfo, class AController* eventInstigator, class AActor* HealCauser, class UClass* DamageTypeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ApplyPointHealth");
		
		UYBlueprintLibrary_ApplyPointHealth_Params params {};
		params.HealedActor = HealedActor;
		params.BaseHealth = BaseHealth;
		params.HealFromDirection = HealFromDirection;
		params.HitInfo = HitInfo;
		params.eventInstigator = eventInstigator;
		params.HealCauser = HealCauser;
		params.DamageTypeClass = DamageTypeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007411D0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.ApplyHealth
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      HealedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseHealth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 eventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      HealCauser                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_ApplyHealth(class AActor* HealedActor, float BaseHealth, class AController* eventInstigator, class AActor* HealCauser, class UClass* DamageTypeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.ApplyHealth");
		
		UYBlueprintLibrary_ApplyHealth_Params params {};
		params.HealedActor = HealedActor;
		params.BaseHealth = BaseHealth;
		params.eventInstigator = eventInstigator;
		params.HealCauser = HealCauser;
		params.DamageTypeClass = DamageTypeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740F20
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.AnalyticsSendTutorialEvent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYGameMode*                                  GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            stepId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      stepName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_AnalyticsSendTutorialEvent(class AYGameMode* GameMode, int32_t stepId, const class FString& stepName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.AnalyticsSendTutorialEvent");
		
		UYBlueprintLibrary_AnalyticsSendTutorialEvent_Params params {};
		params.GameMode = GameMode;
		params.stepId = stepId;
		params.stepName = stepName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740DC0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.AnalyticsSendButtonEvent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      parentName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_AnalyticsSendButtonEvent(const class FString& Name, const class FString& parentName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.AnalyticsSendButtonEvent");
		
		UYBlueprintLibrary_AnalyticsSendButtonEvent_Params params {};
		params.Name = Name;
		params.parentName = parentName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F5A0
	 * 		Name   -> Function DreadGame.YBlueprintLibrary.AddMapCheck
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYE_MCType                                         MessageType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBlueprintLibrary::STATIC_AddMapCheck(EYE_MCType MessageType, class UObject* Owner, const class FString& Text, const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBlueprintLibrary.AddMapCheck");
		
		UYBlueprintLibrary_AddMapCheck_Params params {};
		params.MessageType = MessageType;
		params.Owner = Owner;
		params.Text = Text;
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterAssetConditional.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterAssetConditional::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterAssetConditional");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGoldMembership.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGoldMembership::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGoldMembership");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYLEDPeripheralEffectActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYLEDPeripheralEffectActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLEDPeripheralEffectActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782D80
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.UnMuteMusicBus
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::UnMuteMusicBus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.UnMuteMusicBus");
		
		AYPlayerControllerBase_UnMuteMusicBus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.TutorialFinished
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::TutorialFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.TutorialFinished");
		
		AYPlayerControllerBase_TutorialFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780860
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.SubtractFromPlayerCurrency
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYCurrency                                         currency                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      transactionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::SubtractFromPlayerCurrency(EYCurrency currency, int32_t amount, const class FString& transactionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.SubtractFromPlayerCurrency");
		
		AYPlayerControllerBase_SubtractFromPlayerCurrency_Params params {};
		params.currency = currency;
		params.amount = amount;
		params.transactionName = transactionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.StopRemainingGameTime
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::StopRemainingGameTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.StopRemainingGameTime");
		
		AYPlayerControllerBase_StopRemainingGameTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007802A0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.StopMovieExec
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::StopMovieExec()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.StopMovieExec");
		
		AYPlayerControllerBase_StopMovieExec_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780280
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.StopMovie
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::StopMovie()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.StopMovie");
		
		AYPlayerControllerBase_StopMovie_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.StartRemainingGameTime
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::StartRemainingGameTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.StartRemainingGameTime");
		
		AYPlayerControllerBase_StartRemainingGameTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ShowTargetDebugAI
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::ShowTargetDebugAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ShowTargetDebugAI");
		
		AYPlayerControllerBase_ShowTargetDebugAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.SetRemainingGameTime
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            newRemainingTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::SetRemainingGameTime(int32_t newRemainingTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.SetRemainingGameTime");
		
		AYPlayerControllerBase_SetRemainingGameTime_Params params {};
		params.newRemainingTime = newRemainingTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007787A0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.SetLateJoiner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::SetLateJoiner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.SetLateJoiner");
		
		AYPlayerControllerBase_SetLateJoiner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773A20
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ServerShowTargetDebugAI
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		struct FVector                                     viewPos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     viewDir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::ServerShowTargetDebugAI(const struct FVector& viewPos, const struct FVector& viewDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ServerShowTargetDebugAI");
		
		AYPlayerControllerBase_ServerShowTargetDebugAI_Params params {};
		params.viewPos = viewPos;
		params.viewDir = viewDir;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773560
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ServerSetPlayerAway
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               away                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               idleKickEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::ServerSetPlayerAway(bool away, bool idleKickEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ServerSetPlayerAway");
		
		AYPlayerControllerBase_ServerSetPlayerAway_Params params {};
		params.away = away;
		params.idleKickEnabled = idleKickEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771AB0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ServerEnableScoringSystem
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::ServerEnableScoringSystem(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ServerEnableScoringSystem");
		
		AYPlayerControllerBase_ServerEnableScoringSystem_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774F50
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.Server_ClientFinishedPath
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            pathId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FVector>                             resultPath                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               reachedGoal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              timeCalculating                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::Server_ClientFinishedPath(int32_t pathId, TArray<struct FVector> resultPath, bool reachedGoal, float timeCalculating)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.Server_ClientFinishedPath");
		
		AYPlayerControllerBase_Server_ClientFinishedPath_Params params {};
		params.pathId = pathId;
		params.resultPath = resultPath;
		params.reachedGoal = reachedGoal;
		params.timeCalculating = timeCalculating;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FC50
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ResetOnboardingEventManager
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::ResetOnboardingEventManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ResetOnboardingEventManager");
		
		AYPlayerControllerBase_ResetOnboardingEventManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.RefreshGoalUIGuideEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYPlayerControllerBase::RefreshGoalUIGuideEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.RefreshGoalUIGuideEvent");
		
		AYPlayerControllerBase_RefreshGoalUIGuideEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DF10
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.PrintFeats
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::PrintFeats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.PrintFeats");
		
		AYPlayerControllerBase_PrintFeats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D310
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.PlayMovieExec
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::PlayMovieExec(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.PlayMovieExec");
		
		AYPlayerControllerBase_PlayMovieExec_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D110
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.PlayMovieByID
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        movieID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               loop                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, AdvancedDisplay, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::PlayMovieByID(const class FName& movieID, bool loop, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.PlayMovieByID");
		
		AYPlayerControllerBase_PlayMovieByID_Params params {};
		params.movieID = movieID;
		params.loop = loop;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076CBD0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.PauseMovie
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::PauseMovie()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.PauseMovie");
		
		AYPlayerControllerBase_PauseMovie_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnPreSendPlayerData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerControllerBase::OnPreSendPlayerData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnPreSendPlayerData");
		
		AYPlayerControllerBase_OnPreSendPlayerData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerStateAvaiable__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::OnPlayerStateAvaiable__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerStateAvaiable__DelegateSignature");
		
		AYPlayerControllerBase_OnPlayerStateAvaiable__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerReturned__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::OnPlayerReturned__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerReturned__DelegateSignature");
		
		AYPlayerControllerBase_OnPlayerReturned__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767C10
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnPlayerDataAvailable
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerControllerBase::OnPlayerDataAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnPlayerDataAvailable");
		
		AYPlayerControllerBase_OnPlayerDataAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerDataAvaiable__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::OnPlayerDataAvaiable__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerDataAvaiable__DelegateSignature");
		
		AYPlayerControllerBase_OnPlayerDataAvaiable__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerAway__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::OnPlayerAway__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnPlayerAway__DelegateSignature");
		
		AYPlayerControllerBase_OnPlayerAway__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnPawnChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPawn*                                      NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnPawnChanged__DelegateSignature(class AYPawn* NewPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnPawnChanged__DelegateSignature");
		
		AYPlayerControllerBase_OnPawnChanged__DelegateSignature_Params params {};
		params.NewPawn = NewPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnOnboardingInitialized
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYPlayerControllerBase::OnOnboardingInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnOnboardingInitialized");
		
		AYPlayerControllerBase_OnOnboardingInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnOnboardingEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        trigeredRule                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnOnboardingEvent(const class FName& trigeredRule)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnOnboardingEvent");
		
		AYPlayerControllerBase_OnOnboardingEvent_Params params {};
		params.trigeredRule = trigeredRule;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765D80
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnOfficerManagerInitializationComplete
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerControllerBase::OnOfficerManagerInitializationComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnOfficerManagerInitializationComplete");
		
		AYPlayerControllerBase_OnOfficerManagerInitializationComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007657D0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnMovieStopped
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerControllerBase::OnMovieStopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnMovieStopped");
		
		AYPlayerControllerBase_OnMovieStopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007656C0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnMovieStarted
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnMovieStarted(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnMovieStarted");
		
		AYPlayerControllerBase_OnMovieStarted_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnLocalPlayerSet
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYPlayerControllerBase::OnLocalPlayerSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnLocalPlayerSet");
		
		AYPlayerControllerBase_OnLocalPlayerSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnLocalPlayerAvailable__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::OnLocalPlayerAvailable__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnLocalPlayerAvailable__DelegateSignature");
		
		AYPlayerControllerBase_OnLocalPlayerAvailable__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnGoalUIGuideEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnGoalUIGuideEvent(const class FName& goalId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnGoalUIGuideEvent");
		
		AYPlayerControllerBase_OnGoalUIGuideEvent_Params params {};
		params.goalId = goalId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnGoalRewardEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnGoalRewardEvent(const class FName& goalId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnGoalRewardEvent");
		
		AYPlayerControllerBase_OnGoalRewardEvent_Params params {};
		params.goalId = goalId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnGoalReadyToBeClaimedEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnGoalReadyToBeClaimedEvent(const class FName& goalId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnGoalReadyToBeClaimedEvent");
		
		AYPlayerControllerBase_OnGoalReadyToBeClaimedEvent_Params params {};
		params.goalId = goalId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnGoalPinnedEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnGoalPinnedEvent(const class FName& goalId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnGoalPinnedEvent");
		
		AYPlayerControllerBase_OnGoalPinnedEvent_Params params {};
		params.goalId = goalId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnGoalManagerInitialized
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYPlayerControllerBase::OnGoalManagerInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnGoalManagerInitialized");
		
		AYPlayerControllerBase_OnGoalManagerInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnGoalCategoryUnlockedEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYGoalCategory                                     Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::OnGoalCategoryUnlockedEvent(EYGoalCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnGoalCategoryUnlockedEvent");
		
		AYPlayerControllerBase_OnGoalCategoryUnlockedEvent_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763EB0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnFleetInitializationComplete
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerControllerBase::OnFleetInitializationComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnFleetInitializationComplete");
		
		AYPlayerControllerBase_OnFleetInitializationComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnDataManagerInitialized__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::OnDataManagerInitialized__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnDataManagerInitialized__DelegateSignature");
		
		AYPlayerControllerBase_OnDataManagerInitialized__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.OnCalloutButtonClicked
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            calloutButtonClicked                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYPlayerControllerBase::OnCalloutButtonClicked(int32_t calloutButtonClicked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.OnCalloutButtonClicked");
		
		AYPlayerControllerBase_OnCalloutButtonClicked_Params params {};
		params.calloutButtonClicked = calloutButtonClicked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.OnAnyKeyPressed__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::OnAnyKeyPressed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.OnAnyKeyPressed__DelegateSignature");
		
		AYPlayerControllerBase_OnAnyKeyPressed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761E60
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.NotifyOnboardingTutorialFinished
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::NotifyOnboardingTutorialFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.NotifyOnboardingTutorialFinished");
		
		AYPlayerControllerBase_NotifyOnboardingTutorialFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerControllerBase.NotifyGamePause__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerControllerBase::NotifyGamePause__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerControllerBase.NotifyGamePause__DelegateSignature");
		
		AYPlayerControllerBase_NotifyGamePause__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761790
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.MuteMusicBus
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::MuteMusicBus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.MuteMusicBus");
		
		AYPlayerControllerBase_MuteMusicBus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.MinimapZoomCycle
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::MinimapZoomCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.MinimapZoomCycle");
		
		AYPlayerControllerBase_MinimapZoomCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.MarkTarget
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::MarkTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.MarkTarget");
		
		AYPlayerControllerBase_MarkTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FAD0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.IsSinglePlayerController
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	bool AYPlayerControllerBase::IsSinglePlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.IsSinglePlayerController");
		
		AYPlayerControllerBase_IsSinglePlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F4B0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.IsPlayerAway
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AYPlayerControllerBase::IsPlayerAway()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.IsPlayerAway");
		
		AYPlayerControllerBase_IsPlayerAway_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F160
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.IsMoviePlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPlayerControllerBase::IsMoviePlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.IsMoviePlaying");
		
		AYPlayerControllerBase_IsMoviePlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F070
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.IsLateJoiner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AYPlayerControllerBase::IsLateJoiner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.IsLateJoiner");
		
		AYPlayerControllerBase_IsLateJoiner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CEC0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.InitDataManager
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerControllerBase::InitDataManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.InitDataManager");
		
		AYPlayerControllerBase_InitDataManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B390
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.HandleLeftMouseButtonReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::HandleLeftMouseButtonReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.HandleLeftMouseButtonReleased");
		
		AYPlayerControllerBase_HandleLeftMouseButtonReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B370
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.HandleLeftMouseButtonPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::HandleLeftMouseButtonPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.HandleLeftMouseButtonPressed");
		
		AYPlayerControllerBase_HandleLeftMouseButtonPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B350
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.HandleGamepadInputPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::HandleGamepadInputPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.HandleGamepadInputPressed");
		
		AYPlayerControllerBase_HandleGamepadInputPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B330
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.HandleAnyKeyReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::HandleAnyKeyReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.HandleAnyKeyReleased");
		
		AYPlayerControllerBase_HandleAnyKeyReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B310
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.HandleAnyKeyPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerControllerBase::HandleAnyKeyPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.HandleAnyKeyPressed");
		
		AYPlayerControllerBase_HandleAnyKeyPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B250
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GiveCurrency
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            currency                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::GiveCurrency(int32_t currency, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GiveCurrency");
		
		AYPlayerControllerBase_GiveCurrency_Params params {};
		params.currency = currency;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B0B0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetYPlayerInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYPlayerInput* AYPlayerControllerBase::GetYPlayerInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetYPlayerInput");
		
		AYPlayerControllerBase_GetYPlayerInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ABE0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetYPawn
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPawn* AYPlayerControllerBase::GetYPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetYPawn");
		
		AYPlayerControllerBase_GetYPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075AB50
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetXPManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYXPManager* AYPlayerControllerBase::GetXPManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetXPManager");
		
		AYPlayerControllerBase_GetXPManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757C50
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetSPLocalPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYDreadnoughtLocalPlayer* AYPlayerControllerBase::GetSPLocalPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetSPLocalPlayer");
		
		AYPlayerControllerBase_GetSPLocalPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757E30
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetScoringComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYScoringEventComponent* AYPlayerControllerBase::GetScoringComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetScoringComponent");
		
		AYPlayerControllerBase_GetScoringComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757BF0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetReputationManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYReputationManager* AYPlayerControllerBase::GetReputationManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetReputationManager");
		
		AYPlayerControllerBase_GetReputationManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757210
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetProgressionManagerClient
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYProgressionManagerClient* AYPlayerControllerBase::GetProgressionManagerClient()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetProgressionManagerClient");
		
		AYPlayerControllerBase_GetProgressionManagerClient_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007571E0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetProgressionManagerBattleServer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYProgressionManagerBattleServer* AYPlayerControllerBase::GetProgressionManagerBattleServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetProgressionManagerBattleServer");
		
		AYPlayerControllerBase_GetProgressionManagerBattleServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007571B0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetProgressionManagerBase
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYProgressionManagerBase* AYPlayerControllerBase::GetProgressionManagerBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetProgressionManagerBase");
		
		AYPlayerControllerBase_GetProgressionManagerBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756DB0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetPlayerReplicationInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPlayerReplicationInfo* AYPlayerControllerBase::GetPlayerReplicationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetPlayerReplicationInfo");
		
		AYPlayerControllerBase_GetPlayerReplicationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756B20
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetPlayerCurrency
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYCurrency                                         currency                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYPlayerControllerBase::GetPlayerCurrency(EYCurrency currency)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetPlayerCurrency");
		
		AYPlayerControllerBase_GetPlayerCurrency_Params params {};
		params.currency = currency;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756980
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetPeripheralEventMgr
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYPeripheralEventMgr* AYPlayerControllerBase::GetPeripheralEventMgr()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetPeripheralEventMgr");
		
		AYPlayerControllerBase_GetPeripheralEventMgr_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007559A0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetOrCreateCheatManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYCheatManager* AYPlayerControllerBase::GetOrCreateCheatManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetOrCreateCheatManager");
		
		AYPlayerControllerBase_GetOrCreateCheatManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755880
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetOnboardingEventManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYOnboardingManager* AYPlayerControllerBase::GetOnboardingEventManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetOnboardingEventManager");
		
		AYPlayerControllerBase_GetOnboardingEventManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755760
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetOfficerManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYOfficerManager* AYPlayerControllerBase::GetOfficerManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetOfficerManager");
		
		AYPlayerControllerBase_GetOfficerManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754E20
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetMovieManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYMovieManager* AYPlayerControllerBase::GetMovieManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetMovieManager");
		
		AYPlayerControllerBase_GetMovieManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007541E0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetMediaPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UMediaPlayer* AYPlayerControllerBase::GetMediaPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetMediaPlayer");
		
		AYPlayerControllerBase_GetMediaPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753B20
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetLoadoutManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYLoadoutManagerComponent* AYPlayerControllerBase::GetLoadoutManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetLoadoutManager");
		
		AYPlayerControllerBase_GetLoadoutManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752C70
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetInventoryManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYInventoryManager* AYPlayerControllerBase::GetInventoryManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetInventoryManager");
		
		AYPlayerControllerBase_GetInventoryManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752280
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetGoldMembershipComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYGoldMembershipComponent* AYPlayerControllerBase::GetGoldMembershipComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetGoldMembershipComponent");
		
		AYPlayerControllerBase_GetGoldMembershipComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752250
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetGoalManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYGoalManager* AYPlayerControllerBase::GetGoalManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetGoalManager");
		
		AYPlayerControllerBase_GetGoalManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751C70
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetFleetManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYFleetManager* AYPlayerControllerBase::GetFleetManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetFleetManager");
		
		AYPlayerControllerBase_GetFleetManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007516A0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetDefaultPeripheralEffectsClassForBattle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UClass* AYPlayerControllerBase::GetDefaultPeripheralEffectsClassForBattle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetDefaultPeripheralEffectsClassForBattle");
		
		AYPlayerControllerBase_GetDefaultPeripheralEffectsClassForBattle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007509B0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetCurrentMapName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString AYPlayerControllerBase::GetCurrentMapName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetCurrentMapName");
		
		AYPlayerControllerBase_GetCurrentMapName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074FFA0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetCombatManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYAICombatSceneManager* AYPlayerControllerBase::GetCombatManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetCombatManager");
		
		AYPlayerControllerBase_GetCombatManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E220
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetCaptain
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYCaptain* AYPlayerControllerBase::GetCaptain()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetCaptain");
		
		AYPlayerControllerBase_GetCaptain_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DF60
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.GetBoosterComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYBoosterComponent* AYPlayerControllerBase::GetBoosterComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.GetBoosterComponent");
		
		AYPlayerControllerBase_GetBoosterComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ForceUnloadLevel
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::ForceUnloadLevel(const class FName& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ForceUnloadLevel");
		
		AYPlayerControllerBase_ForceUnloadLevel_Params params {};
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ForceUnloadAllLevels
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::ForceUnloadAllLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ForceUnloadAllLevels");
		
		AYPlayerControllerBase_ForceUnloadAllLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ForceLoadLevel
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::ForceLoadLevel(const class FName& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ForceLoadLevel");
		
		AYPlayerControllerBase_ForceLoadLevel_Params params {};
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ForceLoadAllLevels
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::ForceLoadAllLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ForceLoadAllLevels");
		
		AYPlayerControllerBase_ForceLoadAllLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B610
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.EnableScoringSystem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::EnableScoringSystem(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.EnableScoringSystem");
		
		AYPlayerControllerBase_EnableScoringSystem_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B390
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.DumpOnboardingStates
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::DumpOnboardingStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.DumpOnboardingStates");
		
		AYPlayerControllerBase_DumpOnboardingStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B370
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.DumpOnboardingQueue
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::DumpOnboardingQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.DumpOnboardingQueue");
		
		AYPlayerControllerBase_DumpOnboardingQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B330
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.DumpGoals
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerControllerBase::DumpGoals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.DumpGoals");
		
		AYPlayerControllerBase_DumpGoals_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746830
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ClientSetActiveFleetId
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FName                                        fleetId                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::ClientSetActiveFleetId(const class FName& fleetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ClientSetActiveFleetId");
		
		AYPlayerControllerBase_ClientSetActiveFleetId_Params params {};
		params.fleetId = fleetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747EC0
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.Client_StartDistributedPath
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, NetValidate)
	 * Parameters:
	 * 		int32_t                                            pathId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxPathSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Start                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              filterCloserThanSqr                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            tunnelSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxExpansions                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              targetCover                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              coverPenalty                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              awayFromGoal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               awayFromGoalXYAxesOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              turnPenalty                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              turnPenaltyDPD                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              turnPenaltyMaxD                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     turnStart                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     avoidActorLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              avoidActorRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              avoidActorPenalty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            smoothMaxConsecutiveNodes                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              smoothShipRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              smoothAllowAvoidAreaLoss                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            smoothAllowCoverLoss                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::Client_StartDistributedPath(int32_t pathId, int32_t maxPathSize, const struct FVector& Start, float filterCloserThanSqr, int32_t tunnelSize, const struct FVector& Target, int32_t maxExpansions, float targetCover, float coverPenalty, float awayFromGoal, bool awayFromGoalXYAxesOnly, float turnPenalty, float turnPenaltyDPD, float turnPenaltyMaxD, const struct FVector& turnStart, const struct FVector& avoidActorLocation, float avoidActorRadius, float avoidActorPenalty, int32_t smoothMaxConsecutiveNodes, float smoothShipRadius, float smoothAllowAvoidAreaLoss, int32_t smoothAllowCoverLoss)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.Client_StartDistributedPath");
		
		AYPlayerControllerBase_Client_StartDistributedPath_Params params {};
		params.pathId = pathId;
		params.maxPathSize = maxPathSize;
		params.Start = Start;
		params.filterCloserThanSqr = filterCloserThanSqr;
		params.tunnelSize = tunnelSize;
		params.Target = Target;
		params.maxExpansions = maxExpansions;
		params.targetCover = targetCover;
		params.coverPenalty = coverPenalty;
		params.awayFromGoal = awayFromGoal;
		params.awayFromGoalXYAxesOnly = awayFromGoalXYAxesOnly;
		params.turnPenalty = turnPenalty;
		params.turnPenaltyDPD = turnPenaltyDPD;
		params.turnPenaltyMaxD = turnPenaltyMaxD;
		params.turnStart = turnStart;
		params.avoidActorLocation = avoidActorLocation;
		params.avoidActorRadius = avoidActorRadius;
		params.avoidActorPenalty = avoidActorPenalty;
		params.smoothMaxConsecutiveNodes = smoothMaxConsecutiveNodes;
		params.smoothShipRadius = smoothShipRadius;
		params.smoothAllowAvoidAreaLoss = smoothAllowAvoidAreaLoss;
		params.smoothAllowCoverLoss = smoothAllowCoverLoss;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744550
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.ClaimGoal
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        goaldID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::ClaimGoal(const class FName& goaldID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.ClaimGoal");
		
		AYPlayerControllerBase_ClaimGoal_Params params {};
		params.goaldID = goaldID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.CallSoundResumeEvent
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerControllerBase::CallSoundResumeEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.CallSoundResumeEvent");
		
		AYPlayerControllerBase_CallSoundResumeEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.CallSoundPauseEvent
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerControllerBase::CallSoundPauseEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.CallSoundPauseEvent");
		
		AYPlayerControllerBase_CallSoundPauseEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740350
	 * 		Name   -> Function DreadGame.YPlayerControllerBase.AddPlayerCurrency
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYCurrency                                         currency                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      transactionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerControllerBase::AddPlayerCurrency(EYCurrency currency, int32_t amount, const class FString& transactionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerControllerBase.AddPlayerCurrency");
		
		AYPlayerControllerBase_AddPlayerCurrency_Params params {};
		params.currency = currency;
		params.amount = amount;
		params.transactionName = transactionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerControllerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerControllerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerControllerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EBA0
	 * 		Name   -> Function DreadGame.YBoosterComponentBase.RemoveBooster
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ownerID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBoosterComponentBase::RemoveBooster(int32_t itemID, const class FName& ownerID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponentBase.RemoveBooster");
		
		UYBoosterComponentBase_RemoveBooster_Params params {};
		params.itemID = itemID;
		params.ownerID = ownerID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B410
	 * 		Name   -> Function DreadGame.YBoosterComponentBase.OnTeamBoosterRemoved
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYBoosterContainer                          booster                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYBoosterComponentBase::OnTeamBoosterRemoved(EYTeam Team, const struct FYBoosterContainer& booster)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponentBase.OnTeamBoosterRemoved");
		
		UYBoosterComponentBase_OnTeamBoosterRemoved_Params params {};
		params.Team = Team;
		params.booster = booster;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B320
	 * 		Name   -> Function DreadGame.YBoosterComponentBase.OnTeamBoosterAdded
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYBoosterContainer                          booster                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYBoosterComponentBase::OnTeamBoosterAdded(EYTeam Team, const struct FYBoosterContainer& booster)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponentBase.OnTeamBoosterAdded");
		
		UYBoosterComponentBase_OnTeamBoosterAdded_Params params {};
		params.Team = Team;
		params.booster = booster;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E7B0
	 * 		Name   -> Function DreadGame.YBoosterComponentBase.AddBooster
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBoosterComponentBase::AddBooster(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponentBase.AddBooster");
		
		UYBoosterComponentBase_AddBooster_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterComponentBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterComponentBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterComponentBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783000
	 * 		Name   -> Function DreadGame.YBoosterComponent.UpdateBoosterConditions
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYBoosterComponent::UpdateBoosterConditions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponent.UpdateBoosterConditions");
		
		UYBoosterComponent_UpdateBoosterConditions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767CB0
	 * 		Name   -> Function DreadGame.YBoosterComponent.OnPlayerLeftMatch
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class APlayerState*                                playerLeaving                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYBoosterComponent::OnPlayerLeftMatch(class APlayerState* playerLeaving)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponent.OnPlayerLeftMatch");
		
		UYBoosterComponent_OnPlayerLeftMatch_Params params {};
		params.playerLeaving = playerLeaving;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D4D0
	 * 		Name   -> Function DreadGame.YBoosterComponent.InitializeFromTeammatesPool
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYBoosterComponent::InitializeFromTeammatesPool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponent.InitializeFromTeammatesPool");
		
		UYBoosterComponent_InitializeFromTeammatesPool_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D470
	 * 		Name   -> Function DreadGame.YBoosterComponent.InitializeFromInventory
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYBoosterComponent::InitializeFromInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponent.InitializeFromInventory");
		
		UYBoosterComponent_InitializeFromInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YBoosterComponent.InitializeBoosters
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYBoosterComponent::InitializeBoosters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBoosterComponent.InitializeBoosters");
		
		UYBoosterComponent_InitializeBoosters_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D940
	 * 		Name   -> Function DreadGame.YGoldMembershipComponent.InitializeTeammatesGoldMembershipBonus
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGoldMembershipComponent::InitializeTeammatesGoldMembershipBonus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoldMembershipComponent.InitializeTeammatesGoldMembershipBonus");
		
		UYGoldMembershipComponent_InitializeTeammatesGoldMembershipBonus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D7C0
	 * 		Name   -> Function DreadGame.YGoldMembershipComponent.InitializePlayerGoldMembership
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGoldMembershipComponent::InitializePlayerGoldMembership()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoldMembershipComponent.InitializePlayerGoldMembership");
		
		UYGoldMembershipComponent_InitializePlayerGoldMembership_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGoldMembershipComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGoldMembershipComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGoldMembershipComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_AFK.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_AFK::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_AFK");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_BattleReadyLegendary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_BattleReadyLegendary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_BattleReadyLegendary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_BattleReadyRecruit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_BattleReadyRecruit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_BattleReadyRecruit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_BattleReadyVeteran.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_BattleReadyVeteran::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_BattleReadyVeteran");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_FirstWinOfTheDay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_FirstWinOfTheDay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_FirstWinOfTheDay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_GoldMember.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_GoldMember::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_GoldMember");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_LeaveMatch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_LeaveMatch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_LeaveMatch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_MatchOutcome.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_MatchOutcome::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_MatchOutcome");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_TimeSinceLastMatch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_TimeSinceLastMatch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_TimeSinceLastMatch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBoosterCondition_UsedTraderShip.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBoosterCondition_UsedTraderShip::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBoosterCondition_UsedTraderShip");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007427F0
	 * 		Name   -> Function DreadGame.YBuffsComponent.BuffEffectDeactivated
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FYBuff                                      buff                                                       (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UYBuffsComponent::BuffEffectDeactivated(struct FYBuff* buff)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBuffsComponent.BuffEffectDeactivated");
		
		UYBuffsComponent_BuffEffectDeactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (buff != nullptr)
			*buff = params.buff;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBuffsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBuffsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBuffsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007628F0
	 * 		Name   -> Function DreadGame.YBugReporter.OnBugReportCreated
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYBugReporter::OnBugReportCreated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBugReporter.OnBugReportCreated");
		
		UYBugReporter_OnBugReportCreated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBugReporter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBugReporter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBugReporter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C0B0
	 * 		Name   -> Function DreadGame.YCachedItemIDData.FindItemIdsOfType
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            tier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYCachedItemType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<int32_t>                                    outIds                                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               inflate                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYCachedItemIDData::STATIC_FindItemIdsOfType(int32_t tier, EYCachedItemType Type, TArray<int32_t>* outIds, bool inflate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCachedItemIDData.FindItemIdsOfType");
		
		UYCachedItemIDData_FindItemIdsOfType_Params params {};
		params.tier = tier;
		params.Type = Type;
		params.inflate = inflate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outIds != nullptr)
			*outIds = params.outIds;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BFE0
	 * 		Name   -> Function DreadGame.YCachedItemIDData.FindInflatedItemIDs
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<int32_t>                                    outIds                                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYCachedItemIDData::STATIC_FindInflatedItemIDs(int32_t itemID, TArray<int32_t>* outIds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCachedItemIDData.FindInflatedItemIDs");
		
		UYCachedItemIDData_FindInflatedItemIDs_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outIds != nullptr)
			*outIds = params.outIds;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCachedItemIDData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCachedItemIDData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCachedItemIDData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterCustomizationAssetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterCustomizationAssetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterCustomizationAssetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterCustomizationGender.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterCustomizationGender::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterCustomizationGender");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DA00
	 * 		Name   -> Function DreadGame.YCaptain.PlayerDisplayDataUpdated
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYCaptain::PlayerDisplayDataUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.PlayerDisplayDataUpdated");
		
		UYCaptain_PlayerDisplayDataUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YCaptain.OnCaptainUpdateFailedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYCaptain::OnCaptainUpdateFailedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YCaptain.OnCaptainUpdateFailedSignature__DelegateSignature");
		
		UYCaptain_OnCaptainUpdateFailedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YCaptain.OnCaptainUpdatedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYCaptain::OnCaptainUpdatedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YCaptain.OnCaptainUpdatedSignature__DelegateSignature");
		
		UYCaptain_OnCaptainUpdatedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E9A2E0
	 * 		Name   -> Function DreadGame.YCaptain.InitializeFromPlayerData
	 * 		Flags  -> (Native, Protected)
	 */
	void UYCaptain::InitializeFromPlayerData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.InitializeFromPlayerData");
		
		UYCaptain_InitializeFromPlayerData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C520
	 * 		Name   -> Function DreadGame.YCaptain.HasOnlySubtitlesInComWindow
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYCaptain::HasOnlySubtitlesInComWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.HasOnlySubtitlesInComWindow");
		
		UYCaptain_HasOnlySubtitlesInComWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752100
	 * 		Name   -> Function DreadGame.YCaptain.GetGender
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UYCaptain::GetGender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.GetGender");
		
		UYCaptain_GetGender_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EDC0
	 * 		Name   -> Function DreadGame.YCaptain.GetCharacterTag
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UYCaptain::GetCharacterTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.GetCharacterTag");
		
		UYCaptain_GetCharacterTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EC40
	 * 		Name   -> Function DreadGame.YCaptain.GetCharacterName
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UYCaptain::GetCharacterName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.GetCharacterName");
		
		UYCaptain_GetCharacterName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EB80
	 * 		Name   -> Function DreadGame.YCaptain.GetCharacterImage
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTexture* UYCaptain::GetCharacterImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.GetCharacterImage");
		
		UYCaptain_GetCharacterImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E780
	 * 		Name   -> Function DreadGame.YCaptain.GetCharacterAppearance
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYCharacterAppearance UYCaptain::GetCharacterAppearance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCaptain.GetCharacterAppearance");
		
		UYCaptain_GetCharacterAppearance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCaptain.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCaptain::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCaptain");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779F70
	 * 		Name   -> Function DreadGame.YPlayerStart.SetPlayerStartTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             newTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerStart::SetPlayerStartTeam(EYTeam newTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStart.SetPlayerStartTeam");
		
		AYPlayerStart_SetPlayerStartTeam_Params params {};
		params.newTeam = newTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007755B0
	 * 		Name   -> Function DreadGame.YPlayerStart.SetActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerStart::SetActive(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStart.SetActive");
		
		AYPlayerStart_SetActive_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768370
	 * 		Name   -> Function DreadGame.YPlayerStart.OnPlayerSpawned
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerStart::OnPlayerSpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStart.OnPlayerSpawned");
		
		AYPlayerStart_OnPlayerSpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E2F0
	 * 		Name   -> Function DreadGame.YPlayerStart.IsBlockedByPawn
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYPlayerStart::IsBlockedByPawn(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStart.IsBlockedByPawn");
		
		AYPlayerStart_IsBlockedByPawn_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E000
	 * 		Name   -> Function DreadGame.YPlayerStart.IsActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPlayerStart::IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStart.IsActive");
		
		AYPlayerStart_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756EA0
	 * 		Name   -> Function DreadGame.YPlayerStart.GetPlayerStartTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam AYPlayerStart::GetPlayerStartTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStart.GetPlayerStartTeam");
		
		AYPlayerStart_GetPlayerStartTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D050
	 * 		Name   -> Function DreadGame.YPlayerStart.GetActorLinkedTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AActor* AYPlayerStart::GetActorLinkedTo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStart.GetActorLinkedTo");
		
		AYPlayerStart_GetActorLinkedTo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BE00
	 * 		Name   -> Function DreadGame.YCapturePoint.SetTeamOwningSpawnPointsActive
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::SetTeamOwningSpawnPointsActive(EYTeam Team, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.SetTeamOwningSpawnPointsActive");
		
		AYCapturePoint_SetTeamOwningSpawnPointsActive_Params params {};
		params.Team = Team;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BD80
	 * 		Name   -> Function DreadGame.YCapturePoint.SetTeamOwnerSpawnPoints
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::SetTeamOwnerSpawnPoints(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.SetTeamOwnerSpawnPoints");
		
		AYCapturePoint_SetTeamOwnerSpawnPoints_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779550
	 * 		Name   -> Function DreadGame.YCapturePoint.SetObjectiveTeams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<EYTeam>                                     teams                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::SetObjectiveTeams(TArray<EYTeam> teams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.SetObjectiveTeams");
		
		AYCapturePoint_SetObjectiveTeams_Params params {};
		params.teams = teams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007789B0
	 * 		Name   -> Function DreadGame.YCapturePoint.SetLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsLocked                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::SetLocked(bool bIsLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.SetLocked");
		
		AYCapturePoint_SetLocked_Params params {};
		params.bIsLocked = bIsLocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007761C0
	 * 		Name   -> Function DreadGame.YCapturePoint.SetCapturePoint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::SetCapturePoint(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.SetCapturePoint");
		
		AYCapturePoint_SetCapturePoint_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775800
	 * 		Name   -> Function DreadGame.YCapturePoint.SetAllSpawnPointsActive
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::SetAllSpawnPointsActive(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.SetAllSpawnPointsActive");
		
		AYCapturePoint_SetAllSpawnPointsActive_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FBD0
	 * 		Name   -> Function DreadGame.YCapturePoint.ResetCapturePoint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYCapturePoint::ResetCapturePoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.ResetCapturePoint");
		
		AYCapturePoint_ResetCapturePoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCapturePoint.ReceiveOnRepStationOwnerChange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYCapturePoint::ReceiveOnRepStationOwnerChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.ReceiveOnRepStationOwnerChange");
		
		AYCapturePoint_ReceiveOnRepStationOwnerChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCapturePoint.ReceiveOnRepStationCapturingTeam
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               beingCaptured                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::ReceiveOnRepStationCapturingTeam(bool beingCaptured)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.ReceiveOnRepStationCapturingTeam");
		
		AYCapturePoint_ReceiveOnRepStationCapturingTeam_Params params {};
		params.beingCaptured = beingCaptured;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCapturePoint.OnSetLocked
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsLocked                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::OnSetLocked(bool bIsLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnSetLocked");
		
		AYCapturePoint_OnSetLocked_Params params {};
		params.bIsLocked = bIsLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769180
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_StationOwner
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYCapturePoint::OnRep_StationOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_StationOwner");
		
		AYCapturePoint_OnRep_StationOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E9A2A0
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_StationIndex
	 * 		Flags  -> (Native, Public)
	 */
	void AYCapturePoint::OnRep_StationIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_StationIndex");
		
		AYCapturePoint_OnRep_StationIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769160
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_StationCapturingTeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYCapturePoint::OnRep_StationCapturingTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_StationCapturingTeam");
		
		AYCapturePoint_OnRep_StationCapturingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007693C0
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_objectiveTeams
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYCapturePoint::OnRep_objectiveTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_objectiveTeams");
		
		AYCapturePoint_OnRep_objectiveTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_LockTime
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYCapturePoint::OnRep_LockTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_LockTime");
		
		AYCapturePoint_OnRep_LockTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768C20
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_CurrentHealth
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYCapturePoint::OnRep_CurrentHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_CurrentHealth");
		
		AYCapturePoint_OnRep_CurrentHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768BC0
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_ContestedByBothTeamsChanged
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYCapturePoint::OnRep_ContestedByBothTeamsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_ContestedByBothTeamsChanged");
		
		AYCapturePoint_OnRep_ContestedByBothTeamsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768B60
	 * 		Name   -> Function DreadGame.YCapturePoint.OnRep_ActiveChanged
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYCapturePoint::OnRep_ActiveChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnRep_ActiveChanged");
		
		AYCapturePoint_OnRep_ActiveChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCapturePoint.OnObjectiveTeamsChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYCapturePoint::OnObjectiveTeamsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnObjectiveTeamsChanged");
		
		AYCapturePoint_OnObjectiveTeamsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCapturePoint.OnHealthChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              healthPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::OnHealthChanged(float healthPercent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnHealthChanged");
		
		AYCapturePoint_OnHealthChanged_Params params {};
		params.healthPercent = healthPercent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCapturePoint.OnActiveStatusChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               newStatus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCapturePoint::OnActiveStatusChanged(bool newStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.OnActiveStatusChanged");
		
		AYCapturePoint_OnActiveStatusChanged_Params params {};
		params.newStatus = newStatus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C720
	 * 		Name   -> Function DreadGame.YCapturePoint.HasSpawnPointsForTeam
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYCapturePoint::HasSpawnPointsForTeam(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.HasSpawnPointsForTeam");
		
		AYCapturePoint_HasSpawnPointsForTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759DF0
	 * 		Name   -> Function DreadGame.YCapturePoint.GetTimeToOwn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYCapturePoint::GetTimeToOwn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetTimeToOwn");
		
		AYCapturePoint_GetTimeToOwn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758F10
	 * 		Name   -> Function DreadGame.YCapturePoint.GetSpawnPriority
	 * 		Flags  -> (Final, Native, Public)
	 */
	int32_t AYCapturePoint::GetSpawnPriority()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetSpawnPriority");
		
		AYCapturePoint_GetSpawnPriority_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757B20
	 * 		Name   -> Function DreadGame.YCapturePoint.GetRemainingCaptureTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYCapturePoint::GetRemainingCaptureTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetRemainingCaptureTime");
		
		AYCapturePoint_GetRemainingCaptureTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757060
	 * 		Name   -> Function DreadGame.YCapturePoint.GetPointsPerTickUnderControl
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYCapturePoint::GetPointsPerTickUnderControl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetPointsPerTickUnderControl");
		
		AYCapturePoint_GetPointsPerTickUnderControl_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755AF0
	 * 		Name   -> Function DreadGame.YCapturePoint.GetOwningTeamColorIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYCapturePoint::GetOwningTeamColorIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetOwningTeamColorIndex");
		
		AYCapturePoint_GetOwningTeamColorIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007555A0
	 * 		Name   -> Function DreadGame.YCapturePoint.GetObjectiveTeams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<EYTeam> AYCapturePoint::GetObjectiveTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetObjectiveTeams");
		
		AYCapturePoint_GetObjectiveTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755330
	 * 		Name   -> Function DreadGame.YCapturePoint.GetObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYCapturePointObjective AYCapturePoint::GetObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetObjective");
		
		AYCapturePoint_GetObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755220
	 * 		Name   -> Function DreadGame.YCapturePoint.GetNumberOfPawnsInRange
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYCapturePoint::GetNumberOfPawnsInRange(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetNumberOfPawnsInRange");
		
		AYCapturePoint_GetNumberOfPawnsInRange_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755190
	 * 		Name   -> Function DreadGame.YCapturePoint.GetNextSpawnPoint
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYPlayerStart* AYCapturePoint::GetNextSpawnPoint(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetNextSpawnPoint");
		
		AYCapturePoint_GetNextSpawnPoint_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752C90
	 * 		Name   -> Function DreadGame.YCapturePoint.GetIsContestedByBothTeams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYCapturePoint::GetIsContestedByBothTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetIsContestedByBothTeams");
		
		AYCapturePoint_GetIsContestedByBothTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752C40
	 * 		Name   -> Function DreadGame.YCapturePoint.GetInitialOwningTeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	EYTeam AYCapturePoint::GetInitialOwningTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetInitialOwningTeam");
		
		AYCapturePoint_GetInitialOwningTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752B50
	 * 		Name   -> Function DreadGame.YCapturePoint.GetIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYCapturePoint::GetIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetIndex");
		
		AYCapturePoint_GetIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E690
	 * 		Name   -> Function DreadGame.YCapturePoint.GetCurrentStatus
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool AYCapturePoint::GetCurrentStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetCurrentStatus");
		
		AYCapturePoint_GetCurrentStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750A80
	 * 		Name   -> Function DreadGame.YCapturePoint.GetCurrentOwningTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYTeam AYCapturePoint::GetCurrentOwningTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetCurrentOwningTeam");
		
		AYCapturePoint_GetCurrentOwningTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E550
	 * 		Name   -> Function DreadGame.YCapturePoint.GetCapturingTeamColorIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYCapturePoint::GetCapturingTeamColorIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetCapturingTeamColorIndex");
		
		AYCapturePoint_GetCapturingTeamColorIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E510
	 * 		Name   -> Function DreadGame.YCapturePoint.GetCapturingTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYTeam AYCapturePoint::GetCapturingTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetCapturingTeam");
		
		AYCapturePoint_GetCapturingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E450
	 * 		Name   -> Function DreadGame.YCapturePoint.GetCapturingPawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class AYPawn*> AYCapturePoint::GetCapturingPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetCapturingPawns");
		
		AYCapturePoint_GetCapturingPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DDC0
	 * 		Name   -> Function DreadGame.YCapturePoint.GetBeingCaptured
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYCapturePoint::GetBeingCaptured()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.GetBeingCaptured");
		
		AYCapturePoint_GetBeingCaptured_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A3F0
	 * 		Name   -> Function DreadGame.YCapturePoint.DecreaseCaptureSupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYCapturePoint::DecreaseCaptureSupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.DecreaseCaptureSupply");
		
		AYCapturePoint_DecreaseCaptureSupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749820
	 * 		Name   -> Function DreadGame.YCapturePoint.Deactivate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYCapturePoint::Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.Deactivate");
		
		AYCapturePoint_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCapturePoint.ActorEndOverlapBP
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYCapturePoint::ActorEndOverlapBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.ActorEndOverlapBP");
		
		AYCapturePoint_ActorEndOverlapBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CC40
	 * 		Name   -> Function DreadGame.YCapturePoint.Activate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYCapturePoint::Activate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCapturePoint.Activate");
		
		AYCapturePoint_Activate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCapturePoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCapturePoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCapturePoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCapturePoint_TER.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCapturePoint_TER::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCapturePoint_TER");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawnAIController.QueryShortCommandEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      commander                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUIShortCommands                                  shortCommandId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawnAIController::QueryShortCommandEvent(class AActor* commander, EYUIShortCommands shortCommandId, class AYPawn* targetPawn, int32_t Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawnAIController.QueryShortCommandEvent");
		
		AYPawnAIController_QueryShortCommandEvent_Params params {};
		params.commander = commander;
		params.shortCommandId = shortCommandId;
		params.targetPawn = targetPawn;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPawnAIController.ProcessShortCommandEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      commander                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUIShortCommands                                  shortCommandId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPawnAIController::ProcessShortCommandEvent(class AActor* commander, EYUIShortCommands shortCommandId, class AYPawn* targetPawn, int32_t Priority, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPawnAIController.ProcessShortCommandEvent");
		
		AYPawnAIController_ProcessShortCommandEvent_Params params {};
		params.commander = commander;
		params.shortCommandId = shortCommandId;
		params.targetPawn = targetPawn;
		params.Priority = Priority;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPawnAIController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPawnAIController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPawnAIController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C660
	 * 		Name   -> Function DreadGame.YCreepAIController.ForceJumpOut
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYCreepAIController::ForceJumpOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepAIController.ForceJumpOut");
		
		AYCreepAIController_ForceJumpOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCreepAIController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCreepAIController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCreepAIController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779830
	 * 		Name   -> Function DreadGame.YCreepFactory.SetPatrolCreepSpeedLimit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              speedLimit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCreepFactory::SetPatrolCreepSpeedLimit(float speedLimit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepFactory.SetPatrolCreepSpeedLimit");
		
		AYCreepFactory_SetPatrolCreepSpeedLimit_Params params {};
		params.speedLimit = speedLimit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776770
	 * 		Name   -> Function DreadGame.YCreepFactory.SetCreepMaxSpawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCreepFactory::SetCreepMaxSpawns(int32_t MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepFactory.SetCreepMaxSpawns");
		
		AYCreepFactory_SetCreepMaxSpawns_Params params {};
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775BB0
	 * 		Name   -> Function DreadGame.YCreepFactory.SetAttackCreepSpeedLimit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              speedLimit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCreepFactory::SetAttackCreepSpeedLimit(float speedLimit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepFactory.SetAttackCreepSpeedLimit");
		
		AYCreepFactory_SetAttackCreepSpeedLimit_Params params {};
		params.speedLimit = speedLimit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007707A0
	 * 		Name   -> Function DreadGame.YCreepFactory.SendAttackWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            targetFactory                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCreepFactory::SendAttackWave(int32_t targetFactory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepFactory.SendAttackWave");
		
		AYCreepFactory_SendAttackWave_Params params {};
		params.targetFactory = targetFactory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755D20
	 * 		Name   -> Function DreadGame.YCreepFactory.GetPatrolCreep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYCreepFactory::GetPatrolCreep(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepFactory.GetPatrolCreep");
		
		AYCreepFactory_GetPatrolCreep_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D9A0
	 * 		Name   -> Function DreadGame.YCreepFactory.GetAttackCreep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYCreepFactory::GetAttackCreep(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepFactory.GetAttackCreep");
		
		AYCreepFactory_GetAttackCreep_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCreepFactory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCreepFactory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCreepFactory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterCustomizationMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterCustomizationMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterCustomizationMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterCustomizationMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterCustomizationMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterCustomizationMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BBA0
	 * 		Name   -> Function DreadGame.YCharacterPreset.ExportAppearance
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	class FString UYCharacterPreset::ExportAppearance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterPreset.ExportAppearance");
		
		UYCharacterPreset_ExportAppearance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterPreset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterPreset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterPreset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007809D0
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.SwitchToSceneCapture
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCharacterRenderLevelManager::STATIC_SwitchToSceneCapture(class UWorld* World, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.SwitchToSceneCapture");
		
		UYCharacterRenderLevelManager_SwitchToSceneCapture_Params params {};
		params.World = World;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760500
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.LoadCustomCharacterRenderLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      levelPath                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCharacterRenderLevelManager::STATIC_LoadCustomCharacterRenderLevel(const class FString& levelPath, class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.LoadCustomCharacterRenderLevel");
		
		UYCharacterRenderLevelManager_LoadCustomCharacterRenderLevel_Params params {};
		params.levelPath = levelPath;
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074ECC0
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.GetCharacterRenderLevelScriptActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYLevelScriptActor_CharRenderLevel* UYCharacterRenderLevelManager::STATIC_GetCharacterRenderLevelScriptActor(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.GetCharacterRenderLevelScriptActor");
		
		UYCharacterRenderLevelManager_GetCharacterRenderLevelScriptActor_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EA90
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.GetCharacterByTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYBaseCharacter* UYCharacterRenderLevelManager::STATIC_GetCharacterByTag(class UWorld* World, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.GetCharacterByTag");
		
		UYCharacterRenderLevelManager_GetCharacterByTag_Params params {};
		params.World = World;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E940
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.GetCharacterBySpawnerNoReset
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYCharacterDescription                      characterDescription                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYBaseCharacter* UYCharacterRenderLevelManager::STATIC_GetCharacterBySpawnerNoReset(class UWorld* World, const struct FYCharacterDescription& characterDescription, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.GetCharacterBySpawnerNoReset");
		
		UYCharacterRenderLevelManager_GetCharacterBySpawnerNoReset_Params params {};
		params.World = World;
		params.characterDescription = characterDescription;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E7F0
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.GetCharacterBySpawner
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYCharacterDescription                      characterDescription                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYBaseCharacter* UYCharacterRenderLevelManager::STATIC_GetCharacterBySpawner(class UWorld* World, const struct FYCharacterDescription& characterDescription, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.GetCharacterBySpawner");
		
		UYCharacterRenderLevelManager_GetCharacterBySpawner_Params params {};
		params.World = World;
		params.characterDescription = characterDescription;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CF90
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.GetActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* UYCharacterRenderLevelManager::STATIC_GetActor(class UWorld* World, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.GetActor");
		
		UYCharacterRenderLevelManager_GetActor_Params params {};
		params.World = World;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B410
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.EnableCharacterRenderLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYCharacterRenderLevelType                         Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYCharacterRenderLevelType UYCharacterRenderLevelManager::STATIC_EnableCharacterRenderLevel(class UWorld* World, EYCharacterRenderLevelType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.EnableCharacterRenderLevel");
		
		UYCharacterRenderLevelManager_EnableCharacterRenderLevel_Params params {};
		params.World = World;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A9E0
	 * 		Name   -> Function DreadGame.YCharacterRenderLevelManager.DisableAllSceneCaptures
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCharacterRenderLevelManager::STATIC_DisableAllSceneCaptures(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterRenderLevelManager.DisableAllSceneCaptures");
		
		UYCharacterRenderLevelManager_DisableAllSceneCaptures_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCharacterRenderLevelManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCharacterRenderLevelManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterRenderLevelManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CF70
	 * 		Name   -> Function DreadGame.YInterface_ThumbnailRenderableActor.InitForRendering
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      creatingActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_ThumbnailRenderableActor::InitForRendering(class AActor* creatingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ThumbnailRenderableActor.InitForRendering");
		
		UYInterface_ThumbnailRenderableActor_InitForRendering_Params params {};
		params.creatingActor = creatingActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E420
	 * 		Name   -> Function DreadGame.YInterface_ThumbnailRenderableActor.GetCameraComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UCameraComponent* UYInterface_ThumbnailRenderableActor::GetCameraComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ThumbnailRenderableActor.GetCameraComponent");
		
		UYInterface_ThumbnailRenderableActor_GetCameraComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInterface_ThumbnailRenderableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInterface_ThumbnailRenderableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInterface_ThumbnailRenderableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCharacterSpawner.OnCharacterSpawned
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYBaseCharacter*                             spawnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCharacterSpawner::OnCharacterSpawned(class AYBaseCharacter* spawnedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterSpawner.OnCharacterSpawned");
		
		AYCharacterSpawner_OnCharacterSpawned_Params params {};
		params.spawnedCharacter = spawnedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CEE0
	 * 		Name   -> Function DreadGame.YCharacterSpawner.InitForRendering
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      creatingActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCharacterSpawner::InitForRendering(class AActor* creatingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterSpawner.InitForRendering");
		
		AYCharacterSpawner_InitForRendering_Params params {};
		params.creatingActor = creatingActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C870
	 * 		Name   -> Function DreadGame.YCharacterSpawner.HideCharacters
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               clear                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCharacterSpawner::HideCharacters(bool clear)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterSpawner.HideCharacters");
		
		AYCharacterSpawner_HideCharacters_Params params {};
		params.clear = clear;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E570
	 * 		Name   -> Function DreadGame.YCharacterSpawner.GetCharacter
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYCharacterDescription                      characterDescription                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               forceRefresh                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bInvisibleAfterCreation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               resetExisting                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYBaseCharacter* AYCharacterSpawner::GetCharacter(const struct FYCharacterDescription& characterDescription, bool forceRefresh, bool bInvisibleAfterCreation, bool resetExisting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterSpawner.GetCharacter");
		
		AYCharacterSpawner_GetCharacter_Params params {};
		params.characterDescription = characterDescription;
		params.forceRefresh = forceRefresh;
		params.bInvisibleAfterCreation = bInvisibleAfterCreation;
		params.resetExisting = resetExisting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E0A0
	 * 		Name   -> Function DreadGame.YCharacterSpawner.GetCameraComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UCameraComponent* AYCharacterSpawner::GetCameraComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCharacterSpawner.GetCameraComponent");
		
		AYCharacterSpawner_GetCameraComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCharacterSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCharacterSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCharacterVanityItemPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCharacterVanityItemPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCharacterVanityItemPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C520
	 * 		Name   -> Function DreadGame.YOfficer.HasOnlySubtitlesInComWindow
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYOfficer::HasOnlySubtitlesInComWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.HasOnlySubtitlesInComWindow");
		
		UYOfficer_HasOnlySubtitlesInComWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A050
	 * 		Name   -> Function DreadGame.YOfficer.GetType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYOfficerType UYOfficer::GetType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetType");
		
		UYOfficer_GetType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757790
	 * 		Name   -> Function DreadGame.YOfficer.GetRP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYOfficer::GetRP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetRP");
		
		UYOfficer_GetRP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757860
	 * 		Name   -> Function DreadGame.YOfficer.GetRank
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYOfficer::GetRank()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetRank");
		
		UYOfficer_GetRank_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007569B0
	 * 		Name   -> Function DreadGame.YOfficer.GetPerk
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYPerk* UYOfficer::GetPerk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetPerk");
		
		UYOfficer_GetPerk_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755800
	 * 		Name   -> Function DreadGame.YOfficer.GetOfficerName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UYOfficer::GetOfficerName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetOfficerName");
		
		UYOfficer_GetOfficerName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752100
	 * 		Name   -> Function DreadGame.YOfficer.GetGender
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UYOfficer::GetGender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetGender");
		
		UYOfficer_GetGender_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EDC0
	 * 		Name   -> Function DreadGame.YOfficer.GetCharacterTag
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UYOfficer::GetCharacterTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetCharacterTag");
		
		UYOfficer_GetCharacterTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EC40
	 * 		Name   -> Function DreadGame.YOfficer.GetCharacterName
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UYOfficer::GetCharacterName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetCharacterName");
		
		UYOfficer_GetCharacterName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EB80
	 * 		Name   -> Function DreadGame.YOfficer.GetCharacterImage
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTexture* UYOfficer::GetCharacterImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetCharacterImage");
		
		UYOfficer_GetCharacterImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E780
	 * 		Name   -> Function DreadGame.YOfficer.GetCharacterAppearance
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYCharacterAppearance UYOfficer::GetCharacterAppearance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficer.GetCharacterAppearance");
		
		UYOfficer_GetCharacterAppearance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOfficer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOfficer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOfficer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.VOTriggerByID
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::VOTriggerByID(int32_t Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.VOTriggerByID");
		
		AYCheatManager_VOTriggerByID_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YCheatManager.VOTriggerByEvent
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FName                                        Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::VOTriggerByEvent(const class FName& Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.VOTriggerByEvent");
		
		AYCheatManager_VOTriggerByEvent_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.VOPrintListOfLoadedEvents
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::VOPrintListOfLoadedEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.VOPrintListOfLoadedEvents");
		
		AYCheatManager_VOPrintListOfLoadedEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YCheatManager.UseDebugMmogClientCodeToSwap
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               useIt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::UseDebugMmogClientCodeToSwap(bool useIt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.UseDebugMmogClientCodeToSwap");
		
		AYCheatManager_UseDebugMmogClientCodeToSwap_Params params {};
		params.useIt = useIt;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.ToggleProjectileCloseInRange
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::ToggleProjectileCloseInRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ToggleProjectileCloseInRange");
		
		AYCheatManager_ToggleProjectileCloseInRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.ToggleHitzoneDebug
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::ToggleHitzoneDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ToggleHitzoneDebug");
		
		AYCheatManager_ToggleHitzoneDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.ToggleDebugCamera
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::ToggleDebugCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ToggleDebugCamera");
		
		AYCheatManager_ToggleDebugCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.TestSpecificControlRestrictions
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::TestSpecificControlRestrictions(int32_t idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.TestSpecificControlRestrictions");
		
		AYCheatManager_TestSpecificControlRestrictions_Params params {};
		params.idx = idx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.TestLocalization
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::TestLocalization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.TestLocalization");
		
		AYCheatManager_TestLocalization_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BC60
	 * 		Name   -> Function DreadGame.YCheatManager.TestAnalyticsTutorialEvent
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            stepId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      stepName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::TestAnalyticsTutorialEvent(int32_t stepId, const class FString& stepName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.TestAnalyticsTutorialEvent");
		
		AYCheatManager_TestAnalyticsTutorialEvent_Params params {};
		params.stepId = stepId;
		params.stepName = stepName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.STResetToObjective
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::STResetToObjective(int32_t idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.STResetToObjective");
		
		AYCheatManager_STResetToObjective_Params params {};
		params.idx = idx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.STDumpObjectives
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::STDumpObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.STDumpObjectives");
		
		AYCheatManager_STDumpObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.StartMatchCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::StartMatchCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.StartMatchCustomRoom");
		
		AYCheatManager_StartMatchCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.StartMatchCountdownCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::StartMatchCountdownCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.StartMatchCountdownCustomRoom");
		
		AYCheatManager_StartMatchCountdownCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F6D0
	 * 		Name   -> Function DreadGame.YCheatManager.SquadEnterMatchmaking
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            fleetType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      GameMode                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      mapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SquadEnterMatchmaking(int32_t fleetType, const class FString& GameMode, const class FString& mapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SquadEnterMatchmaking");
		
		AYCheatManager_SquadEnterMatchmaking_Params params {};
		params.fleetType = fleetType;
		params.GameMode = GameMode;
		params.mapName = mapName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E920
	 * 		Name   -> Function DreadGame.YCheatManager.SkipShelteredGames
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::SkipShelteredGames()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SkipShelteredGames");
		
		AYCheatManager_SkipShelteredGames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.SkipRecruitGoals
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::SkipRecruitGoals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SkipRecruitGoals");
		
		AYCheatManager_SkipRecruitGoals_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.SkipProvingGrounds
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::SkipProvingGrounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SkipProvingGrounds");
		
		AYCheatManager_SkipProvingGrounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E800
	 * 		Name   -> Function DreadGame.YCheatManager.SimulateNetworkDisconnect
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		bool                                               turnOn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SimulateNetworkDisconnect(bool turnOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SimulateNetworkDisconnect");
		
		AYCheatManager_SimulateNetworkDisconnect_Params params {};
		params.turnOn = turnOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.ShowPromotionPack
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ShowPromotionPack(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ShowPromotionPack");
		
		AYCheatManager_ShowPromotionPack_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077DBF0
	 * 		Name   -> Function DreadGame.YCheatManager.ShowMultiplePromotionPack
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            itemIDOne                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            itemIDTwo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            itemIDThree                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            itemIDFour                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            itemIDFive                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ShowMultiplePromotionPack(int32_t itemIDOne, int32_t itemIDTwo, int32_t itemIDThree, int32_t itemIDFour, int32_t itemIDFive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ShowMultiplePromotionPack");
		
		AYCheatManager_ShowMultiplePromotionPack_Params params {};
		params.itemIDOne = itemIDOne;
		params.itemIDTwo = itemIDTwo;
		params.itemIDThree = itemIDThree;
		params.itemIDFour = itemIDFour;
		params.itemIDFive = itemIDFive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00BBD7F0
	 * 		Name   -> Function DreadGame.YCheatManager.ShowLoadingScreenData
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            mapIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            gameModeIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ShowLoadingScreenData(bool State, int32_t mapIndex, int32_t gameModeIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ShowLoadingScreenData");
		
		AYCheatManager_ShowLoadingScreenData_Params params {};
		params.State = State;
		params.mapIndex = mapIndex;
		params.gameModeIndex = gameModeIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YCheatManager.ShowLoadingScreen
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ShowLoadingScreen(bool State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ShowLoadingScreen");
		
		AYCheatManager_ShowLoadingScreen_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.SetUpStandardRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::SetUpStandardRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SetUpStandardRoom");
		
		AYCheatManager_SetUpStandardRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.SetSpeakerChannelSetup
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      setupName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SetSpeakerChannelSetup(const class FString& setupName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SetSpeakerChannelSetup");
		
		AYCheatManager_SetSpeakerChannelSetup_Params params {};
		params.setupName = setupName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.SetMyselfAsHost
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::SetMyselfAsHost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SetMyselfAsHost");
		
		AYCheatManager_SetMyselfAsHost_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YCheatManager.SetHost
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        userId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SetHost(const class FName& userId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SetHost");
		
		AYCheatManager_SetHost_Params params {};
		params.userId = userId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YCheatManager.SetDumpStackTraceOnFlushAsyncLoading
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		bool                                               printStackTrace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SetDumpStackTraceOnFlushAsyncLoading(bool printStackTrace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SetDumpStackTraceOnFlushAsyncLoading");
		
		AYCheatManager_SetDumpStackTraceOnFlushAsyncLoading_Params params {};
		params.printStackTrace = printStackTrace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775530
	 * 		Name   -> Function DreadGame.YCheatManager.SetAIFleetType
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		EYFleetType                                        fleetType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SetAIFleetType(EYFleetType fleetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SetAIFleetType");
		
		AYCheatManager_SetAIFleetType_Params params {};
		params.fleetType = fleetType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.SetActiveLoadoutByName
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      loadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SetActiveLoadoutByName(const class FString& loadoutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SetActiveLoadoutByName");
		
		AYCheatManager_SetActiveLoadoutByName_Params params {};
		params.loadoutName = loadoutName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771FB0
	 * 		Name   -> Function DreadGame.YCheatManager.ServerLogBoostersInfo
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPlayerController*                          PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ServerLogBoostersInfo(class AYPlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ServerLogBoostersInfo");
		
		AYCheatManager_ServerLogBoostersInfo_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007719B0
	 * 		Name   -> Function DreadGame.YCheatManager.ServerDebugPVEFinishMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               isWin                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ServerDebugPVEFinishMatch(bool isWin, int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ServerDebugPVEFinishMatch");
		
		AYCheatManager_ServerDebugPVEFinishMatch_Params params {};
		params.isWin = isWin;
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007718F0
	 * 		Name   -> Function DreadGame.YCheatManager.ServerDebugHavocWaveModifierRandomize
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            wave                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ServerDebugHavocWaveModifierRandomize(int32_t wave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ServerDebugHavocWaveModifierRandomize");
		
		AYCheatManager_ServerDebugHavocWaveModifierRandomize_Params params {};
		params.wave = wave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771770
	 * 		Name   -> Function DreadGame.YCheatManager.ServerDebugHavocAddXP
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            xp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ServerDebugHavocAddXP(int32_t xp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ServerDebugHavocAddXP");
		
		AYCheatManager_ServerDebugHavocAddXP_Params params {};
		params.xp = xp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007715A0
	 * 		Name   -> Function DreadGame.YCheatManager.ServerDebugActivateHavocWaveModifier
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        modifierName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ServerDebugActivateHavocWaveModifier(const class FName& modifierName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ServerDebugActivateHavocWaveModifier");
		
		AYCheatManager_ServerDebugActivateHavocWaveModifier_Params params {};
		params.modifierName = modifierName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771170
	 * 		Name   -> Function DreadGame.YCheatManager.ServerActivateBooster
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            boosterID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ServerActivateBooster(int32_t boosterID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ServerActivateBooster");
		
		AYCheatManager_ServerActivateBooster_Params params {};
		params.boosterID = boosterID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007753B0
	 * 		Name   -> Function DreadGame.YCheatManager.Server_SetYPawnInvincible
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPawn*                                      YPawn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               invincible                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::Server_SetYPawnInvincible(class AYPawn* YPawn, bool invincible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.Server_SetYPawnInvincible");
		
		AYCheatManager_Server_SetYPawnInvincible_Params params {};
		params.YPawn = YPawn;
		params.invincible = invincible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007752B0
	 * 		Name   -> Function DreadGame.YCheatManager.Server_SetYPawnForceStayAlive
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPawn*                                      YPawn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               forceStayAlive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::Server_SetYPawnForceStayAlive(class AYPawn* YPawn, bool forceStayAlive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.Server_SetYPawnForceStayAlive");
		
		AYCheatManager_Server_SetYPawnForceStayAlive_Params params {};
		params.YPawn = YPawn;
		params.forceStayAlive = forceStayAlive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007751B0
	 * 		Name   -> Function DreadGame.YCheatManager.Server_SetYPawnCurrentHealthLocked
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPawn*                                      YPawn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               currentHealthLocked                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::Server_SetYPawnCurrentHealthLocked(class AYPawn* YPawn, bool currentHealthLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.Server_SetYPawnCurrentHealthLocked");
		
		AYCheatManager_Server_SetYPawnCurrentHealthLocked_Params params {};
		params.YPawn = YPawn;
		params.currentHealthLocked = currentHealthLocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007750F0
	 * 		Name   -> Function DreadGame.YCheatManager.Server_RunAuthorityConsoleCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::Server_RunAuthorityConsoleCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.Server_RunAuthorityConsoleCommand");
		
		AYCheatManager_Server_RunAuthorityConsoleCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.SendSquadInvite
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      friendId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SendSquadInvite(const class FString& friendId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SendSquadInvite");
		
		AYCheatManager_SendSquadInvite_Params params {};
		params.friendId = friendId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.SendNaNToAudio
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::SendNaNToAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SendNaNToAudio");
		
		AYCheatManager_SendNaNToAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.SendHardwareAnalytics
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::SendHardwareAnalytics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SendHardwareAnalytics");
		
		AYCheatManager_SendHardwareAnalytics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.SendFriendInvite
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      friendId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SendFriendInvite(const class FString& friendId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SendFriendInvite");
		
		AYCheatManager_SendFriendInvite_Params params {};
		params.friendId = friendId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BC60
	 * 		Name   -> Function DreadGame.YCheatManager.SendAnnouncementWithDuration
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            durationInSecs                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SendAnnouncementWithDuration(int32_t durationInSecs, const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SendAnnouncementWithDuration");
		
		AYCheatManager_SendAnnouncementWithDuration_Params params {};
		params.durationInSecs = durationInSecs;
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.SendAnnouncement
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SendAnnouncement(const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SendAnnouncement");
		
		AYCheatManager_SendAnnouncement_Params params {};
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.SearchForFriends
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      searchStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::SearchForFriends(const class FString& searchStr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.SearchForFriends");
		
		AYCheatManager_SearchForFriends_Params params {};
		params.searchStr = searchStr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.RequestCareerProgressionData
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::RequestCareerProgressionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.RequestCareerProgressionData");
		
		AYCheatManager_RequestCareerProgressionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.ReplaceShipWithActiveLoadout
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::ReplaceShipWithActiveLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ReplaceShipWithActiveLoadout");
		
		AYCheatManager_ReplaceShipWithActiveLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YCheatManager.RemoveCustomRoomUser
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        pid                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::RemoveCustomRoomUser(const class FName& pid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.RemoveCustomRoomUser");
		
		AYCheatManager_RemoveCustomRoomUser_Params params {};
		params.pid = pid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.RemoveAllAIFromRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::RemoveAllAIFromRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.RemoveAllAIFromRoom");
		
		AYCheatManager_RemoveAllAIFromRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.LogBoostersInfo
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::LogBoostersInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.LogBoostersInfo");
		
		AYCheatManager_LogBoostersInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.LogBattleReadyFleetsInfo
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::LogBattleReadyFleetsInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.LogBattleReadyFleetsInfo");
		
		AYCheatManager_LogBattleReadyFleetsInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.LeaveCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::LeaveCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.LeaveCustomRoom");
		
		AYCheatManager_LeaveCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749FD0
	 * 		Name   -> Function DreadGame.YCheatManager.IncrementCareerCounterNoSub
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      counterId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            increment                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::IncrementCareerCounterNoSub(const class FString& counterId, int32_t increment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.IncrementCareerCounterNoSub");
		
		AYCheatManager_IncrementCareerCounterNoSub_Params params {};
		params.counterId = counterId;
		params.increment = increment;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CC60
	 * 		Name   -> Function DreadGame.YCheatManager.IncrementCareerCounter
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      counterId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      subId                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            increment                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::IncrementCareerCounter(const class FString& counterId, const class FString& subId, int32_t increment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.IncrementCareerCounter");
		
		AYCheatManager_IncrementCareerCounter_Params params {};
		params.counterId = counterId;
		params.subId = subId;
		params.increment = increment;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.ForceMarketFakeReload
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      campaignToRemove                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ForceMarketFakeReload(const class FString& campaignToRemove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ForceMarketFakeReload");
		
		AYCheatManager_ForceMarketFakeReload_Params params {};
		params.campaignToRemove = campaignToRemove;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.ForceActivateFeat
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      featName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ForceActivateFeat(const class FString& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ForceActivateFeat");
		
		AYCheatManager_ForceActivateFeat_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.FillRoomWithAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::FillRoomWithAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.FillRoomWithAI");
		
		AYCheatManager_FillRoomWithAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.ExitFleetSelectCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::ExitFleetSelectCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ExitFleetSelectCustomRoom");
		
		AYCheatManager_ExitFleetSelectCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.EoMSetDebugStatsDisplay
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      ImportFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::EoMSetDebugStatsDisplay(const class FString& ImportFilePath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.EoMSetDebugStatsDisplay");
		
		AYCheatManager_EoMSetDebugStatsDisplay_Params params {};
		params.ImportFilePath = ImportFilePath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.EoMResetDebugStatsDisplay
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::EoMResetDebugStatsDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.EoMResetDebugStatsDisplay");
		
		AYCheatManager_EoMResetDebugStatsDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.EnterFleetSelectCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::EnterFleetSelectCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.EnterFleetSelectCustomRoom");
		
		AYCheatManager_EnterFleetSelectCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DumpSquadInfo
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DumpSquadInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DumpSquadInfo");
		
		AYCheatManager_DumpSquadInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.DumpMarketData
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      fileName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DumpMarketData(const class FString& fileName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DumpMarketData");
		
		AYCheatManager_DumpMarketData_Params params {};
		params.fileName = fileName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.Disconnect
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::Disconnect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.Disconnect");
		
		AYCheatManager_Disconnect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugShowSimulatedBackendTime
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugShowSimulatedBackendTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugShowSimulatedBackendTime");
		
		AYCheatManager_DebugShowSimulatedBackendTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A210
	 * 		Name   -> Function DreadGame.YCheatManager.DebugSendBusinessAnalyticsEvent
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Category                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      userId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugSendBusinessAnalyticsEvent(const class FString& Name, const class FString& Category, const class FString& userId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugSendBusinessAnalyticsEvent");
		
		AYCheatManager_DebugSendBusinessAnalyticsEvent_Params params {};
		params.Name = Name;
		params.Category = Category;
		params.userId = userId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A0F0
	 * 		Name   -> Function DreadGame.YCheatManager.DebugRenameShipLoadout
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      newName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugRenameShipLoadout(const class FName& loadoutId, const class FString& newName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugRenameShipLoadout");
		
		AYCheatManager_DebugRenameShipLoadout_Params params {};
		params.loadoutId = loadoutId;
		params.newName = newName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749F10
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEFinishMatch
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		bool                                               isWin                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugPVEFinishMatch(bool isWin, int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEFinishMatch");
		
		AYCheatManager_DebugPVEFinishMatch_Params params {};
		params.isWin = isWin;
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749E80
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEClientSetActiveEvent
	 * 		Flags  -> (Final, Exec, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugPVEClientSetActiveEvent(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEClientSetActiveEvent");
		
		AYCheatManager_DebugPVEClientSetActiveEvent_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEClientPrintActiveEventToLog
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugPVEClientPrintActiveEventToLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEClientPrintActiveEventToLog");
		
		AYCheatManager_DebugPVEClientPrintActiveEventToLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749D60
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEBackendSetActiveEvent
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      EventName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            durationMinutes                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            startOffsetMinutes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugPVEBackendSetActiveEvent(const class FString& EventName, int32_t durationMinutes, int32_t startOffsetMinutes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEBackendSetActiveEvent");
		
		AYCheatManager_DebugPVEBackendSetActiveEvent_Params params {};
		params.EventName = EventName;
		params.durationMinutes = durationMinutes;
		params.startOffsetMinutes = startOffsetMinutes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEBackendResetSeasonProgress
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugPVEBackendResetSeasonProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEBackendResetSeasonProgress");
		
		AYCheatManager_DebugPVEBackendResetSeasonProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEBackendReloadSeasonConfig
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugPVEBackendReloadSeasonConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEBackendReloadSeasonConfig");
		
		AYCheatManager_DebugPVEBackendReloadSeasonConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEBackendGrantSeasonReward
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            rewardLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugPVEBackendGrantSeasonReward(int32_t rewardLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEBackendGrantSeasonReward");
		
		AYCheatManager_DebugPVEBackendGrantSeasonReward_Params params {};
		params.rewardLevel = rewardLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749BC0
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPVEBackendGrantEventReward
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            fleetType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            rewardLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugPVEBackendGrantEventReward(int32_t fleetType, int32_t rewardLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPVEBackendGrantEventReward");
		
		AYCheatManager_DebugPVEBackendGrantEventReward_Params params {};
		params.fleetType = fleetType;
		params.rewardLevel = rewardLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749FD0
	 * 		Name   -> Function DreadGame.YCheatManager.DebugPurchaseOffer
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      offerId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugPurchaseOffer(const class FString& offerId, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugPurchaseOffer");
		
		AYCheatManager_DebugPurchaseOffer_Params params {};
		params.offerId = offerId;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomTrySwapTeams
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            teamIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomTrySwapTeams(int32_t teamIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomTrySwapTeams");
		
		AYCheatManager_DebugCustomRoomTrySwapTeams_Params params {};
		params.teamIndex = teamIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomStartMatchCountdown
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            fleetIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomStartMatchCountdown(int32_t fleetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomStartMatchCountdown");
		
		AYCheatManager_DebugCustomRoomStartMatchCountdown_Params params {};
		params.fleetIndex = fleetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomStartMatch
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomStartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomStartMatch");
		
		AYCheatManager_DebugCustomRoomStartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomShowInviteCandidates
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomShowInviteCandidates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomShowInviteCandidates");
		
		AYCheatManager_DebugCustomRoomShowInviteCandidates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomShow
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomShow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomShow");
		
		AYCheatManager_DebugCustomRoomShow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomSetTeamSize
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            teamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomSetTeamSize(int32_t teamSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomSetTeamSize");
		
		AYCheatManager_DebugCustomRoomSetTeamSize_Params params {};
		params.teamSize = teamSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomSetTeam2AiSpawn
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		bool                                               enable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomSetTeam2AiSpawn(bool enable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomSetTeam2AiSpawn");
		
		AYCheatManager_DebugCustomRoomSetTeam2AiSpawn_Params params {};
		params.enable = enable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomSetTeam1AiSpawn
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		bool                                               enable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomSetTeam1AiSpawn(bool enable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomSetTeam1AiSpawn");
		
		AYCheatManager_DebugCustomRoomSetTeam1AiSpawn_Params params {};
		params.enable = enable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomSetMap
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      Map                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomSetMap(const class FString& Map)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomSetMap");
		
		AYCheatManager_DebugCustomRoomSetMap_Params params {};
		params.Map = Map;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomSetGameMode
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      GameMode                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomSetGameMode(const class FString& GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomSetGameMode");
		
		AYCheatManager_DebugCustomRoomSetGameMode_Params params {};
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomSendChatMessage
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomSendChatMessage(const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomSendChatMessage");
		
		AYCheatManager_DebugCustomRoomSendChatMessage_Params params {};
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomListInvites
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomListInvites()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomListInvites");
		
		AYCheatManager_DebugCustomRoomListInvites_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomLeave
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomLeave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomLeave");
		
		AYCheatManager_DebugCustomRoomLeave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749BC0
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomKickPlayer
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            teamIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomKickPlayer(int32_t teamIndex, int32_t SlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomKickPlayer");
		
		AYCheatManager_DebugCustomRoomKickPlayer_Params params {};
		params.teamIndex = teamIndex;
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomJoin
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomJoin(const class FString& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomJoin");
		
		AYCheatManager_DebugCustomRoomJoin_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomInvitePlayer
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      pid                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomInvitePlayer(const class FString& pid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomInvitePlayer");
		
		AYCheatManager_DebugCustomRoomInvitePlayer_Params params {};
		params.pid = pid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749BC0
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomHostSwapPlayers
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            sourceSlotIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            targetSlotIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomHostSwapPlayers(int32_t sourceSlotIndex, int32_t targetSlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomHostSwapPlayers");
		
		AYCheatManager_DebugCustomRoomHostSwapPlayers_Params params {};
		params.sourceSlotIndex = sourceSlotIndex;
		params.targetSlotIndex = targetSlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776670
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomHostChangeTeam
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            sourceTeamIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            targetTeamIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomHostChangeTeam(int32_t SlotIndex, int32_t sourceTeamIndex, int32_t targetTeamIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomHostChangeTeam");
		
		AYCheatManager_DebugCustomRoomHostChangeTeam_Params params {};
		params.SlotIndex = SlotIndex;
		params.sourceTeamIndex = sourceTeamIndex;
		params.targetTeamIndex = targetTeamIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomExitFleetSelect
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomExitFleetSelect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomExitFleetSelect");
		
		AYCheatManager_DebugCustomRoomExitFleetSelect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomEnterFleetSelect
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomEnterFleetSelect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomEnterFleetSelect");
		
		AYCheatManager_DebugCustomRoomEnterFleetSelect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomDeclineInvite
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      roomId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomDeclineInvite(const class FString& roomId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomDeclineInvite");
		
		AYCheatManager_DebugCustomRoomDeclineInvite_Params params {};
		params.roomId = roomId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749A10
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomCreate
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            teamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               team1Ai                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               team2Ai                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      GameMode                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Map                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomCreate(int32_t teamSize, bool team1Ai, bool team2Ai, const class FString& GameMode, const class FString& Map)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomCreate");
		
		AYCheatManager_DebugCustomRoomCreate_Params params {};
		params.teamSize = teamSize;
		params.team1Ai = team1Ai;
		params.team2Ai = team2Ai;
		params.GameMode = GameMode;
		params.Map = Map;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749BC0
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomChangeHost
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            teamIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugCustomRoomChangeHost(int32_t teamIndex, int32_t SlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomChangeHost");
		
		AYCheatManager_DebugCustomRoomChangeHost_Params params {};
		params.teamIndex = teamIndex;
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.DebugCustomRoomCancelMatchCountdown
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::DebugCustomRoomCancelMatchCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugCustomRoomCancelMatchCountdown");
		
		AYCheatManager_DebugCustomRoomCancelMatchCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749BC0
	 * 		Name   -> Function DreadGame.YCheatManager.DebugBuyGP2CreditsPack
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::DebugBuyGP2CreditsPack(int32_t idx, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.DebugBuyGP2CreditsPack");
		
		AYCheatManager_DebugBuyGP2CreditsPack_Params params {};
		params.idx = idx;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.CreateCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::CreateCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.CreateCustomRoom");
		
		AYCheatManager_CreateCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.CrashMe
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      msg                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::CrashMe(const class FString& msg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.CrashMe");
		
		AYCheatManager_CrashMe_Params params {};
		params.msg = msg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.CloseAnnouncement
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::CloseAnnouncement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.CloseAnnouncement");
		
		AYCheatManager_CloseAnnouncement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747270
	 * 		Name   -> Function DreadGame.YCheatManager.ClientShowDebugMessage
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      Color                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            messageCode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ClientShowDebugMessage(const class FString& message, float duration, const struct FColor& Color, int32_t messageCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ClientShowDebugMessage");
		
		AYCheatManager_ClientShowDebugMessage_Params params {};
		params.message = message;
		params.duration = duration;
		params.Color = Color;
		params.messageCode = messageCode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.ClearStats
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::ClearStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ClearStats");
		
		AYCheatManager_ClearStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749FD0
	 * 		Name   -> Function DreadGame.YCheatManager.ClaimCareerGoal
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      goalId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            stage                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ClaimCareerGoal(const class FString& goalId, int32_t stage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ClaimCareerGoal");
		
		AYCheatManager_ClaimCareerGoal_Params params {};
		params.goalId = goalId;
		params.stage = stage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.CancelMatchCountdownCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::CancelMatchCountdownCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.CancelMatchCountdownCustomRoom");
		
		AYCheatManager_CancelMatchCountdownCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.BugReportTest
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::BugReportTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.BugReportTest");
		
		AYCheatManager_BugReportTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.BatchExecuteConsoleCommands
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      FilePath                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::BatchExecuteConsoleCommands(const class FString& FilePath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.BatchExecuteConsoleCommands");
		
		AYCheatManager_BatchExecuteConsoleCommands_Params params {};
		params.FilePath = FilePath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YCheatManager.AuthConsole
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::AuthConsole(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AuthConsole");
		
		AYCheatManager_AuthConsole_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.AddMyselfToCustomRoom
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYCheatManager::AddMyselfToCustomRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AddMyselfToCustomRoom");
		
		AYCheatManager_AddMyselfToCustomRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749BC0
	 * 		Name   -> Function DreadGame.YCheatManager.AddCustomRoomUsers
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            numOfPlayers                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            highestFleet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::AddCustomRoomUsers(int32_t numOfPlayers, int32_t highestFleet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AddCustomRoomUsers");
		
		AYCheatManager_AddCustomRoomUsers_Params params {};
		params.numOfPlayers = numOfPlayers;
		params.highestFleet = highestFleet;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E8C0
	 * 		Name   -> Function DreadGame.YCheatManager.AddCustomRoomUser
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        userId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            highestFleet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::AddCustomRoomUser(const class FName& userId, int32_t highestFleet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AddCustomRoomUser");
		
		AYCheatManager_AddCustomRoomUser_Params params {};
		params.userId = userId;
		params.highestFleet = highestFleet;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YCheatManager.ActivateBooster
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            boosterID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::ActivateBooster(int32_t boosterID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.ActivateBooster");
		
		AYCheatManager_ActivateBooster_Params params {};
		params.boosterID = boosterID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.AccountUnlockTechTree
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::AccountUnlockTechTree()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AccountUnlockTechTree");
		
		AYCheatManager_AccountUnlockTechTree_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.AcceptSquadInvite
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      friendId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::AcceptSquadInvite(const class FString& friendId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AcceptSquadInvite");
		
		AYCheatManager_AcceptSquadInvite_Params params {};
		params.friendId = friendId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YCheatManager.AcceptFriendInvite
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      friendId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCheatManager::AcceptFriendInvite(const class FString& friendId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AcceptFriendInvite");
		
		AYCheatManager_AcceptFriendInvite_Params params {};
		params.friendId = friendId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YCheatManager.AcceptAllPendingFriendInvites
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYCheatManager::AcceptAllPendingFriendInvites()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCheatManager.AcceptAllPendingFriendInvites");
		
		AYCheatManager_AcceptAllPendingFriendInvites_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCheatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCheatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCheatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781680
	 * 		Name   -> Function DreadGame.YMPCheatManager.ToggleTerritoryLinking
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              linkRangeMulti                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              linkExponent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ToggleTerritoryLinking(float linkRangeMulti, float linkExponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ToggleTerritoryLinking");
		
		AYMPCheatManager_ToggleTerritoryLinking_Params params {};
		params.linkRangeMulti = linkRangeMulti;
		params.linkExponent = linkExponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ToggleTerritoryDebugServer
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ToggleTerritoryDebugServer(int32_t mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ToggleTerritoryDebugServer");
		
		AYMPCheatManager_ToggleTerritoryDebugServer_Params params {};
		params.mode = mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.TogglePVEOrbitTimer
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::TogglePVEOrbitTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.TogglePVEOrbitTimer");
		
		AYMPCheatManager_TogglePVEOrbitTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.TogglePVEDifficulty
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::TogglePVEDifficulty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.TogglePVEDifficulty");
		
		AYMPCheatManager_TogglePVEDifficulty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ToggleOutpostTransitionsInfo
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ToggleOutpostTransitionsInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ToggleOutpostTransitionsInfo");
		
		AYMPCheatManager_ToggleOutpostTransitionsInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ToggleForceHeroCombat
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::ToggleForceHeroCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ToggleForceHeroCombat");
		
		AYMPCheatManager_ToggleForceHeroCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ToggleEnableEndOfRound
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ToggleEnableEndOfRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ToggleEnableEndOfRound");
		
		AYMPCheatManager_ToggleEnableEndOfRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007812B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ToggleDebugSpawnAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::ToggleDebugSpawnAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ToggleDebugSpawnAI");
		
		AYMPCheatManager_ToggleDebugSpawnAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ToggleDebugger
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ToggleDebugger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ToggleDebugger");
		
		AYMPCheatManager_ToggleDebugger_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.TestCustomAnalyticsEvent
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::TestCustomAnalyticsEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.TestCustomAnalyticsEvent");
		
		AYMPCheatManager_TestCustomAnalyticsEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.StartHordeWave
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::StartHordeWave(int32_t waveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.StartHordeWave");
		
		AYMPCheatManager_StartHordeWave_Params params {};
		params.waveIndex = waveIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FAB0
	 * 		Name   -> Function DreadGame.YMPCheatManager.StartDebugCombat
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            teamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYMPCheatManager::StartDebugCombat(int32_t teamSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.StartDebugCombat");
		
		AYMPCheatManager_StartDebugCombat_Params params {};
		params.teamSize = teamSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.StartCreeps
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::StartCreeps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.StartCreeps");
		
		AYMPCheatManager_StartCreeps_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.StartCombat
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::StartCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.StartCombat");
		
		AYMPCheatManager_StartCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.SpawnGuideCreeps
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::SpawnGuideCreeps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SpawnGuideCreeps");
		
		AYMPCheatManager_SpawnGuideCreeps_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077EA50
	 * 		Name   -> Function DreadGame.YMPCheatManager.SpawnAITeams
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            team1Size                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            team2Size                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYMPCheatManager::SpawnAITeams(int32_t team1Size, int32_t team2Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SpawnAITeams");
		
		AYMPCheatManager_SpawnAITeams_Params params {};
		params.team1Size = team1Size;
		params.team2Size = team2Size;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E9C0
	 * 		Name   -> Function DreadGame.YMPCheatManager.SpawnAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            teamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYMPCheatManager::SpawnAI(int32_t teamSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SpawnAI");
		
		AYMPCheatManager_SpawnAI_Params params {};
		params.teamSize = teamSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E680
	 * 		Name   -> Function DreadGame.YMPCheatManager.Simulate5VS5Match
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            team1_NumPlayers                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            team1_SkillSeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            team2_NumPlayers                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            team2_SkillSeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int8_t                                             winner_1_OR_3                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::Simulate5VS5Match(int32_t team1_NumPlayers, int32_t team1_SkillSeed, int32_t team2_NumPlayers, int32_t team2_SkillSeed, int8_t winner_1_OR_3)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.Simulate5VS5Match");
		
		AYMPCheatManager_Simulate5VS5Match_Params params {};
		params.team1_NumPlayers = team1_NumPlayers;
		params.team1_SkillSeed = team1_SkillSeed;
		params.team2_NumPlayers = team2_NumPlayers;
		params.team2_SkillSeed = team2_SkillSeed;
		params.winner_1_OR_3 = winner_1_OR_3;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E4F0
	 * 		Name   -> Function DreadGame.YMPCheatManager.Simulate1VS1Match
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              player1Team1_SKILL                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              player1Team1_DEVIATION                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              player2Team2_SKILL                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              player2Team2_DEVIATION                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int8_t                                             winner_1_OR_3                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::Simulate1VS1Match(float player1Team1_SKILL, float player1Team1_DEVIATION, float player2Team2_SKILL, float player2Team2_DEVIATION, int8_t winner_1_OR_3)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.Simulate1VS1Match");
		
		AYMPCheatManager_Simulate1VS1Match_Params params {};
		params.player1Team1_SKILL = player1Team1_SKILL;
		params.player1Team1_DEVIATION = player1Team1_DEVIATION;
		params.player2Team2_SKILL = player2Team2_SKILL;
		params.player2Team2_DEVIATION = player2Team2_DEVIATION;
		params.winner_1_OR_3 = winner_1_OR_3;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowTeamRatingUpdate
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ShowTeamRatingUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowTeamRatingUpdate");
		
		AYMPCheatManager_ShowTeamRatingUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowTeamRatings
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ShowTeamRatings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowTeamRatings");
		
		AYMPCheatManager_ShowTeamRatings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E3A0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowTargetDebugAI
	 * 		Flags  -> (Final, Exec, Native, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     viewPos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     viewDir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYMPCheatManager::ShowTargetDebugAI(const struct FVector& viewPos, const struct FVector& viewDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowTargetDebugAI");
		
		AYMPCheatManager_ShowTargetDebugAI_Params params {};
		params.viewPos = viewPos;
		params.viewDir = viewDir;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FAB0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowNPCDebugAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYMPCheatManager::ShowNPCDebugAI(int32_t Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowNPCDebugAI");
		
		AYMPCheatManager_ShowNPCDebugAI_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowMissileMarkers
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ShowMissileMarkers(int32_t option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowMissileMarkers");
		
		AYMPCheatManager_ShowMissileMarkers_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowMinimapMarkers
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ShowMinimapMarkers(int32_t option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowMinimapMarkers");
		
		AYMPCheatManager_ShowMinimapMarkers_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowMaxMarkers
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ShowMaxMarkers(int32_t option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowMaxMarkers");
		
		AYMPCheatManager_ShowMaxMarkers_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowEOMInfo
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ShowEOMInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowEOMInfo");
		
		AYMPCheatManager_ShowEOMInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D470
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowDebugAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      aiName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               only                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYMPCheatManager::ShowDebugAI(const class FString& aiName, bool only)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowDebugAI");
		
		AYMPCheatManager_ShowDebugAI_Params params {};
		params.aiName = aiName;
		params.only = only;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D2E0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowAllDebugTurret
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               Show                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYMPCheatManager::ShowAllDebugTurret(bool Show)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowAllDebugTurret");
		
		AYMPCheatManager_ShowAllDebugTurret_Params params {};
		params.Show = Show;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ShowAllDebugAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::ShowAllDebugAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ShowAllDebugAI");
		
		AYMPCheatManager_ShowAllDebugAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007851A0
	 * 		Name   -> Function DreadGame.YMPCheatManager.setVelSpring
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strenght                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::setVelSpring(float Min, float Max, float strenght)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.setVelSpring");
		
		AYMPCheatManager_setVelSpring_Params params {};
		params.Min = Min;
		params.Max = Max;
		params.strenght = strenght;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BC60
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetTeamName
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      newName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetTeamName(int32_t Team, const class FString& newName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetTeamName");
		
		AYMPCheatManager_SetTeamName_Params params {};
		params.Team = Team;
		params.newName = newName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetTargetVolMult
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              newMult                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetTargetVolMult(float newMult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetTargetVolMult");
		
		AYMPCheatManager_SetTargetVolMult_Params params {};
		params.newMult = newMult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784FC0
	 * 		Name   -> Function DreadGame.YMPCheatManager.setSpring
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              snap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strenght                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              dump                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::setSpring(float snap, float Min, float Max, float maxDistance, float strenght, float dump)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.setSpring");
		
		AYMPCheatManager_setSpring_Params params {};
		params.snap = snap;
		params.Min = Min;
		params.Max = Max;
		params.maxDistance = maxDistance;
		params.strenght = strenght;
		params.dump = dump;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AE00
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetShipIndexMegaDamage
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               hasMegaDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetShipIndexMegaDamage(int32_t index, bool hasMegaDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetShipIndexMegaDamage");
		
		AYMPCheatManager_SetShipIndexMegaDamage_Params params {};
		params.index = index;
		params.hasMegaDamage = hasMegaDamage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AE00
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetShipIndexInvincible
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isInvincible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetShipIndexInvincible(int32_t index, bool isInvincible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetShipIndexInvincible");
		
		AYMPCheatManager_SetShipIndexInvincible_Params params {};
		params.index = index;
		params.isInvincible = isInvincible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AE00
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetShipIndexForceStayAlive
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isPreventDeath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetShipIndexForceStayAlive(int32_t index, bool isPreventDeath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetShipIndexForceStayAlive");
		
		AYMPCheatManager_SetShipIndexForceStayAlive_Params params {};
		params.index = index;
		params.isPreventDeath = isPreventDeath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AE00
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetShipIndexCurrentHealthLocked
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isPreventHealthChange                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetShipIndexCurrentHealthLocked(int32_t index, bool isPreventHealthChange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetShipIndexCurrentHealthLocked");
		
		AYMPCheatManager_SetShipIndexCurrentHealthLocked_Params params {};
		params.index = index;
		params.isPreventHealthChange = isPreventHealthChange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetRemainingRoundTime
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetRemainingRoundTime(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetRemainingRoundTime");
		
		AYMPCheatManager_SetRemainingRoundTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749BC0
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetCreepManagerTrail
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            maxTrails                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxLodedTrails                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetCreepManagerTrail(int32_t maxTrails, int32_t maxLodedTrails)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetCreepManagerTrail");
		
		AYMPCheatManager_SetCreepManagerTrail_Params params {};
		params.maxTrails = maxTrails;
		params.maxLodedTrails = maxLodedTrails;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776670
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetCreepManagerTick
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            tickLODs                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxInstancesPerTickLOD                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            outOfSightTickLOD                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetCreepManagerTick(int32_t tickLODs, int32_t maxInstancesPerTickLOD, int32_t outOfSightTickLOD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetCreepManagerTick");
		
		AYMPCheatManager_SetCreepManagerTick_Params params {};
		params.tickLODs = tickLODs;
		params.maxInstancesPerTickLOD = maxInstancesPerTickLOD;
		params.outOfSightTickLOD = outOfSightTickLOD;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776670
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetCreepManagerRender
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            maxRenderDist                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxRenderDist_fromPawnNumber                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxPawnsRenderedTotal                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetCreepManagerRender(int32_t maxRenderDist, int32_t maxRenderDist_fromPawnNumber, int32_t maxPawnsRenderedTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetCreepManagerRender");
		
		AYMPCheatManager_SetCreepManagerRender_Params params {};
		params.maxRenderDist = maxRenderDist;
		params.maxRenderDist_fromPawnNumber = maxRenderDist_fromPawnNumber;
		params.maxPawnsRenderedTotal = maxPawnsRenderedTotal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetCreepManagerQuality
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetCreepManagerQuality(int32_t quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetCreepManagerQuality");
		
		AYMPCheatManager_SetCreepManagerQuality_Params params {};
		params.quality = quality;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetCreepManagerMaxCreeps
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            MaxCount                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetCreepManagerMaxCreeps(int32_t MaxCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetCreepManagerMaxCreeps");
		
		AYMPCheatManager_SetCreepManagerMaxCreeps_Params params {};
		params.MaxCount = MaxCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetCreepManagerFlock
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            maxClientFlock                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::SetCreepManagerFlock(int32_t maxClientFlock)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetCreepManagerFlock");
		
		AYMPCheatManager_SetCreepManagerFlock_Params params {};
		params.maxClientFlock = maxClientFlock;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.SetCreepManagerEnabled
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::SetCreepManagerEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.SetCreepManagerEnabled");
		
		AYMPCheatManager_SetCreepManagerEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774A40
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerToggleTerritoryLinking
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              linkRangeMulti                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              linkExponent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerToggleTerritoryLinking(float linkRangeMulti, float linkExponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerToggleTerritoryLinking");
		
		AYMPCheatManager_ServerToggleTerritoryLinking_Params params {};
		params.linkRangeMulti = linkRangeMulti;
		params.linkExponent = linkExponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774950
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerTogglePVEOrbitTimer
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerTogglePVEOrbitTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerTogglePVEOrbitTimer");
		
		AYMPCheatManager_ServerTogglePVEOrbitTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774900
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerTogglePVEDifficulty
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerTogglePVEDifficulty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerTogglePVEDifficulty");
		
		AYMPCheatManager_ServerTogglePVEDifficulty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007748B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerToggleForceHeroCombat
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerToggleForceHeroCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerToggleForceHeroCombat");
		
		AYMPCheatManager_ServerToggleForceHeroCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774860
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerToggleEnableEndOfRound
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerToggleEnableEndOfRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerToggleEnableEndOfRound");
		
		AYMPCheatManager_ServerToggleEnableEndOfRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007747A0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerTestCustomAnalyticsEvent
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPlayerController*                          PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerTestCustomAnalyticsEvent(class AYPlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerTestCustomAnalyticsEvent");
		
		AYMPCheatManager_ServerTestCustomAnalyticsEvent_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007743C0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerStartHordeWave
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerStartHordeWave(int32_t waveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerStartHordeWave");
		
		AYMPCheatManager_ServerStartHordeWave_Params params {};
		params.waveIndex = waveIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774150
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerStartDebugCombat
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            teamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerStartDebugCombat(int32_t teamSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerStartDebugCombat");
		
		AYMPCheatManager_ServerStartDebugCombat_Params params {};
		params.teamSize = teamSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774100
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerStartCreepManager
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerStartCreepManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerStartCreepManager");
		
		AYMPCheatManager_ServerStartCreepManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007740B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerStartCombatManager
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerStartCombatManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerStartCombatManager");
		
		AYMPCheatManager_ServerStartCombatManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773F20
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerSpawnGuideCreeps
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerSpawnGuideCreeps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerSpawnGuideCreeps");
		
		AYMPCheatManager_ServerSpawnGuideCreeps_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773D70
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerSimulate5VS5Match
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            player1Team1_SKILL                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            player1Team1_DEVIATION                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            player2Team2_SKILL                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            player2Team2_DEVIATION                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int8_t                                             winner_1_OR_3                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerSimulate5VS5Match(int32_t player1Team1_SKILL, int32_t player1Team1_DEVIATION, int32_t player2Team2_SKILL, int32_t player2Team2_DEVIATION, int8_t winner_1_OR_3)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerSimulate5VS5Match");
		
		AYMPCheatManager_ServerSimulate5VS5Match_Params params {};
		params.player1Team1_SKILL = player1Team1_SKILL;
		params.player1Team1_DEVIATION = player1Team1_DEVIATION;
		params.player2Team2_SKILL = player2Team2_SKILL;
		params.player2Team2_DEVIATION = player2Team2_DEVIATION;
		params.winner_1_OR_3 = winner_1_OR_3;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773BA0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerSimulate1VS1Match
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              player1Team1_SKILL                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              player1Team1_DEVIATION                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              player2Team2_SKILL                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              player2Team2_DEVIATION                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int8_t                                             winner_1_OR_3                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerSimulate1VS1Match(float player1Team1_SKILL, float player1Team1_DEVIATION, float player2Team2_SKILL, float player2Team2_DEVIATION, int8_t winner_1_OR_3)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerSimulate1VS1Match");
		
		AYMPCheatManager_ServerSimulate1VS1Match_Params params {};
		params.player1Team1_SKILL = player1Team1_SKILL;
		params.player1Team1_DEVIATION = player1Team1_DEVIATION;
		params.player2Team2_SKILL = player2Team2_SKILL;
		params.player2Team2_DEVIATION = player2Team2_DEVIATION;
		params.winner_1_OR_3 = winner_1_OR_3;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773B50
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerShowTeamRatings
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerShowTeamRatings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerShowTeamRatings");
		
		AYMPCheatManager_ServerShowTeamRatings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773960
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerShowEOMInfo
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPlayerController*                          PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerShowEOMInfo(class AYPlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerShowEOMInfo");
		
		AYMPCheatManager_ServerShowEOMInfo_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773660
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerSetRemainingRoundTime
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerSetRemainingRoundTime(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerSetRemainingRoundTime");
		
		AYMPCheatManager_ServerSetRemainingRoundTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772F00
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerScoreOtherTeam
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPlayerController*                          PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerScoreOtherTeam(class AYPlayerController* PC, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerScoreOtherTeam");
		
		AYMPCheatManager_ServerScoreOtherTeam_Params params {};
		params.PC = PC;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772E00
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerScoreMyTeam
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class AYPlayerController*                          PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerScoreMyTeam(class AYPlayerController* PC, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerScoreMyTeam");
		
		AYMPCheatManager_ServerScoreMyTeam_Params params {};
		params.PC = PC;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772D50
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerScoreMe
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerScoreMe(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerScoreMe");
		
		AYMPCheatManager_ServerScoreMe_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772C90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerScoreEvent
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            eventID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerScoreEvent(int32_t eventID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerScoreEvent");
		
		AYMPCheatManager_ServerScoreEvent_Params params {};
		params.eventID = eventID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772B90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerScoreAchievement
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              achievementReputation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               playerAchievement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerScoreAchievement(float achievementReputation, bool playerAchievement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerScoreAchievement");
		
		AYMPCheatManager_ServerScoreAchievement_Params params {};
		params.achievementReputation = achievementReputation;
		params.playerAchievement = playerAchievement;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772540
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerPrintPlayerStateInfo
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerPrintPlayerStateInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerPrintPlayerStateInfo");
		
		AYMPCheatManager_ServerPrintPlayerStateInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772160
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerLogUpdateComponentTransforms
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerLogUpdateComponentTransforms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerLogUpdateComponentTransforms");
		
		AYMPCheatManager_ServerLogUpdateComponentTransforms_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007720C0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerLogContractsInfo
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerLogContractsInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerLogContractsInfo");
		
		AYMPCheatManager_ServerLogContractsInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772070
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerLogContractsData
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerLogContractsData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerLogContractsData");
		
		AYMPCheatManager_ServerLogContractsData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771F60
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerKillMe
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerKillMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerKillMe");
		
		AYMPCheatManager_ServerKillMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771F10
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerKillAllEnemiesInPVE
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerKillAllEnemiesInPVE()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerKillAllEnemiesInPVE");
		
		AYMPCheatManager_ServerKillAllEnemiesInPVE_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771D20
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerHealMe
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerHealMe(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerHealMe");
		
		AYMPCheatManager_ServerHealMe_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771CD0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerGetCreepCPU
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerGetCreepCPU()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerGetCreepCPU");
		
		AYMPCheatManager_ServerGetCreepCPU_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771C80
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerForceFleetsMaintenance
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerForceFleetsMaintenance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerForceFleetsMaintenance");
		
		AYMPCheatManager_ServerForceFleetsMaintenance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771830
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerDebugHavocJumpToWave
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            wave                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerDebugHavocJumpToWave(int32_t wave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerDebugHavocJumpToWave");
		
		AYMPCheatManager_ServerDebugHavocJumpToWave_Params params {};
		params.wave = wave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771720
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerDebugGetRoomFleets
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYMPCheatManager::ServerDebugGetRoomFleets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerDebugGetRoomFleets");
		
		AYMPCheatManager_ServerDebugGetRoomFleets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771660
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerDebugCompleteContracts
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            numContracts                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerDebugCompleteContracts(int32_t numContracts)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerDebugCompleteContracts");
		
		AYMPCheatManager_ServerDebugCompleteContracts_Params params {};
		params.numContracts = numContracts;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007714F0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerDamageMe
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerDamageMe(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerDamageMe");
		
		AYMPCheatManager_ServerDamageMe_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771340
	 * 		Name   -> Function DreadGame.YMPCheatManager.ServerBroadcastCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ServerBroadcastCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ServerBroadcastCommand");
		
		AYMPCheatManager_ServerBroadcastCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ScoreOtherTeam
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ScoreOtherTeam(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ScoreOtherTeam");
		
		AYMPCheatManager_ScoreOtherTeam_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ScoreMyTeam
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ScoreMyTeam(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ScoreMyTeam");
		
		AYMPCheatManager_ScoreMyTeam_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YMPCheatManager.ScoreMe
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ScoreMe(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ScoreMe");
		
		AYMPCheatManager_ScoreMe_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770410
	 * 		Name   -> Function DreadGame.YMPCheatManager.ScoreEventsMultiple
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            numEvents                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            randSeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ScoreEventsMultiple(int32_t numEvents, int32_t randSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ScoreEventsMultiple");
		
		AYMPCheatManager_ScoreEventsMultiple_Params params {};
		params.numEvents = numEvents;
		params.randSeed = randSeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ScoreEventHelp
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ScoreEventHelp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ScoreEventHelp");
		
		AYMPCheatManager_ScoreEventHelp_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.ScoreEvent
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            eventID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ScoreEvent(int32_t eventID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ScoreEvent");
		
		AYMPCheatManager_ScoreEvent_Params params {};
		params.eventID = eventID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770290
	 * 		Name   -> Function DreadGame.YMPCheatManager.ScoreAchievement
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              achievementReputation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               playerAchievement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ScoreAchievement(float achievementReputation, bool playerAchievement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ScoreAchievement");
		
		AYMPCheatManager_ScoreAchievement_Params params {};
		params.achievementReputation = achievementReputation;
		params.playerAchievement = playerAchievement;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ProfileHUD
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ProfileHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ProfileHUD");
		
		AYMPCheatManager_ProfileHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DF30
	 * 		Name   -> Function DreadGame.YMPCheatManager.PrintPlayerStateInfo
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::PrintPlayerStateInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.PrintPlayerStateInfo");
		
		AYMPCheatManager_PrintPlayerStateInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.LogUpdateComponentTransforms
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::LogUpdateComponentTransforms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.LogUpdateComponentTransforms");
		
		AYMPCheatManager_LogUpdateComponentTransforms_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.LogScoringAchievements
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::LogScoringAchievements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.LogScoringAchievements");
		
		AYMPCheatManager_LogScoringAchievements_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.LogPersistentScoringAchievements
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::LogPersistentScoringAchievements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.LogPersistentScoringAchievements");
		
		AYMPCheatManager_LogPersistentScoringAchievements_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760990
	 * 		Name   -> Function DreadGame.YMPCheatManager.LogMatchXPInfo
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::LogMatchXPInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.LogMatchXPInfo");
		
		AYMPCheatManager_LogMatchXPInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.LogMatchCreditsInfo
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::LogMatchCreditsInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.LogMatchCreditsInfo");
		
		AYMPCheatManager_LogMatchCreditsInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.LogContractsInfo
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::LogContractsInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.LogContractsInfo");
		
		AYMPCheatManager_LogContractsInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.LogContractsData
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::LogContractsData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.LogContractsData");
		
		AYMPCheatManager_LogContractsData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007600E0
	 * 		Name   -> Function DreadGame.YMPCheatManager.KillPawn
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::KillPawn(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.KillPawn");
		
		AYMPCheatManager_KillPawn_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.KillOther
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::KillOther(int32_t Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.KillOther");
		
		AYMPCheatManager_KillOther_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.KillMe
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::KillMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.KillMe");
		
		AYMPCheatManager_KillMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.KillAllEnemiesInPVE
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::KillAllEnemiesInPVE()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.KillAllEnemiesInPVE");
		
		AYMPCheatManager_KillAllEnemiesInPVE_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YMPCheatManager.HealMe
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::HealMe(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.HealMe");
		
		AYMPCheatManager_HealMe_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.GetSpawnNearActors
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYMPCheatManager::GetSpawnNearActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.GetSpawnNearActors");
		
		AYMPCheatManager_GetSpawnNearActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756DE0
	 * 		Name   -> Function DreadGame.YMPCheatManager.GetPlayerShipByIndex
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYMPCheatManager::GetPlayerShipByIndex(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.GetPlayerShipByIndex");
		
		AYMPCheatManager_GetPlayerShipByIndex_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756A90
	 * 		Name   -> Function DreadGame.YMPCheatManager.GetPlayerControllerByIndex
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerController* AYMPCheatManager::GetPlayerControllerByIndex(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.GetPlayerControllerByIndex");
		
		AYMPCheatManager_GetPlayerControllerByIndex_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.ForceFleetsMaintenance
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::ForceFleetsMaintenance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ForceFleetsMaintenance");
		
		AYMPCheatManager_ForceFleetsMaintenance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.EoMResetMatchStatsOverride
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::EoMResetMatchStatsOverride()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.EoMResetMatchStatsOverride");
		
		AYMPCheatManager_EoMResetMatchStatsOverride_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YMPCheatManager.EoMOverrideMatchStats
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		class FString                                      Path                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::EoMOverrideMatchStats(const class FString& Path)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.EoMOverrideMatchStats");
		
		AYMPCheatManager_EoMOverrideMatchStats_Params params {};
		params.Path = Path;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugRenderUpdateOverlaps
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::DebugRenderUpdateOverlaps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugRenderUpdateOverlaps");
		
		AYMPCheatManager_DebugRenderUpdateOverlaps_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugOverlapMulti
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::DebugOverlapMulti()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugOverlapMulti");
		
		AYMPCheatManager_DebugOverlapMulti_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugMousePosition
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYMPCheatManager::DebugMousePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugMousePosition");
		
		AYMPCheatManager_DebugMousePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugHavocJumpToWave
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            wave                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::DebugHavocJumpToWave(int32_t wave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugHavocJumpToWave");
		
		AYMPCheatManager_DebugHavocJumpToWave_Params params {};
		params.wave = wave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugGetRoomFleets
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AYMPCheatManager::DebugGetRoomFleets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugGetRoomFleets");
		
		AYMPCheatManager_DebugGetRoomFleets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugCompleteContracts
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            numContracts                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::DebugCompleteContracts(int32_t numContracts)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugCompleteContracts");
		
		AYMPCheatManager_DebugCompleteContracts_Params params {};
		params.numContracts = numContracts;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugBotAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::DebugBotAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugBotAI");
		
		AYMPCheatManager_DebugBotAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F8B0
	 * 		Name   -> Function DreadGame.YMPCheatManager.DebugAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	bool AYMPCheatManager::DebugAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DebugAI");
		
		AYMPCheatManager_DebugAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YMPCheatManager.DamageMe
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::DamageMe(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.DamageMe");
		
		AYMPCheatManager_DamageMe_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMPCheatManager.CreepLogPhys
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYMPCheatManager::CreepLogPhys()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.CreepLogPhys");
		
		AYMPCheatManager_CreepLogPhys_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744990
	 * 		Name   -> Function DreadGame.YMPCheatManager.CliShowAIDebugInfo
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		class FString                                      debugStr                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     strLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<struct FVector>                             nextWaypoints                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::CliShowAIDebugInfo(const class FString& debugStr, const struct FVector& strLocation, TArray<struct FVector> nextWaypoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.CliShowAIDebugInfo");
		
		AYMPCheatManager_CliShowAIDebugInfo_Params params {};
		params.debugStr = debugStr;
		params.strLocation = strLocation;
		params.nextWaypoints = nextWaypoints;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007468C0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ClientSetCreepCPU
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Total                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Perception                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              serverFPS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ClientSetCreepCPU(int32_t Count, float Total, float Perception, float serverFPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ClientSetCreepCPU");
		
		AYMPCheatManager_ClientSetCreepCPU_Params params {};
		params.Count = Count;
		params.Total = Total;
		params.Perception = Perception;
		params.serverFPS = serverFPS;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007452D0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ClientExecuteCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ClientExecuteCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ClientExecuteCommand");
		
		AYMPCheatManager_ClientExecuteCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744F20
	 * 		Name   -> Function DreadGame.YMPCheatManager.ClientDrawnDebugString
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		class FString                                      debugStr                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     strLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      Color                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ClientDrawnDebugString(const class FString& debugStr, const struct FVector& strLocation, const struct FColor& Color, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ClientDrawnDebugString");
		
		AYMPCheatManager_ClientDrawnDebugString_Params params {};
		params.debugStr = debugStr;
		params.strLocation = strLocation;
		params.Color = Color;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744DC0
	 * 		Name   -> Function DreadGame.YMPCheatManager.ClientDrawnDebugBox
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     boxLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     BoxSize                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      Color                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::ClientDrawnDebugBox(const struct FVector& boxLocation, const struct FVector& BoxSize, const struct FColor& Color, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.ClientDrawnDebugBox");
		
		AYMPCheatManager_ClientDrawnDebugBox_Params params {};
		params.boxLocation = boxLocation;
		params.BoxSize = BoxSize;
		params.Color = Color;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742720
	 * 		Name   -> Function DreadGame.YMPCheatManager.BroadcastStringMulticast
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        String                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::BroadcastStringMulticast(const class FName& String, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.BroadcastStringMulticast");
		
		AYMPCheatManager_BroadcastStringMulticast_Params params {};
		params.String = String;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YMPCheatManager.BroadcastCommand
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMPCheatManager::BroadcastCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPCheatManager.BroadcastCommand");
		
		AYMPCheatManager_BroadcastCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYMPCheatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYMPCheatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPCheatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYChunkInstallDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYChunkInstallDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YChunkInstallDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYChunkManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYChunkManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YChunkManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YClientCreepPawn.ReceiveOnRepTeamChange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYClientCreepPawn::ReceiveOnRepTeamChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YClientCreepPawn.ReceiveOnRepTeamChange");
		
		AYClientCreepPawn_ReceiveOnRepTeamChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YClientCreepPawn.OnKilled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYClientCreepPawn::OnKilled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YClientCreepPawn.OnKilled");
		
		AYClientCreepPawn_OnKilled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F2A0
	 * 		Name   -> Function DreadGame.YClientCreepPawn.IsMyTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYClientCreepPawn::IsMyTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YClientCreepPawn.IsMyTeam");
		
		AYClientCreepPawn_IsMyTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYClientCreepPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYClientCreepPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YClientCreepPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784560
	 * 		Name   -> Function DreadGame.YCloakingComponent.WeaponFired
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      firingPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCloakingComponent::WeaponFired(class AYPawn* firingPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.WeaponFired");
		
		UYCloakingComponent_WeaponFired_Params params {};
		params.firingPawn = firingPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781E40
	 * 		Name   -> Function DreadGame.YCloakingComponent.TriggerCloakingModifier
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		EYShipCloakingModifier                             modifier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCloakingComponent::TriggerCloakingModifier(EYShipCloakingModifier modifier, float percentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.TriggerCloakingModifier");
		
		UYCloakingComponent_TriggerCloakingModifier_Params params {};
		params.modifier = modifier;
		params.percentage = percentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B210
	 * 		Name   -> Function DreadGame.YCloakingComponent.OnTakeDamage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 instigatorController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCloakingComponent::OnTakeDamage(float amount, float newHealth, class AController* instigatorController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.OnTakeDamage");
		
		UYCloakingComponent_OnTakeDamage_Params params {};
		params.amount = amount;
		params.newHealth = newHealth;
		params.instigatorController = instigatorController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766670
	 * 		Name   -> Function DreadGame.YCloakingComponent.OnOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		TArray<struct FYSoftCollisionOverlapResult>        overlapResults                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYCloakingComponent::OnOverlap(TArray<struct FYSoftCollisionOverlapResult> overlapResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.OnOverlap");
		
		UYCloakingComponent_OnOverlap_Params params {};
		params.overlapResults = overlapResults;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EE00
	 * 		Name   -> Function DreadGame.YCloakingComponent.GetCloakingState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYShipCloakingState UYCloakingComponent::GetCloakingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.GetCloakingState");
		
		UYCloakingComponent_GetCloakingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007498C0
	 * 		Name   -> Function DreadGame.YCloakingComponent.DeactivateCloaking
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYCloakingComponent::DeactivateCloaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.DeactivateCloaking");
		
		UYCloakingComponent_DeactivateCloaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CE50
	 * 		Name   -> Function DreadGame.YCloakingComponent.ActivateCloaking
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		float                                              shipMatlFalloff                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              cloakedMatlFalloff                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInstance*                           cloakingMID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FYShipCloakingModifier>              cloakingModifiers                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UYCloakingComponent::ActivateCloaking(float shipMatlFalloff, float cloakedMatlFalloff, class UMaterialInstance* cloakingMID, TArray<struct FYShipCloakingModifier>* cloakingModifiers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.ActivateCloaking");
		
		UYCloakingComponent_ActivateCloaking_Params params {};
		params.shipMatlFalloff = shipMatlFalloff;
		params.cloakedMatlFalloff = cloakedMatlFalloff;
		params.cloakingMID = cloakingMID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (cloakingModifiers != nullptr)
			*cloakingModifiers = params.cloakingModifiers;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073C760
	 * 		Name   -> Function DreadGame.YCloakingComponent.AbilityActivated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      firingPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCloakingComponent::AbilityActivated(class AYPawn* firingPawn, class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCloakingComponent.AbilityActivated");
		
		UYCloakingComponent_AbilityActivated_Params params {};
		params.firingPawn = firingPawn;
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCloakingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCloakingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCloakingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCloakSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCloakSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCloakSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007805A0
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.StopVoiceLine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYVoiceLine*                                 voiceLine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayVoiceLinesComponent::StopVoiceLine(class UYVoiceLine* voiceLine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.StopVoiceLine");
		
		UYPlayVoiceLinesComponent_StopVoiceLine_Params params {};
		params.voiceLine = voiceLine;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780110
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.StopCurrentVoiceLine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               clearAllQueuedVoiceLines                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYPlayVoiceLinesComponent::StopCurrentVoiceLine(bool clearAllQueuedVoiceLines)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.StopCurrentVoiceLine");
		
		UYPlayVoiceLinesComponent_StopCurrentVoiceLine_Params params {};
		params.clearAllQueuedVoiceLines = clearAllQueuedVoiceLines;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777ED0
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.SetGenericVoiceOverCharacterName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        voCharacterName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayVoiceLinesComponent::SetGenericVoiceOverCharacterName(const class FName& voCharacterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.SetGenericVoiceOverCharacterName");
		
		UYPlayVoiceLinesComponent_SetGenericVoiceOverCharacterName_Params params {};
		params.voCharacterName = voCharacterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D510
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.PlayVoiceLineImmediately
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYVoiceLine*                                 voiceLine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYVoiceLineAudioTemplate                           audioTemplate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYPlayVoiceLinesComponent::PlayVoiceLineImmediately(class UYVoiceLine* voiceLine, EYVoiceLineAudioTemplate audioTemplate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.PlayVoiceLineImmediately");
		
		UYPlayVoiceLinesComponent_PlayVoiceLineImmediately_Params params {};
		params.voiceLine = voiceLine;
		params.audioTemplate = audioTemplate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D450
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.PlayVoiceLineForEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        voiceLineName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYKismetGameplayConditionQueryContext*       queryContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYPlayVoiceLinesComponent::PlayVoiceLineForEvent(const class FName& voiceLineName, class UYKismetGameplayConditionQueryContext* queryContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.PlayVoiceLineForEvent");
		
		UYPlayVoiceLinesComponent_PlayVoiceLineForEvent_Params params {};
		params.voiceLineName = voiceLineName;
		params.queryContext = queryContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D390
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.PlayVoiceLine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYVoiceLine*                                 voiceLine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYVoiceLineAudioTemplate                           audioTemplate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayVoiceLinesComponent::PlayVoiceLine(class UYVoiceLine* voiceLine, EYVoiceLineAudioTemplate audioTemplate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.PlayVoiceLine");
		
		UYPlayVoiceLinesComponent_PlayVoiceLine_Params params {};
		params.voiceLine = voiceLine;
		params.audioTemplate = audioTemplate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F4E0
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.IsPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UYVoiceLine*                                 voiceLine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYPlayVoiceLinesComponent::IsPlaying(class UYVoiceLine* voiceLine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.IsPlaying");
		
		UYPlayVoiceLinesComponent_IsPlaying_Params params {};
		params.voiceLine = voiceLine;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752180
	 * 		Name   -> Function DreadGame.YPlayVoiceLinesComponent.GetGenericVoiceOverCharacterName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class FName UYPlayVoiceLinesComponent::GetGenericVoiceOverCharacterName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayVoiceLinesComponent.GetGenericVoiceOverCharacterName");
		
		UYPlayVoiceLinesComponent_GetGenericVoiceOverCharacterName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayVoiceLinesComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayVoiceLinesComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayVoiceLinesComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVoiceLineCategory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVoiceLineCategory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVoiceLineCategory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784370
	 * 		Name   -> Function DreadGame.YComVOComponent.VoiceLineCompleted
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		int32_t                                            uid                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::VoiceLineCompleted(int32_t uid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YComVOComponent.VoiceLineCompleted");
		
		UYComVOComponent_VoiceLineCompleted_Params params {};
		params.uid = uid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007825E0
	 * 		Name   -> Function DreadGame.YComVOComponent.TriggerPlayByPlayEventOnClient
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FName                                        triggerType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::TriggerPlayByPlayEventOnClient(const class FName& triggerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YComVOComponent.TriggerPlayByPlayEventOnClient");
		
		UYComVOComponent_TriggerPlayByPlayEventOnClient_Params params {};
		params.triggerType = triggerType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780080
	 * 		Name   -> Function DreadGame.YComVOComponent.StopCurrentVoiceLine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               clearAllQueuedVoiceLines                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::StopCurrentVoiceLine(bool clearAllQueuedVoiceLines)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YComVOComponent.StopCurrentVoiceLine");
		
		UYComVOComponent_StopCurrentVoiceLine_Params params {};
		params.clearAllQueuedVoiceLines = clearAllQueuedVoiceLines;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B5A0
	 * 		Name   -> Function DreadGame.YComVOComponent.OnTriggerFacialAnimationLoadCompleted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYBaseCharacter*                             Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYVoiceLineUnique*                           voLine                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              timeTriggered                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isAnimationLoadCallback                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::OnTriggerFacialAnimationLoadCompleted(class AYBaseCharacter* Character, class UYVoiceLineUnique* voLine, float timeTriggered, bool isAnimationLoadCallback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YComVOComponent.OnTriggerFacialAnimationLoadCompleted");
		
		UYComVOComponent_OnTriggerFacialAnimationLoadCompleted_Params params {};
		params.Character = Character;
		params.voLine = voLine;
		params.timeTriggered = timeTriggered;
		params.isAnimationLoadCallback = isAnimationLoadCallback;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YComVOComponent.OnComWindowVisibilityUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               visibile                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::OnComWindowVisibilityUpdated__DelegateSignature(bool visibile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YComVOComponent.OnComWindowVisibilityUpdated__DelegateSignature");
		
		UYComVOComponent_OnComWindowVisibilityUpdated__DelegateSignature_Params params {};
		params.visibile = visibile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YComVOComponent.OnComWindowTitleUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FString                                      title                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::OnComWindowTitleUpdated__DelegateSignature(const class FString& title)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YComVOComponent.OnComWindowTitleUpdated__DelegateSignature");
		
		UYComVOComponent_OnComWindowTitleUpdated__DelegateSignature_Params params {};
		params.title = title;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YComVOComponent.OnComWindowTextureUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::OnComWindowTextureUpdated__DelegateSignature(class UTexture* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YComVOComponent.OnComWindowTextureUpdated__DelegateSignature");
		
		UYComVOComponent_OnComWindowTextureUpdated__DelegateSignature_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YComVOComponent.OnComWindowSubtitleUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FString                                      subtitle                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYComVOComponent::OnComWindowSubtitleUpdated__DelegateSignature(const class FString& subtitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YComVOComponent.OnComWindowSubtitleUpdated__DelegateSignature");
		
		UYComVOComponent_OnComWindowSubtitleUpdated__DelegateSignature_Params params {};
		params.subtitle = subtitle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744950
	 * 		Name   -> Function DreadGame.YComVOComponent.ClearQueueOnDeath
	 * 		Flags  -> (Native, Protected)
	 */
	void UYComVOComponent::ClearQueueOnDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YComVOComponent.ClearQueueOnDeath");
		
		UYComVOComponent_ClearQueueOnDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007447E0
	 * 		Name   -> Function DreadGame.YComVOComponent.CleanComWindow
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYComVOComponent::CleanComWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YComVOComponent.CleanComWindow");
		
		UYComVOComponent_CleanComWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYComVOComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYComVOComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YComVOComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D010
	 * 		Name   -> Function DreadGame.YContainerWidget.PlayAudioEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		EYUIAudioEnum                                      audioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYContainerWidget::PlayAudioEvent(EYUIAudioEnum audioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YContainerWidget.PlayAudioEvent");
		
		UYContainerWidget_PlayAudioEvent_Params params {};
		params.audioEvent = audioEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYContainerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYContainerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YContainerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767680
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchContainer.OnPageIntroAnimationFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYWidget_EndOfMatchContainer::OnPageIntroAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchContainer.OnPageIntroAnimationFinished");
		
		UYWidget_EndOfMatchContainer_OnPageIntroAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767660
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchContainer.OnPageFadeOutFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYWidget_EndOfMatchContainer::OnPageFadeOutFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchContainer.OnPageFadeOutFinished");
		
		UYWidget_EndOfMatchContainer_OnPageFadeOutFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767640
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchContainer.OnPageFadeInFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYWidget_EndOfMatchContainer::OnPageFadeInFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchContainer.OnPageFadeInFinished");
		
		UYWidget_EndOfMatchContainer_OnPageFadeInFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742700
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchContainer.BroadcastLeaveMatchRequest
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYWidget_EndOfMatchContainer::BroadcastLeaveMatchRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchContainer.BroadcastLeaveMatchRequest");
		
		UYWidget_EndOfMatchContainer_BroadcastLeaveMatchRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EF20
	 * 		Name   -> Function DreadGame.YWidget.RemoveInputComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYWidget::RemoveInputComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.RemoveInputComponent");
		
		UYWidget_RemoveInputComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D090
	 * 		Name   -> Function DreadGame.YWidget.PlayAudioEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUIAudioEnum                                      audioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget::PlayAudioEvent(EYUIAudioEnum audioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.PlayAudioEvent");
		
		UYWidget_PlayAudioEvent_Params params {};
		params.audioEvent = audioEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00BC0500
	 * 		Name   -> Function DreadGame.YWidget.OnAllBlueprintLinksSet
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 */
	void UYWidget::OnAllBlueprintLinksSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.OnAllBlueprintLinksSet");
		
		UYWidget_OnAllBlueprintLinksSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759520
	 * 		Name   -> Function DreadGame.YWidget.GetStyleContainerReference
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class UYHUDWidget_StyleContainer* UYWidget::GetStyleContainerReference()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.GetStyleContainerReference");
		
		UYWidget_GetStyleContainerReference_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget.BP_InitializeWidgetLinks
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYWidget::BP_InitializeWidgetLinks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.BP_InitializeWidgetLinks");
		
		UYWidget_BP_InitializeWidgetLinks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741FE0
	 * 		Name   -> Function DreadGame.YWidget.BP_AnimateVisibility
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		ESlateVisibility                                   newVisibility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget::BP_AnimateVisibility(ESlateVisibility newVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.BP_AnimateVisibility");
		
		UYWidget_BP_AnimateVisibility_Params params {};
		params.newVisibility = newVisibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00BBFD00
	 * 		Name   -> Function DreadGame.YWidget.AnimateVisibility
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ESlateVisibility                                   newVisibility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget::AnimateVisibility(ESlateVisibility newVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.AnimateVisibility");
		
		UYWidget_AnimateVisibility_Params params {};
		params.newVisibility = newVisibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F090
	 * 		Name   -> Function DreadGame.YWidget.AddInputComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYWidget::AddInputComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget.AddInputComponent");
		
		UYWidget_AddInputComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FE90
	 * 		Name   -> Function DreadGame.YHUDWidget.IsWidgetForPlayer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        inUniqueID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYHUDWidget::IsWidgetForPlayer(const class FName& inUniqueID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.IsWidgetForPlayer");
		
		UYHUDWidget_IsWidgetForPlayer_Params params {};
		params.inUniqueID = inUniqueID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C590
	 * 		Name   -> Function DreadGame.YHUDWidget.HasPlayerUniqueID
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool UYHUDWidget::HasPlayerUniqueID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.HasPlayerUniqueID");
		
		UYHUDWidget_HasPlayerUniqueID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759520
	 * 		Name   -> Function DreadGame.YHUDWidget.GetStyleContainerReference
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class UYHUDWidget_StyleContainer* UYHUDWidget::GetStyleContainerReference()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.GetStyleContainerReference");
		
		UYHUDWidget_GetStyleContainerReference_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756F00
	 * 		Name   -> Function DreadGame.YHUDWidget.GetPlayerUniqueID
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName UYHUDWidget::GetPlayerUniqueID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.GetPlayerUniqueID");
		
		UYHUDWidget_GetPlayerUniqueID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C9B0
	 * 		Name   -> Function DreadGame.YHUDWidget.FormatSecondsToCountdownString
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYHUDWidget::FormatSecondsToCountdownString(int32_t seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.FormatSecondsToCountdownString");
		
		UYHUDWidget_FormatSecondsToCountdownString_Params params {};
		params.seconds = seconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C800
	 * 		Name   -> Function DreadGame.YHUDWidget.FormatNumberToText
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Number                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            decimalPlaces                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      units                                                      (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYHUDWidget::FormatNumberToText(float Number, int32_t decimalPlaces, const class FString& units)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.FormatNumberToText");
		
		UYHUDWidget_FormatNumberToText_Params params {};
		params.Number = Number;
		params.decimalPlaces = decimalPlaces;
		params.units = units;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget.BP_SetComponentLockState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		unsigned char                                      lockValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               lockState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget::BP_SetComponentLockState(unsigned char lockValue, bool lockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.BP_SetComponentLockState");
		
		UYHUDWidget_BP_SetComponentLockState_Params params {};
		params.lockValue = lockValue;
		params.lockState = lockState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget.BP_OnPlayerUniqueIDSet
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        inUniqueID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget::BP_OnPlayerUniqueIDSet(const class FName& inUniqueID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget.BP_OnPlayerUniqueIDSet");
		
		UYHUDWidget_BP_OnPlayerUniqueIDSet_Params params {};
		params.inUniqueID = inUniqueID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchContainerPS4.BP_EventScoreboardVisible
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Visible                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchContainerPS4::BP_EventScoreboardVisible(bool Visible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchContainerPS4.BP_EventScoreboardVisible");
		
		UYWidget_EndOfMatchContainerPS4_BP_EventScoreboardVisible_Params params {};
		params.Visible = Visible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchContainerPS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchContainerPS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchContainerPS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCookingFileIncluder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCookingFileIncluder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCookingFileIncluder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCreepManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCreepManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCreepManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCreepNavigationSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCreepNavigationSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCreepNavigationSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtA.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtA::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtA");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtAInterfaceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtAInterfaceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtAInterfaceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E270
	 * 		Name   -> Function DreadGame.YCtACaptainInterface.GetCaptain
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYCaptain* UYCtACaptainInterface::GetCaptain()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtACaptainInterface.GetCaptain");
		
		UYCtACaptainInterface_GetCaptain_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtACaptainInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtACaptainInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtACaptainInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C430
	 * 		Name   -> Function DreadGame.YCtAInventoryInterface.HasItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtAInventoryInterface::HasItem(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAInventoryInterface.HasItem");
		
		UYCtAInventoryInterface_HasItem_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtAInventoryInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtAInventoryInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtAInventoryInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782790
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.TriggerQueuedCtAsForGroup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            groupID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            numToTrigger                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtAManagerInterface::TriggerQueuedCtAsForGroup(int32_t groupID, int32_t numToTrigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.TriggerQueuedCtAsForGroup");
		
		UYCtAManagerInterface_TriggerQueuedCtAsForGroup_Params params {};
		params.groupID = groupID;
		params.numToTrigger = numToTrigger;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782700
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.TriggerQueuedCtAs
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            numToTrigger                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtAManagerInterface::TriggerQueuedCtAs(int32_t numToTrigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.TriggerQueuedCtAs");
		
		UYCtAManagerInterface_TriggerQueuedCtAs_Params params {};
		params.numToTrigger = numToTrigger;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782670
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.TriggerQueuedCtA
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtAManagerInterface::TriggerQueuedCtA(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.TriggerQueuedCtA");
		
		UYCtAManagerInterface_TriggerQueuedCtA_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782120
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.TriggerCtA
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAManagerInterface::TriggerCtA(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.TriggerCtA");
		
		UYCtAManagerInterface_TriggerCtA_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F010
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.RemoveQueuedCtAsForGroup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            groupID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAManagerInterface::RemoveQueuedCtAsForGroup(int32_t groupID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.RemoveQueuedCtAsForGroup");
		
		UYCtAManagerInterface_RemoveQueuedCtAsForGroup_Params params {};
		params.groupID = groupID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EC60
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.RemoveCtAFromQueue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAManagerInterface::RemoveCtAFromQueue(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.RemoveCtAFromQueue");
		
		UYCtAManagerInterface_RemoveCtAFromQueue_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E420
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.IsCtAQueued
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtAManagerInterface::IsCtAQueued(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.IsCtAQueued");
		
		UYCtAManagerInterface_IsCtAQueued_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E3F0
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.IsCtAManagerReady
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYCtAManagerInterface::IsCtAManagerReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.IsCtAManagerReady");
		
		UYCtAManagerInterface_IsCtAManagerReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C280
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.HasCtALinkBeenClicked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtAManagerInterface::HasCtALinkBeenClicked(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.HasCtALinkBeenClicked");
		
		UYCtAManagerInterface_HasCtALinkBeenClicked_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757740
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.GetQueuedCtAs
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class UYCtA*> UYCtAManagerInterface::GetQueuedCtAs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.GetQueuedCtAs");
		
		UYCtAManagerInterface_GetQueuedCtAs_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753510
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.GetLastTimeCtATriggered
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDateTime UYCtAManagerInterface::GetLastTimeCtATriggered(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.GetLastTimeCtATriggered");
		
		UYCtAManagerInterface_GetLastTimeCtATriggered_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753480
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.GetLastTimeCtAShown
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDateTime UYCtAManagerInterface::GetLastTimeCtAShown(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.GetLastTimeCtAShown");
		
		UYCtAManagerInterface_GetLastTimeCtAShown_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007504C0
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.GetCtATriggeredCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtAManagerInterface::GetCtATriggeredCount(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.GetCtATriggeredCount");
		
		UYCtAManagerInterface_GetCtATriggeredCount_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750430
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.GetCtAShownCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtAManagerInterface::GetCtAShownCount(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.GetCtAShownCount");
		
		UYCtAManagerInterface_GetCtAShownCount_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007493B0
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.CtAShown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAManagerInterface::CtAShown(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.CtAShown");
		
		UYCtAManagerInterface_CtAShown_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749330
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.CtALinkClicked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAManagerInterface::CtALinkClicked(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.CtALinkClicked");
		
		UYCtAManagerInterface_CtALinkClicked_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E840
	 * 		Name   -> Function DreadGame.YCtAManagerInterface.AddCtAToQueue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYCtA*                                       cta                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAManagerInterface::AddCtAToQueue(class UYCtA* cta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManagerInterface.AddCtAToQueue");
		
		UYCtAManagerInterface_AddCtAToQueue_Params params {};
		params.cta = cta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtAManagerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtAManagerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtAManagerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C310
	 * 		Name   -> Function DreadGame.YCtAPlayerInterface.HasEliteStatus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYCtAPlayerInterface::HasEliteStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAPlayerInterface.HasEliteStatus");
		
		UYCtAPlayerInterface_HasEliteStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759390
	 * 		Name   -> Function DreadGame.YCtAPlayerInterface.GetStatsCounterValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EYPlayerStatsCounterId                             counterId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYPlayerStatsCounterSubId                          subId                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtAPlayerInterface::GetStatsCounterValue(EYPlayerStatsCounterId counterId, EYPlayerStatsCounterSubId subId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAPlayerInterface.GetStatsCounterValue");
		
		UYCtAPlayerInterface_GetStatsCounterValue_Params params {};
		params.counterId = counterId;
		params.subId = subId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757FC0
	 * 		Name   -> Function DreadGame.YCtAPlayerInterface.GetSessionTime
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FTimespan UYCtAPlayerInterface::GetSessionTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAPlayerInterface.GetSessionTime");
		
		UYCtAPlayerInterface_GetSessionTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007517B0
	 * 		Name   -> Function DreadGame.YCtAPlayerInterface.GetEliteStatusTimeRemaining
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FTimespan UYCtAPlayerInterface::GetEliteStatusTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAPlayerInterface.GetEliteStatusTimeRemaining");
		
		UYCtAPlayerInterface_GetEliteStatusTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750550
	 * 		Name   -> Function DreadGame.YCtAPlayerInterface.GetCurrencyAmount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EYCurrency                                         currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtAPlayerInterface::GetCurrencyAmount(EYCurrency currencyType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAPlayerInterface.GetCurrencyAmount");
		
		UYCtAPlayerInterface_GetCurrencyAmount_Params params {};
		params.currencyType = currencyType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtAPlayerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtAPlayerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtAPlayerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753D80
	 * 		Name   -> Function DreadGame.YCtAProgressionInterface.GetManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYProgressionManagerClient* UYCtAProgressionInterface::GetManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAProgressionInterface.GetManager");
		
		UYCtAProgressionInterface_GetManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtAProgressionInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtAProgressionInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtAProgressionInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C660
	 * 		Name   -> Function DreadGame.YCtATechTreeInterface.HasResearchedItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtATechTreeInterface::HasResearchedItem(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtATechTreeInterface.HasResearchedItem");
		
		UYCtATechTreeInterface_HasResearchedItem_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C5D0
	 * 		Name   -> Function DreadGame.YCtATechTreeInterface.HasPurchasedItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtATechTreeInterface::HasPurchasedItem(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtATechTreeInterface.HasPurchasedItem");
		
		UYCtATechTreeInterface_HasPurchasedItem_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A2F0
	 * 		Name   -> Function DreadGame.YCtATechTreeInterface.GetUnresearchedModuleXPCostSumForClassTier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            classId                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            tier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtATechTreeInterface::GetUnresearchedModuleXPCostSumForClassTier(int32_t classId, int32_t tier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtATechTreeInterface.GetUnresearchedModuleXPCostSumForClassTier");
		
		UYCtATechTreeInterface_GetUnresearchedModuleXPCostSumForClassTier_Params params {};
		params.classId = classId;
		params.tier = tier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A260
	 * 		Name   -> Function DreadGame.YCtATechTreeInterface.GetUnresearchedModuleXPCostSumForClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            classId                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYCtATechTreeInterface::GetUnresearchedModuleXPCostSumForClass(int32_t classId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtATechTreeInterface.GetUnresearchedModuleXPCostSumForClass");
		
		UYCtATechTreeInterface_GetUnresearchedModuleXPCostSumForClass_Params params {};
		params.classId = classId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752D80
	 * 		Name   -> Function DreadGame.YCtATechTreeInterface.GetItemState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYTechTreeItemState UYCtATechTreeInterface::GetItemState(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtATechTreeInterface.GetItemState");
		
		UYCtATechTreeInterface_GetItemState_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743E50
	 * 		Name   -> Function DreadGame.YCtATechTreeInterface.CanResearchItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtATechTreeInterface::CanResearchItem(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtATechTreeInterface.CanResearchItem");
		
		UYCtATechTreeInterface_CanResearchItem_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743DC0
	 * 		Name   -> Function DreadGame.YCtATechTreeInterface.CanPurchaseItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYCtATechTreeInterface::CanPurchaseItem(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtATechTreeInterface.CanPurchaseItem");
		
		UYCtATechTreeInterface_CanPurchaseItem_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtATechTreeInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtATechTreeInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtATechTreeInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YCtAUIInterface.OnReturnedToHangarAfterGame__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYGameModeType                                     gameModeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAUIInterface::OnReturnedToHangarAfterGame__DelegateSignature(EYGameModeType gameModeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YCtAUIInterface.OnReturnedToHangarAfterGame__DelegateSignature");
		
		UYCtAUIInterface_OnReturnedToHangarAfterGame__DelegateSignature_Params params {};
		params.gameModeType = gameModeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YCtAUIInterface.OnPlayerLoggedIn__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYCtAUIInterface::OnPlayerLoggedIn__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YCtAUIInterface.OnPlayerLoggedIn__DelegateSignature");
		
		UYCtAUIInterface_OnPlayerLoggedIn__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YCtAUIInterface.OnPlayerDisconnected__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYCtAUIInterface::OnPlayerDisconnected__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YCtAUIInterface.OnPlayerDisconnected__DelegateSignature");
		
		UYCtAUIInterface_OnPlayerDisconnected__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YCtAUIInterface.OnMenuSectionSelected__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYOutpostSection                                   menuSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAUIInterface::OnMenuSectionSelected__DelegateSignature(EYOutpostSection menuSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YCtAUIInterface.OnMenuSectionSelected__DelegateSignature");
		
		UYCtAUIInterface_OnMenuSectionSelected__DelegateSignature_Params params {};
		params.menuSection = menuSection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B3B0
	 * 		Name   -> Function DreadGame.YCtAUIInterface.HandleOnReturnedToHangarAfterGame
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EYGameModeType                                     gameModeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAUIInterface::HandleOnReturnedToHangarAfterGame(EYGameModeType gameModeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAUIInterface.HandleOnReturnedToHangarAfterGame");
		
		UYCtAUIInterface_HandleOnReturnedToHangarAfterGame_Params params {};
		params.gameModeType = gameModeType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BEF0
	 * 		Name   -> Function DreadGame.YCtAUIInterface.HandleOnPlayerLoggedIn
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYCtAUIInterface::HandleOnPlayerLoggedIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAUIInterface.HandleOnPlayerLoggedIn");
		
		UYCtAUIInterface_HandleOnPlayerLoggedIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BED0
	 * 		Name   -> Function DreadGame.YCtAUIInterface.HandleOnPlayerDisconnected
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYCtAUIInterface::HandleOnPlayerDisconnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAUIInterface.HandleOnPlayerDisconnected");
		
		UYCtAUIInterface_HandleOnPlayerDisconnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BAD0
	 * 		Name   -> Function DreadGame.YCtAUIInterface.HandleOnMenuSectionSelected
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EYOutpostSection                                   menuSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAUIInterface::HandleOnMenuSectionSelected(EYOutpostSection menuSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAUIInterface.HandleOnMenuSectionSelected");
		
		UYCtAUIInterface_HandleOnMenuSectionSelected_Params params {};
		params.menuSection = menuSection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtAUIInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtAUIInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtAUIInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtASaveData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtASaveData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtASaveData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BF10
	 * 		Name   -> Function DreadGame.YCtAManager.HandleOnPlayerStatsCounterDataAvailable
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FYPlayerStatsCounterData                    counterData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYCtAManager::HandleOnPlayerStatsCounterDataAvailable(const struct FYPlayerStatsCounterData& counterData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManager.HandleOnPlayerStatsCounterDataAvailable");
		
		UYCtAManager_HandleOnPlayerStatsCounterDataAvailable_Params params {};
		params.counterData = counterData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BE90
	 * 		Name   -> Function DreadGame.YCtAManager.HandleOnPlayerDataLoaded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYCtAManager::HandleOnPlayerDataLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManager.HandleOnPlayerDataLoaded");
		
		UYCtAManager_HandleOnPlayerDataLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BC70
	 * 		Name   -> Function DreadGame.YCtAManager.HandleOnPlayerControllerSet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPlayerControllerBase*                      PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYCtAManager::HandleOnPlayerControllerSet(class AYPlayerControllerBase* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCtAManager.HandleOnPlayerControllerSet");
		
		UYCtAManager_HandleOnPlayerControllerSet_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCtAManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCtAManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCtAManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BEB0
	 * 		Name   -> Function DreadGame.YCustomMatchManager.HandleOnPlayerDataLoaded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYCustomMatchManager::HandleOnPlayerDataLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCustomMatchManager.HandleOnPlayerDataLoaded");
		
		UYCustomMatchManager_HandleOnPlayerDataLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCustomMatchManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCustomMatchManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCustomMatchManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYCustomMatchManagerPS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYCustomMatchManagerPS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCustomMatchManagerPS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYLootDropDataTableHelper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYLootDropDataTableHelper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLootDropDataTableHelper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CA30
	 * 		Name   -> Function DreadGame.YHUDBase.SetUseControllerAsMouse
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               useAsMouse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUDBase::SetUseControllerAsMouse(bool useAsMouse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDBase.SetUseControllerAsMouse");
		
		AYHUDBase_SetUseControllerAsMouse_Params params {};
		params.useAsMouse = useAsMouse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768700
	 * 		Name   -> Function DreadGame.YHUDBase.OnPurchaseBattleReadyResult
	 * 		Flags  -> (Native, Public)
	 */
	void AYHUDBase::OnPurchaseBattleReadyResult()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDBase.OnPurchaseBattleReadyResult");
		
		AYHUDBase_OnPurchaseBattleReadyResult_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752220
	 * 		Name   -> Function DreadGame.YHUDBase.GetGlobalUIData
	 * 		Flags  -> (Final, Native, Public)
	 */
	class UYUIData* AYHUDBase::GetGlobalUIData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDBase.GetGlobalUIData");
		
		AYHUDBase_GetGlobalUIData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYHUDBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYHUDBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783980
	 * 		Name   -> Function DreadGame.YMenu.UpdateLoadoutDetail
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::UpdateLoadoutDetail(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.UpdateLoadoutDetail");
		
		AYMenu_UpdateLoadoutDetail_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783420
	 * 		Name   -> Function DreadGame.YMenu.UpdateFleetSlots
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::UpdateFleetSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.UpdateFleetSlots");
		
		AYMenu_UpdateFleetSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783400
	 * 		Name   -> Function DreadGame.YMenu.UpdateFleetMaintenance
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::UpdateFleetMaintenance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.UpdateFleetMaintenance");
		
		AYMenu_UpdateFleetMaintenance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783020
	 * 		Name   -> Function DreadGame.YMenu.UpdateCurrentPurchaseItemData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               catalogIsReloaded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::UpdateCurrentPurchaseItemData(bool catalogIsReloaded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.UpdateCurrentPurchaseItemData");
		
		AYMenu_UpdateCurrentPurchaseItemData_Params params {};
		params.catalogIsReloaded = catalogIsReloaded;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782DE0
	 * 		Name   -> Function DreadGame.YMenu.UncoverLoginScreenWidget
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::UncoverLoginScreenWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.UncoverLoginScreenWidget");
		
		AYMenu_UncoverLoginScreenWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FE90
	 * 		Name   -> Function DreadGame.YMenu.StartTutorial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYMenu::StartTutorial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.StartTutorial");
		
		AYMenu_StartTutorial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FCF0
	 * 		Name   -> Function DreadGame.YMenu.StartMatchmaking
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            gameModeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      mapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::StartMatchmaking(int32_t gameModeType, const class FString& mapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.StartMatchmaking");
		
		AYMenu_StartMatchmaking_Params params {};
		params.gameModeType = gameModeType;
		params.mapName = mapName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F890
	 * 		Name   -> Function DreadGame.YMenu.StartBenchmark
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYMenu::StartBenchmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.StartBenchmark");
		
		AYMenu_StartBenchmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D160
	 * 		Name   -> Function DreadGame.YMenu.ShopRebuilt
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::ShopRebuilt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.ShopRebuilt");
		
		AYMenu_ShopRebuilt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D120
	 * 		Name   -> Function DreadGame.YMenu.ShopCatalogUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::ShopCatalogUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.ShopCatalogUpdated");
		
		AYMenu_ShopCatalogUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A0F0
	 * 		Name   -> Function DreadGame.YMenu.SetPreviewActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYShipCustomizationPreview*                  previewActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               renderThumbnail                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::SetPreviewActor(class AYShipCustomizationPreview* previewActor, bool renderThumbnail)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.SetPreviewActor");
		
		AYMenu_SetPreviewActor_Params params {};
		params.previewActor = previewActor;
		params.renderThumbnail = renderThumbnail;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778EA0
	 * 		Name   -> Function DreadGame.YMenu.SetMenuState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYMenuState                                        menuState                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuSubState                                     menuSubState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::SetMenuState(EYMenuState menuState, EYMenuSubState menuSubState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.SetMenuState");
		
		AYMenu_SetMenuState_Params params {};
		params.menuState = menuState;
		params.menuSubState = menuSubState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YMenu.SetHideHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               hudIsHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::SetHideHUD(bool hudIsHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.SetHideHUD");
		
		AYMenu_SetHideHUD_Params params {};
		params.hudIsHidden = hudIsHidden;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776120
	 * 		Name   -> Function DreadGame.YMenu.SetCaptainBaseTemplate
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      genderTag                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::SetCaptainBaseTemplate(const class FString& genderTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.SetCaptainBaseTemplate");
		
		AYMenu_SetCaptainBaseTemplate_Params params {};
		params.genderTag = genderTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YMenu.SetCalloutAllButtonsEnabled
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::SetCalloutAllButtonsEnabled(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.SetCalloutAllButtonsEnabled");
		
		AYMenu_SetCalloutAllButtonsEnabled_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F820
	 * 		Name   -> Function DreadGame.YMenu.RequestMarketCamera
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::RequestMarketCamera(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.RequestMarketCamera");
		
		AYMenu_RequestMarketCamera_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DCB0
	 * 		Name   -> Function DreadGame.YMenu.PlayerShipXpUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::PlayerShipXpUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.PlayerShipXpUpdated");
		
		AYMenu_PlayerShipXpUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DAC0
	 * 		Name   -> Function DreadGame.YMenu.PlayerFreeXpUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::PlayerFreeXpUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.PlayerFreeXpUpdated");
		
		AYMenu_PlayerFreeXpUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D9E0
	 * 		Name   -> Function DreadGame.YMenu.PlayerDisconnected
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::PlayerDisconnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.PlayerDisconnected");
		
		AYMenu_PlayerDisconnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnUpdateVanityPurchaseData
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FYUIVanityItemPurchaseData                  purchaseData                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnUpdateVanityPurchaseData(const struct FYUIVanityItemPurchaseData& purchaseData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnUpdateVanityPurchaseData");
		
		AYMenu_OnUpdateVanityPurchaseData_Params params {};
		params.purchaseData = purchaseData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnUpdateTechTreePurchaseData
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FYUITechTreeItemPurchaseData                purchaseData                                               (Parm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            missingShipXP                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isOfficerBriefing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnUpdateTechTreePurchaseData(const struct FYUITechTreeItemPurchaseData& purchaseData, int32_t missingShipXP, bool isOfficerBriefing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnUpdateTechTreePurchaseData");
		
		AYMenu_OnUpdateTechTreePurchaseData_Params params {};
		params.purchaseData = purchaseData;
		params.missingShipXP = missingShipXP;
		params.isOfficerBriefing = isOfficerBriefing;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnUpdateBundlePurchaseData
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FYUIBundleItemPurchaseData                  purchaseData                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnUpdateBundlePurchaseData(const struct FYUIBundleItemPurchaseData& purchaseData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnUpdateBundlePurchaseData");
		
		AYMenu_OnUpdateBundlePurchaseData_Params params {};
		params.purchaseData = purchaseData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B7B0
	 * 		Name   -> Function DreadGame.YMenu.OnUIReadyForInit
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnUIReadyForInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnUIReadyForInit");
		
		AYMenu_OnUIReadyForInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMenu.OnStoredPlayersDisplayInformationUpdatedPS4
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnStoredPlayersDisplayInformationUpdatedPS4()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnStoredPlayersDisplayInformationUpdatedPS4");
		
		AYMenu_OnStoredPlayersDisplayInformationUpdatedPS4_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076ABC0
	 * 		Name   -> Function DreadGame.YMenu.OnStoredPlayersDisplayInformationUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnStoredPlayersDisplayInformationUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnStoredPlayersDisplayInformationUpdated");
		
		AYMenu_OnStoredPlayersDisplayInformationUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A7B0
	 * 		Name   -> Function DreadGame.YMenu.OnSkipMaintenance
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnSkipMaintenance(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnSkipMaintenance");
		
		AYMenu_OnSkipMaintenance_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A570
	 * 		Name   -> Function DreadGame.YMenu.OnShopPurchaseComplete
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            purchaseResult                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      offerId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            quantity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnShopPurchaseComplete(int32_t purchaseResult, const class FString& offerId, int32_t quantity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnShopPurchaseComplete");
		
		AYMenu_OnShopPurchaseComplete_Params params {};
		params.purchaseResult = purchaseResult;
		params.offerId = offerId;
		params.quantity = quantity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnShipSlotSelected__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FCachedItemIDDataEntry                      cachedItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EYUILoadoutItemType                                itemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeleportToSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnShipSlotSelected__DelegateSignature(const struct FCachedItemIDDataEntry& cachedItemData, EYUILoadoutItemType itemType, bool bTeleportToSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnShipSlotSelected__DelegateSignature");
		
		AYMenu_OnShipSlotSelected__DelegateSignature_Params params {};
		params.cachedItemData = cachedItemData;
		params.itemType = itemType;
		params.bTeleportToSlot = bTeleportToSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A490
	 * 		Name   -> Function DreadGame.YMenu.OnShipNameValidationResponse
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      newName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnShipNameValidationResponse(const class FString& newName, int32_t Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnShipNameValidationResponse");
		
		AYMenu_OnShipNameValidationResponse_Params params {};
		params.newName = newName;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnSetPreviewActor__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AActor*                                      shipActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnSetPreviewActor__DelegateSignature(class AActor* shipActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnSetPreviewActor__DelegateSignature");
		
		AYMenu_OnSetPreviewActor__DelegateSignature_Params params {};
		params.shipActor = shipActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnReturnedToHangarAfterGame__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYGameModeType                                     gameModeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnReturnedToHangarAfterGame__DelegateSignature(EYGameModeType gameModeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnReturnedToHangarAfterGame__DelegateSignature");
		
		AYMenu_OnReturnedToHangarAfterGame__DelegateSignature_Params params {};
		params.gameModeType = gameModeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768700
	 * 		Name   -> Function DreadGame.YMenu.OnPurchaseBattleReadyResult
	 * 		Flags  -> (Native, Public)
	 */
	void AYMenu::OnPurchaseBattleReadyResult()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnPurchaseBattleReadyResult");
		
		AYMenu_OnPurchaseBattleReadyResult_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMenu.OnProgressionInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnProgressionInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnProgressionInitialized");
		
		AYMenu_OnProgressionInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007685E0
	 * 		Name   -> Function DreadGame.YMenu.OnPreviewLoadoutFinishedLoading
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnPreviewLoadoutFinishedLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnPreviewLoadoutFinishedLoading");
		
		AYMenu_OnPreviewLoadoutFinishedLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768490
	 * 		Name   -> Function DreadGame.YMenu.OnPreviewActor_LoadoutAsyncLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYShipLoadout*                               loadout                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnPreviewActor_LoadoutAsyncLoaded(class UYShipLoadout* loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnPreviewActor_LoadoutAsyncLoaded");
		
		AYMenu_OnPreviewActor_LoadoutAsyncLoaded_Params params {};
		params.loadout = loadout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768230
	 * 		Name   -> Function DreadGame.YMenu.OnPlayerResearchRequestData
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               purchaseState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnPlayerResearchRequestData(int32_t itemID, bool purchaseState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnPlayerResearchRequestData");
		
		AYMenu_OnPlayerResearchRequestData_Params params {};
		params.itemID = itemID;
		params.purchaseState = purchaseState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnPlayerLoggedIn__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYMenu::OnPlayerLoggedIn__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnPlayerLoggedIn__DelegateSignature");
		
		AYMenu_OnPlayerLoggedIn__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnPlayerDisconnected__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYMenu::OnPlayerDisconnected__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnPlayerDisconnected__DelegateSignature");
		
		AYMenu_OnPlayerDisconnected__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767BF0
	 * 		Name   -> Function DreadGame.YMenu.OnPlayerDataAvailable
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::OnPlayerDataAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnPlayerDataAvailable");
		
		AYMenu_OnPlayerDataAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767B60
	 * 		Name   -> Function DreadGame.YMenu.OnPlayerConversionRequestDone
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnPlayerConversionRequestDone(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnPlayerConversionRequestDone");
		
		AYMenu_OnPlayerConversionRequestDone_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767B40
	 * 		Name   -> Function DreadGame.YMenu.OnPlayerContractsUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnPlayerContractsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnPlayerContractsUpdated");
		
		AYMenu_OnPlayerContractsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnOverlayMenuToggled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               toggled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnOverlayMenuToggled(bool toggled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnOverlayMenuToggled");
		
		AYMenu_OnOverlayMenuToggled_Params params {};
		params.toggled = toggled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766C90
	 * 		Name   -> Function DreadGame.YMenu.OnOverlayMenuButtonPressed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            buttonID                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnOverlayMenuButtonPressed(int32_t buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnOverlayMenuButtonPressed");
		
		AYMenu_OnOverlayMenuButtonPressed_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765F30
	 * 		Name   -> Function DreadGame.YMenu.OnOutpostLoadedAndVisible
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::OnOutpostLoadedAndVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnOutpostLoadedAndVisible");
		
		AYMenu_OnOutpostLoadedAndVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765DA0
	 * 		Name   -> Function DreadGame.YMenu.OnOnboardingInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnOnboardingInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnOnboardingInitialized");
		
		AYMenu_OnOnboardingInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007657B0
	 * 		Name   -> Function DreadGame.YMenu.OnMovieStopped
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYMenu::OnMovieStopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnMovieStopped");
		
		AYMenu_OnMovieStopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnMenuStateChanged_PS4
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYMenuState                                        previousMenuState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuState                                        newMenuState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuSubState                                     previousMenuSubState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuSubState                                     currentMenuSubState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnMenuStateChanged_PS4(EYMenuState previousMenuState, EYMenuState newMenuState, EYMenuSubState previousMenuSubState, EYMenuSubState currentMenuSubState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnMenuStateChanged_PS4");
		
		AYMenu_OnMenuStateChanged_PS4_Params params {};
		params.previousMenuState = previousMenuState;
		params.newMenuState = newMenuState;
		params.previousMenuSubState = previousMenuSubState;
		params.currentMenuSubState = currentMenuSubState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnMenuStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYMenuState                                        previousMenuState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuState                                        newMenuState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnMenuStateChanged(EYMenuState previousMenuState, EYMenuState newMenuState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnMenuStateChanged");
		
		AYMenu_OnMenuStateChanged_Params params {};
		params.previousMenuState = previousMenuState;
		params.newMenuState = newMenuState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnMenuSectionSelected__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYOutpostSection                                   outpostSelection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnMenuSectionSelected__DelegateSignature(EYOutpostSection outpostSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnMenuSectionSelected__DelegateSignature");
		
		AYMenu_OnMenuSectionSelected__DelegateSignature_Params params {};
		params.outpostSelection = outpostSelection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764DA0
	 * 		Name   -> Function DreadGame.YMenu.OnLoadoutUpdatedInFleet
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnLoadoutUpdatedInFleet(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnLoadoutUpdatedInFleet");
		
		AYMenu_OnLoadoutUpdatedInFleet_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764B40
	 * 		Name   -> Function DreadGame.YMenu.OnLoadoutRemovedFromFleet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnLoadoutRemovedFromFleet(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnLoadoutRemovedFromFleet");
		
		AYMenu_OnLoadoutRemovedFromFleet_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007648C0
	 * 		Name   -> Function DreadGame.YMenu.OnLoadoutAddToFleetFailed
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::OnLoadoutAddToFleetFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnLoadoutAddToFleetFailed");
		
		AYMenu_OnLoadoutAddToFleetFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764A00
	 * 		Name   -> Function DreadGame.YMenu.OnLoadoutAddedToFleet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnLoadoutAddedToFleet(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnLoadoutAddedToFleet");
		
		AYMenu_OnLoadoutAddedToFleet_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007648E0
	 * 		Name   -> Function DreadGame.YMenu.OnLoadoutAdded
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnLoadoutAdded(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnLoadoutAdded");
		
		AYMenu_OnLoadoutAdded_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007647C0
	 * 		Name   -> Function DreadGame.YMenu.OnLoadoutActivated
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UYLoadoutManagerComponent*                   loadoutManager                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYShipLoadout*                               shipLoadout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYLoadoutFilter*                             Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnLoadoutActivated(class UYLoadoutManagerComponent* loadoutManager, class UYShipLoadout* shipLoadout, class UYLoadoutFilter* Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnLoadoutActivated");
		
		AYMenu_OnLoadoutActivated_Params params {};
		params.loadoutManager = loadoutManager;
		params.shipLoadout = shipLoadout;
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764580
	 * 		Name   -> Function DreadGame.YMenu.OnItemClaimCompleted
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnItemClaimCompleted(int32_t itemID, bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnItemClaimCompleted");
		
		AYMenu_OnItemClaimCompleted_Params params {};
		params.itemID = itemID;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007643E0
	 * 		Name   -> Function DreadGame.YMenu.OnInventoryInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::OnInventoryInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnInventoryInitialized");
		
		AYMenu_OnInventoryInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007643A0
	 * 		Name   -> Function DreadGame.YMenu.OnInitialCharacterCreationFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::OnInitialCharacterCreationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnInitialCharacterCreationFinished");
		
		AYMenu_OnInitialCharacterCreationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007642D0
	 * 		Name   -> Function DreadGame.YMenu.OnIndividualFleetMaintenanceUpdated
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FName                                        fleetId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maintenanceCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnIndividualFleetMaintenanceUpdated(const class FName& fleetId, int32_t maintenanceCost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnIndividualFleetMaintenanceUpdated");
		
		AYMenu_OnIndividualFleetMaintenanceUpdated_Params params {};
		params.fleetId = fleetId;
		params.maintenanceCost = maintenanceCost;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763F50
	 * 		Name   -> Function DreadGame.YMenu.OnFleetUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::OnFleetUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnFleetUpdated");
		
		AYMenu_OnFleetUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763ED0
	 * 		Name   -> Function DreadGame.YMenu.OnFleetUnlocked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EYFleetType                                        fleetType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnFleetUnlocked(EYFleetType fleetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnFleetUnlocked");
		
		AYMenu_OnFleetUnlocked_Params params {};
		params.fleetType = fleetType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763990
	 * 		Name   -> Function DreadGame.YMenu.OnDataManagerInitialized
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::OnDataManagerInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnDataManagerInitialized");
		
		AYMenu_OnDataManagerInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762C00
	 * 		Name   -> Function DreadGame.YMenu.OnCareerProgressionGoalStageRewardUpdated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               succeed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnCareerProgressionGoalStageRewardUpdated(const class FName& goalId, bool succeed, const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnCareerProgressionGoalStageRewardUpdated");
		
		AYMenu_OnCareerProgressionGoalStageRewardUpdated_Params params {};
		params.goalId = goalId;
		params.succeed = succeed;
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762B40
	 * 		Name   -> Function DreadGame.YMenu.OnCareerProgressionGoalProgressChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            newProgressValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnCareerProgressionGoalProgressChanged(const class FName& goalId, int32_t newProgressValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnCareerProgressionGoalProgressChanged");
		
		AYMenu_OnCareerProgressionGoalProgressChanged_Params params {};
		params.goalId = goalId;
		params.newProgressValue = newProgressValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMenu.OnCaptainUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::OnCaptainUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnCaptainUpdated");
		
		AYMenu_OnCaptainUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnCameraViewShipItem__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FCachedItemIDDataEntry                      cachedItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EYUILoadoutItemType                                itemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeleportToSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnCameraViewShipItem__DelegateSignature(const struct FCachedItemIDDataEntry& cachedItemData, EYUILoadoutItemType itemType, bool bTeleportToSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnCameraViewShipItem__DelegateSignature");
		
		AYMenu_OnCameraViewShipItem__DelegateSignature_Params params {};
		params.cachedItemData = cachedItemData;
		params.itemType = itemType;
		params.bTeleportToSlot = bTeleportToSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnBPTutorialClicked
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      mapToTravel                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnBPTutorialClicked(const class FString& mapToTravel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnBPTutorialClicked");
		
		AYMenu_OnBPTutorialClicked_Params params {};
		params.mapToTravel = mapToTravel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnBPShipSelected
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYShipClass                                        shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnBPShipSelected(EYShipClass shipclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnBPShipSelected");
		
		AYMenu_OnBPShipSelected_Params params {};
		params.shipclass = shipclass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.OnBPAbilitiyCategorySelected
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYAbilityCategory                                  Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnBPAbilitiyCategorySelected(EYAbilityCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnBPAbilitiyCategorySelected");
		
		AYMenu_OnBPAbilitiyCategorySelected_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C1F0
	 * 		Name   -> Function DreadGame.YMenu.OnboardingNotifyShipSlot
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FCachedItemIDDataEntry                      cachedItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EYUILoadoutItemType                                itemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnboardingNotifyShipSlot(const struct FCachedItemIDDataEntry& cachedItemData, EYUILoadoutItemType itemType, bool bTeleport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.OnboardingNotifyShipSlot");
		
		AYMenu_OnboardingNotifyShipSlot_Params params {};
		params.cachedItemData = cachedItemData;
		params.itemType = itemType;
		params.bTeleport = bTeleport;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMenu.OnAsyncVideoLoaded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UFileMediaSource*                            VideoMovieSource                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::OnAsyncVideoLoaded__DelegateSignature(class UFileMediaSource* VideoMovieSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMenu.OnAsyncVideoLoaded__DelegateSignature");
		
		AYMenu_OnAsyncVideoLoaded__DelegateSignature_Params params {};
		params.VideoMovieSource = VideoMovieSource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760160
	 * 		Name   -> Function DreadGame.YMenu.LeaveSquad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYMenu::LeaveSquad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.LeaveSquad");
		
		AYMenu_LeaveSquad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007600A0
	 * 		Name   -> Function DreadGame.YMenu.JumpToPreviousMenuState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYMenu::JumpToPreviousMenuState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.JumpToPreviousMenuState");
		
		AYMenu_JumpToPreviousMenuState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EFB0
	 * 		Name   -> Function DreadGame.YMenu.IsInEscapeMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AYMenu::IsInEscapeMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.IsInEscapeMenu");
		
		AYMenu_IsInEscapeMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenu.HandleShopBackendValidationResult
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYMenuState                                        menuState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuSubState                                     menuSubState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            spectateItemID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::HandleShopBackendValidationResult(bool Result, EYMenuState menuState, EYMenuSubState menuSubState, int32_t spectateItemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.HandleShopBackendValidationResult");
		
		AYMenu_HandleShopBackendValidationResult_Params params {};
		params.Result = Result;
		params.menuState = menuState;
		params.menuSubState = menuSubState;
		params.spectateItemID = spectateItemID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759B70
	 * 		Name   -> Function DreadGame.YMenu.GetTechTreeItemStateOfItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYTechTreeItemState AYMenu::GetTechTreeItemStateOfItem(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetTechTreeItemStateOfItem");
		
		AYMenu_GetTechTreeItemStateOfItem_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007590C0
	 * 		Name   -> Function DreadGame.YMenu.GetSquadMenuBP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYHUDWidget_Squad* AYMenu::GetSquadMenuBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetSquadMenuBP");
		
		AYMenu_GetSquadMenuBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007590A0
	 * 		Name   -> Function DreadGame.YMenu.GetSquadMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYHUDWidget_Squad* AYMenu::GetSquadMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetSquadMenu");
		
		AYMenu_GetSquadMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758BB0
	 * 		Name   -> Function DreadGame.YMenu.GetShop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYShop* AYMenu::GetShop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetShop");
		
		AYMenu_GetShop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757C80
	 * 		Name   -> Function DreadGame.YMenu.GetScaleformMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYGFxMoviePlayer_YMenu* AYMenu::GetScaleformMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetScaleformMenu");
		
		AYMenu_GetScaleformMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007545A0
	 * 		Name   -> Function DreadGame.YMenu.GetModuleVideoFromPath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      videoPath                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      directory                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UFileMediaSource* AYMenu::GetModuleVideoFromPath(const class FString& videoPath, const class FString& directory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetModuleVideoFromPath");
		
		AYMenu_GetModuleVideoFromPath_Params params {};
		params.videoPath = videoPath;
		params.directory = directory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007544A0
	 * 		Name   -> Function DreadGame.YMenu.GetModuleStillFromPath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      imagePath                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      directory                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* AYMenu::GetModuleStillFromPath(const class FString& imagePath, const class FString& directory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetModuleStillFromPath");
		
		AYMenu_GetModuleStillFromPath_Params params {};
		params.imagePath = imagePath;
		params.directory = directory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750C10
	 * 		Name   -> Function DreadGame.YMenu.GetCurrentShipResearchTreeItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYMenu::GetCurrentShipResearchTreeItemId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetCurrentShipResearchTreeItemId");
		
		AYMenu_GetCurrentShipResearchTreeItemId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750B60
	 * 		Name   -> Function DreadGame.YMenu.GetCurrentPurchaseItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYMenu::GetCurrentPurchaseItemId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetCurrentPurchaseItemId");
		
		AYMenu_GetCurrentPurchaseItemId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D780
	 * 		Name   -> Function DreadGame.YMenu.GetAssetItemInflatedIds
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      itemAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<int32_t> AYMenu::GetAssetItemInflatedIds(class UClass* itemAsset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetAssetItemInflatedIds");
		
		AYMenu_GetAssetItemInflatedIds_Params params {};
		params.itemAsset = itemAsset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D6F0
	 * 		Name   -> Function DreadGame.YMenu.GetAssetItemBaseId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      itemAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYMenu::GetAssetItemBaseId(class UClass* itemAsset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.GetAssetItemBaseId");
		
		AYMenu_GetAssetItemBaseId_Params params {};
		params.itemAsset = itemAsset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C770
	 * 		Name   -> Function DreadGame.YMenu.ForceStartMatch
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYMenu::ForceStartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.ForceStartMatch");
		
		AYMenu_ForceStartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMenu.ForceLocalServer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYMenu::ForceLocalServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.ForceLocalServer");
		
		AYMenu_ForceLocalServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749060
	 * 		Name   -> Function DreadGame.YMenu.CoverLoginScreenWidget
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::CoverLoginScreenWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.CoverLoginScreenWidget");
		
		AYMenu_CoverLoginScreenWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744880
	 * 		Name   -> Function DreadGame.YMenu.ClearCurrentLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYMenu::ClearCurrentLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.ClearCurrentLoadout");
		
		AYMenu_ClearCurrentLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744340
	 * 		Name   -> Function DreadGame.YMenu.CheckForPromotionItemsNotification
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYMenu::CheckForPromotionItemsNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.CheckForPromotionItemsNotification");
		
		AYMenu_CheckForPromotionItemsNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMenu.AutoMatchMakeForMatchSoakTest
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYMenu::AutoMatchMakeForMatchSoakTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.AutoMatchMakeForMatchSoakTest");
		
		AYMenu_AutoMatchMakeForMatchSoakTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741EA0
	 * 		Name   -> Function DreadGame.YMenu.AttemptPurchase
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::AttemptPurchase(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.AttemptPurchase");
		
		AYMenu_AttemptPurchase_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741CC0
	 * 		Name   -> Function DreadGame.YMenu.AsyncLoadVideoFromPath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      videoPath                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      directory                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMenu::AsyncLoadVideoFromPath(const class FString& videoPath, const class FString& directory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenu.AsyncLoadVideoFromPath");
		
		AYMenu_AsyncLoadVideoFromPath_Params params {};
		params.videoPath = videoPath;
		params.directory = directory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783510
	 * 		Name   -> Function DreadGame.YGoalManager.UpdateGoals
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<class FString>                              goals                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYGoalManager::UpdateGoals(TArray<class FString> goals)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.UpdateGoals");
		
		UYGoalManager_UpdateGoals_Params params {};
		params.goals = goals;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783140
	 * 		Name   -> Function DreadGame.YGoalManager.UpdateData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGoalManager::UpdateData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.UpdateData");
		
		UYGoalManager_UpdateData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGoalManager.OnGoalsUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGoalManager::OnGoalsUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGoalManager.OnGoalsUpdated__DelegateSignature");
		
		UYGoalManager_OnGoalsUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGoalManager.OnGoalsListUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGoalManager::OnGoalsListUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGoalManager.OnGoalsListUpdated__DelegateSignature");
		
		UYGoalManager_OnGoalsListUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EB90
	 * 		Name   -> Function DreadGame.YGoalManager.IsGoalReadyToBeClaimed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYGoalManager::IsGoalReadyToBeClaimed(const class FName& goalId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.IsGoalReadyToBeClaimed");
		
		UYGoalManager_IsGoalReadyToBeClaimed_Params params {};
		params.goalId = goalId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EB00
	 * 		Name   -> Function DreadGame.YGoalManager.IsGoalCategoryUnlocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYGoalCategory                                     Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYGoalManager::IsGoalCategoryUnlocked(EYGoalCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.IsGoalCategoryUnlocked");
		
		UYGoalManager_IsGoalCategoryUnlocked_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EAD0
	 * 		Name   -> Function DreadGame.YGoalManager.IsGameModesUnlocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYGoalManager::IsGameModesUnlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.IsGameModesUnlocked");
		
		UYGoalManager_IsGameModesUnlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D5A0
	 * 		Name   -> Function DreadGame.YGoalManager.InitializeGoalListFromDataTable
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDataTable*                                  DataTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGoalManager::InitializeGoalListFromDataTable(class UDataTable* DataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.InitializeGoalListFromDataTable");
		
		UYGoalManager_InitializeGoalListFromDataTable_Params params {};
		params.DataTable = DataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DA60
	 * 		Name   -> Function DreadGame.YGoalManager.Initialized
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYGoalManager::Initialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.Initialized");
		
		UYGoalManager_Initialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D210
	 * 		Name   -> Function DreadGame.YGoalManager.Initialize
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGoalManager::Initialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.Initialize");
		
		UYGoalManager_Initialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BCF0
	 * 		Name   -> Function DreadGame.YGoalManager.HandleOnPlayerControllerSet
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPlayerControllerBase*                      PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGoalManager::HandleOnPlayerControllerSet(class AYPlayerControllerBase* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.HandleOnPlayerControllerSet");
		
		UYGoalManager_HandleOnPlayerControllerSet_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753110
	 * 		Name   -> Function DreadGame.YGoalManager.GetLastClaimedStageNumber
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        goalId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYGoalManager::GetLastClaimedStageNumber(const class FName& goalId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.GetLastClaimedStageNumber");
		
		UYGoalManager_GetLastClaimedStageNumber_Params params {};
		params.goalId = goalId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751C30
	 * 		Name   -> Function DreadGame.YGoalManager.GetFirstUnclaimedGoalId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName UYGoalManager::GetFirstUnclaimedGoalId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.GetFirstUnclaimedGoalId");
		
		UYGoalManager_GetFirstUnclaimedGoalId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744700
	 * 		Name   -> Function DreadGame.YGoalManager.ClaimGoalSucceeded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            stage                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGoalManager::ClaimGoalSucceeded(const class FString& ID, int32_t stage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.ClaimGoalSucceeded");
		
		UYGoalManager_ClaimGoalSucceeded_Params params {};
		params.ID = ID;
		params.stage = stage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007445D0
	 * 		Name   -> Function DreadGame.YGoalManager.ClaimGoalFailed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            stage                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGoalManager::ClaimGoalFailed(const class FString& ID, int32_t stage, const class FString& Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGoalManager.ClaimGoalFailed");
		
		UYGoalManager_ClaimGoalFailed_Params params {};
		params.ID = ID;
		params.stage = stage;
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGoalManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGoalManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGoalManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDreadnoughtLocalPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDreadnoughtLocalPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDreadnoughtLocalPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YNPCAIController.TickBehavior
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYNPCAIController::TickBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.TickBehavior");
		
		AYNPCAIController_TickBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B4F0
	 * 		Name   -> Function DreadGame.YNPCAIController.SetSuspendFire
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               suspendFire                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               suspendFireAbilities                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetSuspendFire(bool suspendFire, bool suspendFireAbilities)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetSuspendFire");
		
		AYNPCAIController_SetSuspendFire_Params params {};
		params.suspendFire = suspendFire;
		params.suspendFireAbilities = suspendFireAbilities;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B370
	 * 		Name   -> Function DreadGame.YNPCAIController.SetStandBehaviorOnPos
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYCreepNavigation*                           standLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetStandBehaviorOnPos(class AYCreepNavigation* standLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetStandBehaviorOnPos");
		
		AYNPCAIController_SetStandBehaviorOnPos_Params params {};
		params.standLocation = standLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B350
	 * 		Name   -> Function DreadGame.YNPCAIController.SetStandBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYNPCAIController::SetStandBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetStandBehavior");
		
		AYNPCAIController_SetStandBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B2D0
	 * 		Name   -> Function DreadGame.YNPCAIController.SetSpotBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetSpotBehavior(class AYPawn* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetSpotBehavior");
		
		AYNPCAIController_SetSpotBehavior_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AF40
	 * 		Name   -> Function DreadGame.YNPCAIController.SetSkirmishBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetSkirmishBehavior(class AYPawn* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetSkirmishBehavior");
		
		AYNPCAIController_SetSkirmishBehavior_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A920
	 * 		Name   -> Function DreadGame.YNPCAIController.SetRunBehaviourTree
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetRunBehaviourTree(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetRunBehaviourTree");
		
		AYNPCAIController_SetRunBehaviourTree_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A640
	 * 		Name   -> Function DreadGame.YNPCAIController.SetProperties
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      newProperties                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetProperties(class UClass* newProperties)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetProperties");
		
		AYNPCAIController_SetProperties_Params params {};
		params.newProperties = newProperties;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778F60
	 * 		Name   -> Function DreadGame.YNPCAIController.SetNewFlightPlan
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FVector>                             newFP                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		float                                              addToReplanTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetNewFlightPlan(TArray<struct FVector> newFP, float addToReplanTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetNewFlightPlan");
		
		AYNPCAIController_SetNewFlightPlan_Params params {};
		params.newFP = newFP;
		params.addToReplanTime = addToReplanTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778D50
	 * 		Name   -> Function DreadGame.YNPCAIController.SetMaxFireDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetMaxFireDistance(float newDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetMaxFireDistance");
		
		AYNPCAIController_SetMaxFireDistance_Params params {};
		params.newDistance = newDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778150
	 * 		Name   -> Function DreadGame.YNPCAIController.SetHideBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYNPCAIController::SetHideBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetHideBehavior");
		
		AYNPCAIController_SetHideBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777710
	 * 		Name   -> Function DreadGame.YNPCAIController.SetFiresAbility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               use                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetFiresAbility(int32_t index, bool use)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetFiresAbility");
		
		AYNPCAIController_SetFiresAbility_Params params {};
		params.index = index;
		params.use = use;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777680
	 * 		Name   -> Function DreadGame.YNPCAIController.SetFiresAbilities
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               use                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetFiresAbilities(bool use)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetFiresAbilities");
		
		AYNPCAIController_SetFiresAbilities_Params params {};
		params.use = use;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777600
	 * 		Name   -> Function DreadGame.YNPCAIController.SetFireAtActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      newTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetFireAtActor(class AActor* newTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetFireAtActor");
		
		AYNPCAIController_SetFireAtActor_Params params {};
		params.newTarget = newTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777530
	 * 		Name   -> Function DreadGame.YNPCAIController.SetFavorWeaponFireAtPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      newTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               swapToNewTargetImmediately                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetFavorWeaponFireAtPawn(class AYPawn* newTarget, bool swapToNewTargetImmediately)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetFavorWeaponFireAtPawn");
		
		AYNPCAIController_SetFavorWeaponFireAtPawn_Params params {};
		params.newTarget = newTarget;
		params.swapToNewTargetImmediately = swapToNewTargetImmediately;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007773F0
	 * 		Name   -> Function DreadGame.YNPCAIController.SetFavorAbilityFireAtPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      newTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetFavorAbilityFireAtPawn(class AYPawn* newTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetFavorAbilityFireAtPawn");
		
		AYNPCAIController_SetFavorAbilityFireAtPawn_Params params {};
		params.newTarget = newTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007772E0
	 * 		Name   -> Function DreadGame.YNPCAIController.SetEvasiveUpDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               enable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetEvasiveUpDown(bool enable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetEvasiveUpDown");
		
		AYNPCAIController_SetEvasiveUpDown_Params params {};
		params.enable = enable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777260
	 * 		Name   -> Function DreadGame.YNPCAIController.SetEscortShyBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetEscortShyBehavior(class AYPawn* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetEscortShyBehavior");
		
		AYNPCAIController_SetEscortShyBehavior_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007771E0
	 * 		Name   -> Function DreadGame.YNPCAIController.SetEngageBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SetEngageBehavior(class AYPawn* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetEngageBehavior");
		
		AYNPCAIController_SetEngageBehavior_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775C30
	 * 		Name   -> Function DreadGame.YNPCAIController.SetAvoidBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYNPCAIController::SetAvoidBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SetAvoidBehavior");
		
		AYNPCAIController_SetAvoidBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770C70
	 * 		Name   -> Function DreadGame.YNPCAIController.SendShortCommandToPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUIShortCommands                                  shortCmd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::SendShortCommandToPlayer(EYUIShortCommands shortCmd, class AYPawn* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.SendShortCommandToPlayer");
		
		AYNPCAIController_SendShortCommandToPlayer_Params params {};
		params.shortCmd = shortCmd;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E9F0
	 * 		Name   -> Function DreadGame.YNPCAIController.RemoteControl
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              TurnRight                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              vertical                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              throttle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYNPCAIController::RemoteControl(float TurnRight, float vertical, float throttle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.RemoteControl");
		
		AYNPCAIController_RemoteControl_Params params {};
		params.TurnRight = TurnRight;
		params.vertical = vertical;
		params.throttle = throttle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EFE0
	 * 		Name   -> Function DreadGame.YNPCAIController.IsInOrbit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYNPCAIController::IsInOrbit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.IsInOrbit");
		
		AYNPCAIController_IsInOrbit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E4B0
	 * 		Name   -> Function DreadGame.YNPCAIController.IsCurrentBehaviour
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYCombatSceneBehavior                              behaviour                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYNPCAIController::IsCurrentBehaviour(EYCombatSceneBehavior behaviour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.IsCurrentBehaviour");
		
		AYNPCAIController_IsCurrentBehaviour_Params params {};
		params.behaviour = behaviour;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759670
	 * 		Name   -> Function DreadGame.YNPCAIController.GetTargetedByCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               withCreeps                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t AYNPCAIController::GetTargetedByCount(bool withCreeps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetTargetedByCount");
		
		AYNPCAIController_GetTargetedByCount_Params params {};
		params.withCreeps = withCreeps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756730
	 * 		Name   -> Function DreadGame.YNPCAIController.GetPerceptedIsolatedEnemyInRange
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              isolatedRange                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetPerceptedIsolatedEnemyInRange(float range, float isolatedRange, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetPerceptedIsolatedEnemyInRange");
		
		AYNPCAIController_GetPerceptedIsolatedEnemyInRange_Params params {};
		params.range = range;
		params.isolatedRange = isolatedRange;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756500
	 * 		Name   -> Function DreadGame.YNPCAIController.GetPerceptedEnemiesInRange
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> AYNPCAIController::GetPerceptedEnemiesInRange(float range, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetPerceptedEnemiesInRange");
		
		AYNPCAIController_GetPerceptedEnemiesInRange_Params params {};
		params.range = range;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007562E0
	 * 		Name   -> Function DreadGame.YNPCAIController.GetPerceptedEnemies
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> AYNPCAIController::GetPerceptedEnemies(bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetPerceptedEnemies");
		
		AYNPCAIController_GetPerceptedEnemies_Params params {};
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007560D0
	 * 		Name   -> Function DreadGame.YNPCAIController.GetPerceptedAlliesInRange
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> AYNPCAIController::GetPerceptedAlliesInRange(float range, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetPerceptedAlliesInRange");
		
		AYNPCAIController_GetPerceptedAlliesInRange_Params params {};
		params.range = range;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755F00
	 * 		Name   -> Function DreadGame.YNPCAIController.GetPerceptedAllies
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> AYNPCAIController::GetPerceptedAllies(bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetPerceptedAllies");
		
		AYNPCAIController_GetPerceptedAllies_Params params {};
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754C40
	 * 		Name   -> Function DreadGame.YNPCAIController.GetMostTargetedPerceptedEnemy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetMostTargetedPerceptedEnemy(float range, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetMostTargetedPerceptedEnemy");
		
		AYNPCAIController_GetMostTargetedPerceptedEnemy_Params params {};
		params.range = range;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754A60
	 * 		Name   -> Function DreadGame.YNPCAIController.GetMostDamagedPerceptedEnemy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetMostDamagedPerceptedEnemy(float range, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetMostDamagedPerceptedEnemy");
		
		AYNPCAIController_GetMostDamagedPerceptedEnemy_Params params {};
		params.range = range;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754870
	 * 		Name   -> Function DreadGame.YNPCAIController.GetMostDamagedPerceptedAllyOfBaseClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<EYShipBaseClass>                            baseclassList                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetMostDamagedPerceptedAllyOfBaseClass(TArray<EYShipBaseClass> baseclassList, float range, bool weaponTarget, bool abilityTarget, bool behaviorTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetMostDamagedPerceptedAllyOfBaseClass");
		
		AYNPCAIController_GetMostDamagedPerceptedAllyOfBaseClass_Params params {};
		params.baseclassList = baseclassList;
		params.range = range;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007546A0
	 * 		Name   -> Function DreadGame.YNPCAIController.GetMostDamagedPerceptedAlly
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetMostDamagedPerceptedAlly(float range, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetMostDamagedPerceptedAlly");
		
		AYNPCAIController_GetMostDamagedPerceptedAlly_Params params {};
		params.range = range;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750630
	 * 		Name   -> Function DreadGame.YNPCAIController.GetCurrentBehaviourTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYPawn* AYNPCAIController::GetCurrentBehaviourTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetCurrentBehaviourTarget");
		
		AYNPCAIController_GetCurrentBehaviourTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750030
	 * 		Name   -> Function DreadGame.YNPCAIController.GetCommandShip
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               searchAllied                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               hasLineOfSight                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetCommandShip(bool searchAllied, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool* hasLineOfSight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetCommandShip");
		
		AYNPCAIController_GetCommandShip_Params params {};
		params.searchAllied = searchAllied;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (hasLineOfSight != nullptr)
			*hasLineOfSight = params.hasLineOfSight;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074FD80
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestStaticPerceptedEnemy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxSpeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestStaticPerceptedEnemy(float range, float MaxSpeed, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestStaticPerceptedEnemy");
		
		AYNPCAIController_GetClosestStaticPerceptedEnemy_Params params {};
		params.range = range;
		params.MaxSpeed = MaxSpeed;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074FA70
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestPerceptedEnemyOfClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipClass                                        baseclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestPerceptedEnemyOfClass(EYShipClass baseclass, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestPerceptedEnemyOfClass");
		
		AYNPCAIController_GetClosestPerceptedEnemyOfClass_Params params {};
		params.baseclass = baseclass;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074F8B0
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestPerceptedEnemyOfBaseClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipBaseClass                                    baseclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestPerceptedEnemyOfBaseClass(EYShipBaseClass baseclass, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestPerceptedEnemyOfBaseClass");
		
		AYNPCAIController_GetClosestPerceptedEnemyOfBaseClass_Params params {};
		params.baseclass = baseclass;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074F6D0
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestPerceptedEnemyInRange
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestPerceptedEnemyInRange(float range, bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestPerceptedEnemyInRange");
		
		AYNPCAIController_GetClosestPerceptedEnemyInRange_Params params {};
		params.range = range;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074F500
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestPerceptedEnemy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeCloaked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestPerceptedEnemy(bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeCloaked, bool includeAITargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestPerceptedEnemy");
		
		AYNPCAIController_GetClosestPerceptedEnemy_Params params {};
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeCloaked = includeCloaked;
		params.includeAITargets = includeAITargets;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074F390
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestPerceptedAllyOfClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipClass                                        baseclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestPerceptedAllyOfClass(EYShipClass baseclass, bool weaponTarget, bool abilityTarget, bool behaviorTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestPerceptedAllyOfClass");
		
		AYNPCAIController_GetClosestPerceptedAllyOfClass_Params params {};
		params.baseclass = baseclass;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074F220
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestPerceptedAllyOfBaseClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipBaseClass                                    baseclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestPerceptedAllyOfBaseClass(EYShipBaseClass baseclass, bool weaponTarget, bool abilityTarget, bool behaviorTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestPerceptedAllyOfBaseClass");
		
		AYNPCAIController_GetClosestPerceptedAllyOfBaseClass_Params params {};
		params.baseclass = baseclass;
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074F040
	 * 		Name   -> Function DreadGame.YNPCAIController.GetClosestPerceptedAlly
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               weaponTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               abilityTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               behaviorTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               includeAITargets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               excludeJetFighter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               excludeScouts                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AYPawn* AYNPCAIController::GetClosestPerceptedAlly(bool weaponTarget, bool abilityTarget, bool behaviorTarget, bool includeAITargets, bool excludeJetFighter, bool excludeScouts)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetClosestPerceptedAlly");
		
		AYNPCAIController_GetClosestPerceptedAlly_Params params {};
		params.weaponTarget = weaponTarget;
		params.abilityTarget = abilityTarget;
		params.behaviorTarget = behaviorTarget;
		params.includeAITargets = includeAITargets;
		params.excludeJetFighter = excludeJetFighter;
		params.excludeScouts = excludeScouts;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DCB0
	 * 		Name   -> Function DreadGame.YNPCAIController.GetBehaviourTargetedByCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               withCreeps                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             excludeTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYNPCAIController::GetBehaviourTargetedByCount(bool withCreeps, EYTeam excludeTeam, class AYPawn* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetBehaviourTargetedByCount");
		
		AYNPCAIController_GetBehaviourTargetedByCount_Params params {};
		params.withCreeps = withCreeps;
		params.excludeTeam = excludeTeam;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CA90
	 * 		Name   -> Function DreadGame.YNPCAIController.GetAIDifficultyLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYAILevel AYNPCAIController::GetAIDifficultyLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetAIDifficultyLevel");
		
		AYNPCAIController_GetAIDifficultyLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CB40
	 * 		Name   -> Function DreadGame.YNPCAIController.GetAbilityCurrentCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AYNPCAIController::GetAbilityCurrentCooldown(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.GetAbilityCurrentCooldown");
		
		AYNPCAIController_GetAbilityCurrentCooldown_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784F90
	 * 		Name   -> Function DreadGame.YNPCAIController.currentBehaviourRequiresTargetPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYNPCAIController::currentBehaviourRequiresTargetPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.currentBehaviourRequiresTargetPawn");
		
		AYNPCAIController_currentBehaviourRequiresTargetPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784F60
	 * 		Name   -> Function DreadGame.YNPCAIController.currentBehaviourRequiresTargetAllyPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYNPCAIController::currentBehaviourRequiresTargetAllyPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.currentBehaviourRequiresTargetAllyPawn");
		
		AYNPCAIController_currentBehaviourRequiresTargetAllyPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744930
	 * 		Name   -> Function DreadGame.YNPCAIController.ClearPath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYNPCAIController::ClearPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIController.ClearPath");
		
		AYNPCAIController_ClearPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYNPCAIController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYNPCAIController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YNPCAIController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYAIAbilityActivationRulesDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYAIAbilityActivationRulesDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YAIAbilityActivationRulesDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYBattleReadyUpdateRulesDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYBattleReadyUpdateRulesDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBattleReadyUpdateRulesDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYClientBotDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYClientBotDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YClientBotDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGlobalGameplayTuningDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGlobalGameplayTuningDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGlobalGameplayTuningDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDBuffTypeIconDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDBuffTypeIconDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDBuffTypeIconDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDColorStyleDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDColorStyleDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDColorStyleDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDEnergySelectionIconDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDEnergySelectionIconDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDEnergySelectionIconDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDHelperOverlayInstructions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDHelperOverlayInstructions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDHelperOverlayInstructions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDInfoEncountersDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDInfoEncountersDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDInfoEncountersDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDInfoPlanetsDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDInfoPlanetsDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDInfoPlanetsDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDInfoQuestObjectsDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDInfoQuestObjectsDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDInfoQuestObjectsDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDInfoSpacePortsDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDInfoSpacePortsDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDInfoSpacePortsDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDInfoWarpGatesDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDInfoWarpGatesDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDInfoWarpGatesDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDOnboardingDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDOnboardingDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDOnboardingDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDPromptLocalizationDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDPromptLocalizationDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDPromptLocalizationDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDQuestMarkerDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDQuestMarkerDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDQuestMarkerDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDShipClassIconDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDShipClassIconDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDShipClassIconDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDShortCommandIconDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDShortCommandIconDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDShortCommandIconDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDTeamEliminationIconDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDTeamEliminationIconDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDTeamEliminationIconDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMENUModuleVideoDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMENUModuleVideoDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMENUModuleVideoDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPItemDropDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPItemDropDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPItemDropDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYRankDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYRankDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YRankDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSubtitlesDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSubtitlesDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSubtitlesDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVOInfoDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVOInfoDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVOInfoDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWeaponGroupDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWeaponGroupDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeaponGroupDataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDefaultMediaPlayer_Widget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDefaultMediaPlayer_Widget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDefaultMediaPlayer_Widget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D880
	 * 		Name   -> Function DreadGame.YDefendScoringController.InitializeScoringFromDataTable
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDataTable*                                  DataTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYDefendScoringController::InitializeScoringFromDataTable(class UDataTable* DataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDefendScoringController.InitializeScoringFromDataTable");
		
		UYDefendScoringController_InitializeScoringFromDataTable_Params params {};
		params.DataTable = DataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757D00
	 * 		Name   -> Function DreadGame.YDefendScoringController.GetScore
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        objectID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FYDefendScoringResult UYDefendScoringController::GetScore(const class FName& objectID, int32_t Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDefendScoringController.GetScore");
		
		UYDefendScoringController_GetScore_Params params {};
		params.objectID = objectID;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDefendScoringController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDefendScoringController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDefendScoringController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766400
	 * 		Name   -> Function DreadGame.YProximityMineActor.OnOverlap
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProximityMineActor::OnOverlap(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProximityMineActor.OnOverlap");
		
		AYProximityMineActor_OnOverlap_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProximityMineActor.OnMineExploded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProximityMineActor::OnMineExploded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProximityMineActor.OnMineExploded");
		
		AYProximityMineActor_OnMineExploded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProximityMineActor.OnMineActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              countdown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProximityMineActor::OnMineActivated(float countdown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProximityMineActor.OnMineActivated");
		
		AYProximityMineActor_OnMineActivated_Params params {};
		params.countdown = countdown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProximityMineActor.OnDealDamageToPawn
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      hitPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProximityMineActor::OnDealDamageToPawn(class AYPawn* hitPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProximityMineActor.OnDealDamageToPawn");
		
		AYProximityMineActor_OnDealDamageToPawn_Params params {};
		params.hitPawn = hitPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745370
	 * 		Name   -> Function DreadGame.YProximityMineActor.ClientExplodeMine
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		TArray<class AYPawn*>                              hitPawns                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYProximityMineActor::ClientExplodeMine(TArray<class AYPawn*> hitPawns)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProximityMineActor.ClientExplodeMine");
		
		AYProximityMineActor_ClientExplodeMine_Params params {};
		params.hitPawns = hitPawns;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744AD0
	 * 		Name   -> Function DreadGame.YProximityMineActor.ClientActivateMine
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 */
	void AYProximityMineActor::ClientActivateMine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProximityMineActor.ClientActivateMine");
		
		AYProximityMineActor_ClientActivateMine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYProximityMineActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYProximityMineActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProximityMineActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007801D0
	 * 		Name   -> Function DreadGame.YTurretActor.StopFireMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AYTurretActor::StopFireMulticast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YTurretActor.StopFireMulticast");
		
		AYTurretActor_StopFireMulticast_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C460
	 * 		Name   -> Function DreadGame.YTurretActor.FireMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class AActor*                                      fireTarget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            projectileID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            randomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYTurretActor::FireMulticast(class AActor* fireTarget, int32_t projectileID, int32_t randomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YTurretActor.FireMulticast");
		
		AYTurretActor_FireMulticast_Params params {};
		params.fireTarget = fireTarget;
		params.projectileID = projectileID;
		params.randomSeed = randomSeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYTurretActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYTurretActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YTurretActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F0B0
	 * 		Name   -> Function DreadGame.YDNSearchManager.ReplaceActiveSearchManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYDNSearchManager*                           newSearchmanager                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYDNSearchManager::ReplaceActiveSearchManager(class AYDNSearchManager* newSearchmanager)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDNSearchManager.ReplaceActiveSearchManager");
		
		AYDNSearchManager_ReplaceActiveSearchManager_Params params {};
		params.newSearchmanager = newSearchmanager;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751EA0
	 * 		Name   -> Function DreadGame.YDNSearchManager.GetFreeWorldCoordinates
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     worldCoordinates                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            tunnelSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AYDNSearchManager::GetFreeWorldCoordinates(const struct FVector& worldCoordinates, int32_t tunnelSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDNSearchManager.GetFreeWorldCoordinates");
		
		AYDNSearchManager_GetFreeWorldCoordinates_Params params {};
		params.worldCoordinates = worldCoordinates;
		params.tunnelSize = tunnelSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751DB0
	 * 		Name   -> Function DreadGame.YDNSearchManager.GetFreeTileCoordinates
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     worldCoordinates                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            tunnelSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AYDNSearchManager::GetFreeTileCoordinates(const struct FVector& worldCoordinates, int32_t tunnelSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YDNSearchManager.GetFreeTileCoordinates");
		
		AYDNSearchManager_GetFreeTileCoordinates_Params params {};
		params.worldCoordinates = worldCoordinates;
		params.tunnelSize = tunnelSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYDNSearchManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYDNSearchManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDNSearchManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDreadnoughtSingleton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDreadnoughtSingleton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDreadnoughtSingleton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchDataManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchDataManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchDataManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDummyStatsPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDummyStatsPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDummyStatsPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDummyMvpPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDummyMvpPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDummyMvpPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDummyRewardsPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDummyRewardsPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDummyRewardsPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYDummyScoreboard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYDummyScoreboard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDummyScoreboard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchActivateInputStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchActivateInputStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchActivateInputStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchAsyncLoadContentBaseStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchAsyncLoadContentBaseStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchAsyncLoadContentBaseStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchAsyncLoadContentPveStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchAsyncLoadContentPveStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchAsyncLoadContentPveStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchAsyncLoadContentPvpStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchAsyncLoadContentPvpStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchAsyncLoadContentPvpStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchFadeFromBlackStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchFadeFromBlackStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchFadeFromBlackStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchFadeToBlackStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchFadeToBlackStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchFadeToBlackStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchInitStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchInitStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchInitStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchLoadLevelStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchLoadLevelStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchLoadLevelStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A3D0
	 * 		Name   -> Function DreadGame.YEndOfMatchNonSkippableStatsStage.OnSequenceFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYEndOfMatchNonSkippableStatsStage::OnSequenceFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchNonSkippableStatsStage.OnSequenceFinished");
		
		UYEndOfMatchNonSkippableStatsStage_OnSequenceFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchNonSkippableStatsStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchNonSkippableStatsStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchNonSkippableStatsStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchSetupSceneBaseStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchSetupSceneBaseStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchSetupSceneBaseStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchSetupScenePveStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchSetupScenePveStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchSetupScenePveStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchSetupScenePvpStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchSetupScenePvpStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchSetupScenePvpStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchSetupUIWidgetsStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchSetupUIWidgetsStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchSetupUIWidgetsStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchSetupPveUIWidgetsStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchSetupPveUIWidgetsStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchSetupPveUIWidgetsStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchSetupPvpUIWidgetsStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchSetupPvpUIWidgetsStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchSetupPvpUIWidgetsStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchUIBaseStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchUIBaseStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchUIBaseStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchBlurSwapStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchBlurSwapStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchBlurSwapStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchCameraSwapStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchCameraSwapStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchCameraSwapStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchSkippableTabScreenStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchSkippableTabScreenStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchSkippableTabScreenStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A3B0
	 * 		Name   -> Function DreadGame.YEndOfMatchNonSkippableMvpStage.OnSequenceFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYEndOfMatchNonSkippableMvpStage::OnSequenceFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchNonSkippableMvpStage.OnSequenceFinished");
		
		UYEndOfMatchNonSkippableMvpStage_OnSequenceFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762460
	 * 		Name   -> Function DreadGame.YEndOfMatchNonSkippableMvpStage.OnAnimEventTriggered
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      EventName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchNonSkippableMvpStage::OnAnimEventTriggered(const class FString& EventName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchNonSkippableMvpStage.OnAnimEventTriggered");
		
		UYEndOfMatchNonSkippableMvpStage_OnAnimEventTriggered_Params params {};
		params.EventName = EventName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchNonSkippableMvpStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchNonSkippableMvpStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchNonSkippableMvpStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchNoSkipMvpStage_Custom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchNoSkipMvpStage_Custom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchNoSkipMvpStage_Custom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchPveRewardsPageAnimatedStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchPveRewardsPageAnimatedStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchPveRewardsPageAnimatedStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchPveScorePageAnimatedStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchPveScorePageAnimatedStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchPveScorePageAnimatedStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A3F0
	 * 		Name   -> Function DreadGame.YEndOfMatchPveTeamPageNonSkippableStage.OnSequenceFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYEndOfMatchPveTeamPageNonSkippableStage::OnSequenceFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchPveTeamPageNonSkippableStage.OnSequenceFinished");
		
		UYEndOfMatchPveTeamPageNonSkippableStage_OnSequenceFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762550
	 * 		Name   -> Function DreadGame.YEndOfMatchPveTeamPageNonSkippableStage.OnAnimEventTriggered
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      EventName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchPveTeamPageNonSkippableStage::OnAnimEventTriggered(const class FString& EventName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchPveTeamPageNonSkippableStage.OnAnimEventTriggered");
		
		UYEndOfMatchPveTeamPageNonSkippableStage_OnAnimEventTriggered_Params params {};
		params.EventName = EventName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchPveTeamPageNonSkippableStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchPveTeamPageNonSkippableStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchPveTeamPageNonSkippableStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchRewardsPageAnimatedStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchRewardsPageAnimatedStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchRewardsPageAnimatedStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStatsPageAnimatedStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStatsPageAnimatedStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStatsPageAnimatedStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStaticTabScreenStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStaticTabScreenStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStaticTabScreenStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchMvpStaticStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchMvpStaticStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchMvpStaticStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchPveTeamPageStaticStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchPveTeamPageStaticStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchPveTeamPageStaticStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchScoreboardStaticStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchScoreboardStaticStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchScoreboardStaticStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AC00
	 * 		Name   -> Function DreadGame.YEndOfMatchUnloadSublevelsStage.OnSublevelsUnloadedContinuation
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UYPlayerOrbitComponent*                      orbitComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchUnloadSublevelsStage::OnSublevelsUnloadedContinuation(class UYPlayerOrbitComponent* orbitComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchUnloadSublevelsStage.OnSublevelsUnloadedContinuation");
		
		UYEndOfMatchUnloadSublevelsStage_OnSublevelsUnloadedContinuation_Params params {};
		params.orbitComp = orbitComp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchUnloadSublevelsStage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchUnloadSublevelsStage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchUnloadSublevelsStage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStageGraph.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStageGraph::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStageGraph");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStagingManagerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStagingManagerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStagingManagerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStagingManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStagingManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStagingManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStagingManager_Custom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStagingManager_Custom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStagingManager_Custom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchStagingManagerPve.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchStagingManagerPve::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchStagingManagerPve");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EB00
	 * 		Name   -> Function DreadGame.YGameplayAttributeComponent.RemoveAttributeModifer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      modifierIdentifier                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeComponent::RemoveAttributeModifer(const class FString& modifierIdentifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeComponent.RemoveAttributeModifer");
		
		UYGameplayAttributeComponent_RemoveAttributeModifer_Params params {};
		params.modifierIdentifier = modifierIdentifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E370
	 * 		Name   -> Function DreadGame.YGameplayAttributeComponent.QueryAttributeForValue
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        attributeName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYKismetGameplayConditionQueryContext*       queryContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              attributeValue                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYGameplayAttributeComponent::QueryAttributeForValue(const class FName& attributeName, class UYKismetGameplayConditionQueryContext* queryContext, float* attributeValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeComponent.QueryAttributeForValue");
		
		UYGameplayAttributeComponent_QueryAttributeForValue_Params params {};
		params.attributeName = attributeName;
		params.queryContext = queryContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (attributeValue != nullptr)
			*attributeValue = params.attributeValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E190
	 * 		Name   -> Function DreadGame.YGameplayAttributeComponent.QueryAttributeForModifierValues
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        attributeName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYKismetGameplayConditionQueryContext*       queryContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              addModifierValue                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              percentageModifierValue                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              outGlobalPercentageModifierValue                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYGameplayAttributeComponent::QueryAttributeForModifierValues(const class FName& attributeName, class UYKismetGameplayConditionQueryContext* queryContext, float* addModifierValue, float* percentageModifierValue, float* outGlobalPercentageModifierValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeComponent.QueryAttributeForModifierValues");
		
		UYGameplayAttributeComponent_QueryAttributeForModifierValues_Params params {};
		params.attributeName = attributeName;
		params.queryContext = queryContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (addModifierValue != nullptr)
			*addModifierValue = params.addModifierValue;
		if (percentageModifierValue != nullptr)
			*percentageModifierValue = params.percentageModifierValue;
		if (outGlobalPercentageModifierValue != nullptr)
			*outGlobalPercentageModifierValue = params.outGlobalPercentageModifierValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007492A0
	 * 		Name   -> Function DreadGame.YGameplayAttributeComponent.CreateQueryContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYKismetGameplayConditionQueryContext* UYGameplayAttributeComponent::CreateQueryContext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeComponent.CreateQueryContext");
		
		UYGameplayAttributeComponent_CreateQueryContext_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740BB0
	 * 		Name   -> Function DreadGame.YGameplayAttributeComponent.AdjustValueByAttribute
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        attributeName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYKismetGameplayConditionQueryContext*       queryContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              outValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYGameplayAttributeComponent::AdjustValueByAttribute(const class FName& attributeName, float InValue, class UYKismetGameplayConditionQueryContext* queryContext, float* outValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeComponent.AdjustValueByAttribute");
		
		UYGameplayAttributeComponent_AdjustValueByAttribute_Params params {};
		params.attributeName = attributeName;
		params.InValue = InValue;
		params.queryContext = queryContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outValue != nullptr)
			*outValue = params.outValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E250
	 * 		Name   -> Function DreadGame.YGameplayAttributeComponent.AddAttributeModifer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      constructionString                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      modifierIdentifier                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYGameplayAttributeComponent::AddAttributeModifer(const class FString& constructionString, const class FString& modifierIdentifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeComponent.AddAttributeModifer");
		
		UYGameplayAttributeComponent_AddAttributeModifer_Params params {};
		params.constructionString = constructionString;
		params.modifierIdentifier = modifierIdentifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E180
	 * 		Name   -> Function DreadGame.YGameplayAttributeComponent.AddAttribute
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        attributeName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              neutralValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeComponent::AddAttribute(const class FName& attributeName, float neutralValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeComponent.AddAttribute");
		
		UYGameplayAttributeComponent_AddAttribute_Params params {};
		params.attributeName = attributeName;
		params.neutralValue = neutralValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameplayAttributeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameplayAttributeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameplayAttributeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007801A0
	 * 		Name   -> Function DreadGame.YEnergyComponent.StopEnergyConsumption
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYEnergyComponent::StopEnergyConsumption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.StopEnergyConsumption");
		
		UYEnergyComponent_StopEnergyConsumption_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FBA0
	 * 		Name   -> Function DreadGame.YEnergyComponent.StartEnergyConsumption
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYEnergyComponent::StartEnergyConsumption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.StartEnergyConsumption");
		
		UYEnergyComponent_StartEnergyConsumption_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769360
	 * 		Name   -> Function DreadGame.YEnergyComponent.OnRep_energySystemState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYEnergyComponent::OnRep_energySystemState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.OnRep_energySystemState");
		
		UYEnergyComponent_OnRep_energySystemState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768CC0
	 * 		Name   -> Function DreadGame.YEnergyComponent.OnRep_Energy
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYEnergyComponent::OnRep_Energy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.OnRep_Energy");
		
		UYEnergyComponent_OnRep_Energy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766E60
	 * 		Name   -> Function DreadGame.YEnergyComponent.OnOwningPawnDied
	 * 		Flags  -> (Final, Native, Private, HasDefaults)
	 * Parameters:
	 * 		float                                              ActualDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         FHitComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Momentum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEnergyComponent::OnOwningPawnDied(float ActualDamage, class AController* Killer, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, const class FName& BoneName, const struct FVector& Momentum, class UDamageType* DamageType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.OnOwningPawnDied");
		
		UYEnergyComponent_OnOwningPawnDied_Params params {};
		params.ActualDamage = ActualDamage;
		params.Killer = Killer;
		params.HitLocation = HitLocation;
		params.FHitComponent = FHitComponent;
		params.BoneName = BoneName;
		params.Momentum = Momentum;
		params.DamageType = DamageType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760FE0
	 * 		Name   -> Function DreadGame.YEnergyComponent.ModifyEnergy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              energyModifier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEnergyComponent::ModifyEnergy(float energyModifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.ModifyEnergy");
		
		UYEnergyComponent_ModifyEnergy_Params params {};
		params.energyModifier = energyModifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DD50
	 * 		Name   -> Function DreadGame.YEnergyComponent.InterruptEnergyRegeneration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYEnergyComponent::InterruptEnergyRegeneration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.InterruptEnergyRegeneration");
		
		UYEnergyComponent_InterruptEnergyRegeneration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C340
	 * 		Name   -> Function DreadGame.YEnergyComponent.HasEnergy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYEnergyComponent::HasEnergy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.HasEnergy");
		
		UYEnergyComponent_HasEnergy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759330
	 * 		Name   -> Function DreadGame.YEnergyComponent.GetState
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	EYEnergySystemState UYEnergyComponent::GetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.GetState");
		
		UYEnergyComponent_GetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753F40
	 * 		Name   -> Function DreadGame.YEnergyComponent.GetMaxEnergy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYEnergyComponent::GetMaxEnergy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.GetMaxEnergy");
		
		UYEnergyComponent_GetMaxEnergy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751880
	 * 		Name   -> Function DreadGame.YEnergyComponent.GetEnergyRegenerationRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYEnergyComponent::GetEnergyRegenerationRate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.GetEnergyRegenerationRate");
		
		UYEnergyComponent_GetEnergyRegenerationRate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751850
	 * 		Name   -> Function DreadGame.YEnergyComponent.GetEnergyConsumptionRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYEnergyComponent::GetEnergyConsumptionRate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.GetEnergyConsumptionRate");
		
		UYEnergyComponent_GetEnergyConsumptionRate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751820
	 * 		Name   -> Function DreadGame.YEnergyComponent.GetEnergy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYEnergyComponent::GetEnergy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyComponent.GetEnergy");
		
		UYEnergyComponent_GetEnergy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEnergyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEnergyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEnergyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEnergyShield.ReceiveShieldDestroyed
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 */
	void AYEnergyShield::ReceiveShieldDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.ReceiveShieldDestroyed");
		
		AYEnergyShield_ReceiveShieldDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEnergyShield.ReceiveAnyHealth
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              HealthAmt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      HealthCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYEnergyShield::ReceiveAnyHealth(float HealthAmt, class AController* InstigatedBy, class AActor* HealthCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.ReceiveAnyHealth");
		
		AYEnergyShield_ReceiveAnyHealth_Params params {};
		params.HealthAmt = HealthAmt;
		params.InstigatedBy = InstigatedBy;
		params.HealthCauser = HealthCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEnergyShield.OnShieldMeshSet
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
	 */
	void AYEnergyShield::OnShieldMeshSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.OnShieldMeshSet");
		
		AYEnergyShield_OnShieldMeshSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007693A0
	 * 		Name   -> Function DreadGame.YEnergyShield.OnRep_isDestroyed
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYEnergyShield::OnRep_isDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.OnRep_isDestroyed");
		
		AYEnergyShield_OnRep_isDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007622B0
	 * 		Name   -> Function DreadGame.YEnergyShield.OnActiveEnergyWheelFunctionChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             activeEnergyWheelFunction                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYEnergyShield::OnActiveEnergyWheelFunctionChanged(EYEnergyWheelSelection activeEnergyWheelFunction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.OnActiveEnergyWheelFunctionChanged");
		
		AYEnergyShield_OnActiveEnergyWheelFunctionChanged_Params params {};
		params.activeEnergyWheelFunction = activeEnergyWheelFunction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F990
	 * 		Name   -> Function DreadGame.YEnergyShield.IsShieldEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYEnergyShield::IsShieldEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.IsShieldEnabled");
		
		AYEnergyShield_IsShieldEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007580A0
	 * 		Name   -> Function DreadGame.YEnergyShield.GetShieldDataRow
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYEnergyShieldDataTableRow                  rowOut                                                     (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool AYEnergyShield::GetShieldDataRow(const class FName& Name, struct FYEnergyShieldDataTableRow* rowOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.GetShieldDataRow");
		
		AYEnergyShield_GetShieldDataRow_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (rowOut != nullptr)
			*rowOut = params.rowOut;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755A90
	 * 		Name   -> Function DreadGame.YEnergyShield.GetOwningPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYPawn* AYEnergyShield::GetOwningPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.GetOwningPawn");
		
		AYEnergyShield_GetOwningPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753F70
	 * 		Name   -> Function DreadGame.YEnergyShield.GetMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AYEnergyShield::GetMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.GetMaxHealth");
		
		AYEnergyShield_GetMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007525F0
	 * 		Name   -> Function DreadGame.YEnergyShield.GetHealthQuotient
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AYEnergyShield::GetHealthQuotient()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.GetHealthQuotient");
		
		AYEnergyShield_GetHealthQuotient_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752570
	 * 		Name   -> Function DreadGame.YEnergyShield.GetHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AYEnergyShield::GetHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.GetHealth");
		
		AYEnergyShield_GetHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B6A0
	 * 		Name   -> Function DreadGame.YEnergyShield.EnableShield
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYEnergyShield::EnableShield()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.EnableShield");
		
		AYEnergyShield_EnableShield_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AB00
	 * 		Name   -> Function DreadGame.YEnergyShield.DisableShield
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYEnergyShield::DisableShield()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEnergyShield.DisableShield");
		
		AYEnergyShield_DisableShield_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYEnergyShield.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYEnergyShield::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEnergyShield");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEOMWidget_HavocResult.BP_OnUpdateTimeUntilResetText
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        timeUntilReset                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYEOMWidget_HavocResult::BP_OnUpdateTimeUntilResetText(const class FText& timeUntilReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEOMWidget_HavocResult.BP_OnUpdateTimeUntilResetText");
		
		UYEOMWidget_HavocResult_BP_OnUpdateTimeUntilResetText_Params params {};
		params.timeUntilReset = timeUntilReset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEOMWidget_HavocResult.BP_OnUpdateResultLine
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            lineValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               newRecord                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYEOMWidget_HavocResult::BP_OnUpdateResultLine(int32_t index, int32_t lineValue, bool newRecord)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEOMWidget_HavocResult.BP_OnUpdateResultLine");
		
		UYEOMWidget_HavocResult_BP_OnUpdateResultLine_Params params {};
		params.index = index;
		params.lineValue = lineValue;
		params.newRecord = newRecord;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEOMWidget_HavocResult.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEOMWidget_HavocResult::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEOMWidget_HavocResult");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEOMWidget_HavocRewardElement.BP_OnUpdateData
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYUICurrency                                       rewardCurrencyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            scoreRequired                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            rewardAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               rewardUnlocked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               rewardUnlockedThisRound                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYEOMWidget_HavocRewardElement::BP_OnUpdateData(EYUICurrency rewardCurrencyType, int32_t scoreRequired, int32_t rewardAmount, bool rewardUnlocked, bool rewardUnlockedThisRound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEOMWidget_HavocRewardElement.BP_OnUpdateData");
		
		UYEOMWidget_HavocRewardElement_BP_OnUpdateData_Params params {};
		params.rewardCurrencyType = rewardCurrencyType;
		params.scoreRequired = scoreRequired;
		params.rewardAmount = rewardAmount;
		params.rewardUnlocked = rewardUnlocked;
		params.rewardUnlockedThisRound = rewardUnlockedThisRound;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEOMWidget_HavocRewardElement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEOMWidget_HavocRewardElement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEOMWidget_HavocRewardElement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYExplosion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYExplosion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YExplosion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEZProfileHelper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEZProfileHelper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEZProfileHelper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYFactionWrapper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYFactionWrapper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YFactionWrapper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076ED60
	 * 		Name   -> Function DreadGame.YFeatsComponent.RemoveFeatServer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        featName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::RemoveFeatServer(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.RemoveFeatServer");
		
		UYFeatsComponent_RemoveFeatServer_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076ECE0
	 * 		Name   -> Function DreadGame.YFeatsComponent.RemoveFeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        featName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::RemoveFeat(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.RemoveFeat");
		
		UYFeatsComponent_RemoveFeat_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768D00
	 * 		Name   -> Function DreadGame.YFeatsComponent.OnRep_Feats
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYFeatsComponent::OnRep_Feats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.OnRep_Feats");
		
		UYFeatsComponent_OnRep_Feats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007682F0
	 * 		Name   -> Function DreadGame.YFeatsComponent.OnPlayerRespawned
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::OnPlayerRespawned(class AYPlayerController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.OnPlayerRespawned");
		
		UYFeatsComponent_OnPlayerRespawned_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007676A0
	 * 		Name   -> Function DreadGame.YFeatsComponent.OnPawnPossessed
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      YPawn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::OnPawnPossessed(class AYPawn* YPawn, class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.OnPawnPossessed");
		
		UYFeatsComponent_OnPawnPossessed_Params params {};
		params.YPawn = YPawn;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762440
	 * 		Name   -> Function DreadGame.YFeatsComponent.OnAiEnteredMatch
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYFeatsComponent::OnAiEnteredMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.OnAiEnteredMatch");
		
		UYFeatsComponent_OnAiEnteredMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C960
	 * 		Name   -> Function DreadGame.YFeatsComponent.MulticastOnPawnEnteredMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 */
	void UYFeatsComponent::MulticastOnPawnEnteredMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.MulticastOnPawnEnteredMatch");
		
		UYFeatsComponent_MulticastOnPawnEnteredMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C3A0
	 * 		Name   -> Function DreadGame.YFeatsComponent.HasFeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        featName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYFeatsComponent::HasFeat(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.HasFeat");
		
		UYFeatsComponent_HasFeat_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B560
	 * 		Name   -> Function DreadGame.YFeatsComponent.EnableFeatMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        featName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::EnableFeatMulticast(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.EnableFeatMulticast");
		
		UYFeatsComponent_EnableFeatMulticast_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AA50
	 * 		Name   -> Function DreadGame.YFeatsComponent.DisableFeatMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        featName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::DisableFeatMulticast(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.DisableFeatMulticast");
		
		UYFeatsComponent_DisableFeatMulticast_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007498E0
	 * 		Name   -> Function DreadGame.YFeatsComponent.DeactivateFeatMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        featName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::DeactivateFeatMulticast(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.DeactivateFeatMulticast");
		
		UYFeatsComponent_DeactivateFeatMulticast_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073EE80
	 * 		Name   -> Function DreadGame.YFeatsComponent.AddFeatServer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        featName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::AddFeatServer(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.AddFeatServer");
		
		UYFeatsComponent_AddFeatServer_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073EDF0
	 * 		Name   -> Function DreadGame.YFeatsComponent.AddFeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        featName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYFeatsComponent::AddFeat(const class FName& featName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.AddFeat");
		
		UYFeatsComponent_AddFeat_Params params {};
		params.featName = featName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073ED20
	 * 		Name   -> Function DreadGame.YFeatsComponent.AddDataTable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UDataTable*                                  newDataTable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               autoAddfeats                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::AddDataTable(class UDataTable* newDataTable, bool autoAddfeats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.AddDataTable");
		
		UYFeatsComponent_AddDataTable_Params params {};
		params.newDataTable = newDataTable;
		params.autoAddfeats = autoAddfeats;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CFC0
	 * 		Name   -> Function DreadGame.YFeatsComponent.ActivateFeatMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FName                                        featName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        triggerType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      triggerTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Multiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFeatsComponent::ActivateFeatMulticast(const class FName& featName, const class FName& triggerType, class AYPawn* Instigator, class AYPawn* triggerTarget, float Multiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFeatsComponent.ActivateFeatMulticast");
		
		UYFeatsComponent_ActivateFeatMulticast_Params params {};
		params.featName = featName;
		params.triggerType = triggerType;
		params.Instigator = Instigator;
		params.triggerTarget = triggerTarget;
		params.Multiplier = Multiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYFeatsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYFeatsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YFeatsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D9A0
	 * 		Name   -> Function DreadGame.YFleetManager.PlayerDataInitCompleted
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYFleetManager::PlayerDataInitCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.PlayerDataInitCompleted");
		
		UYFleetManager_PlayerDataInitCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnToggleAutoMaintenanceSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnToggleAutoMaintenanceSignature__DelegateSignature(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnToggleAutoMaintenanceSignature__DelegateSignature");
		
		UYFleetManager_OnToggleAutoMaintenanceSignature__DelegateSignature_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AB60
	 * 		Name   -> Function DreadGame.YFleetManager.OnStaticDataInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYFleetManager::OnStaticDataInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.OnStaticDataInitialized");
		
		UYFleetManager_OnStaticDataInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnSkipMaintenanceSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnSkipMaintenanceSignature__DelegateSignature(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnSkipMaintenanceSignature__DelegateSignature");
		
		UYFleetManager_OnSkipMaintenanceSignature__DelegateSignature_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764E50
	 * 		Name   -> Function DreadGame.YFleetManager.OnLocalPlayerAvailable
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYFleetManager::OnLocalPlayerAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.OnLocalPlayerAvailable");
		
		UYFleetManager_OnLocalPlayerAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764D10
	 * 		Name   -> Function DreadGame.YFleetManager.OnLoadoutUpdated
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnLoadoutUpdated(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.OnLoadoutUpdated");
		
		UYFleetManager_OnLoadoutUpdated_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764E30
	 * 		Name   -> Function DreadGame.YFleetManager.OnLoadoutsInstalled
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYFleetManager::OnLoadoutsInstalled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.OnLoadoutsInstalled");
		
		UYFleetManager_OnLoadoutsInstalled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnLoadoutRemovedFromFleetSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnLoadoutRemovedFromFleetSignature__DelegateSignature(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnLoadoutRemovedFromFleetSignature__DelegateSignature");
		
		UYFleetManager_OnLoadoutRemovedFromFleetSignature__DelegateSignature_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764B20
	 * 		Name   -> Function DreadGame.YFleetManager.OnLoadoutDataInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYFleetManager::OnLoadoutDataInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.OnLoadoutDataInitialized");
		
		UYFleetManager_OnLoadoutDataInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnLoadoutAddedToFleetSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnLoadoutAddedToFleetSignature__DelegateSignature(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnLoadoutAddedToFleetSignature__DelegateSignature");
		
		UYFleetManager_OnLoadoutAddedToFleetSignature__DelegateSignature_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764970
	 * 		Name   -> Function DreadGame.YFleetManager.OnLoadoutAdded
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnLoadoutAdded(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.OnLoadoutAdded");
		
		UYFleetManager_OnLoadoutAdded_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnInitializedFromPlayerData__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYFleetManager::OnInitializedFromPlayerData__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnInitializedFromPlayerData__DelegateSignature");
		
		UYFleetManager_OnInitializedFromPlayerData__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnInitializationCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYFleetManager::OnInitializationCompleted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnInitializationCompleted__DelegateSignature");
		
		UYFleetManager_OnInitializationCompleted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnIndividualFleetMaintenanceUpdatedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class FName                                        fleetId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maintenanceCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnIndividualFleetMaintenanceUpdatedSignature__DelegateSignature(const class FName& fleetId, int32_t maintenanceCost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnIndividualFleetMaintenanceUpdatedSignature__DelegateSignature");
		
		UYFleetManager_OnIndividualFleetMaintenanceUpdatedSignature__DelegateSignature_Params params {};
		params.fleetId = fleetId;
		params.maintenanceCost = maintenanceCost;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnFleetUpdatedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYFleetManager::OnFleetUpdatedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnFleetUpdatedSignature__DelegateSignature");
		
		UYFleetManager_OnFleetUpdatedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnFleetUnlockedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYFleetType                                        fleetType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnFleetUnlockedSignature__DelegateSignature(EYFleetType fleetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnFleetUnlockedSignature__DelegateSignature");
		
		UYFleetManager_OnFleetUnlockedSignature__DelegateSignature_Params params {};
		params.fleetType = fleetType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YFleetManager.OnFlagshipUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FName                                        flagshipID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::OnFlagshipUpdated__DelegateSignature(const class FName& flagshipID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YFleetManager.OnFlagshipUpdated__DelegateSignature");
		
		UYFleetManager_OnFlagshipUpdated__DelegateSignature_Params params {};
		params.flagshipID = flagshipID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B8A0
	 * 		Name   -> Function DreadGame.YFleetManager.HandleMmogbrainToggleAutoMaintenance
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::HandleMmogbrainToggleAutoMaintenance(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.HandleMmogbrainToggleAutoMaintenance");
		
		UYFleetManager_HandleMmogbrainToggleAutoMaintenance_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B810
	 * 		Name   -> Function DreadGame.YFleetManager.HandleMmogbrainRemovedFromFleet
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::HandleMmogbrainRemovedFromFleet(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.HandleMmogbrainRemovedFromFleet");
		
		UYFleetManager_HandleMmogbrainRemovedFromFleet_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B590
	 * 		Name   -> Function DreadGame.YFleetManager.HandleMmogbrainIndividualFleetMaintenanceUpdated
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        fleetId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maintenanceCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::HandleMmogbrainIndividualFleetMaintenanceUpdated(const class FName& fleetId, int32_t maintenanceCost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.HandleMmogbrainIndividualFleetMaintenanceUpdated");
		
		UYFleetManager_HandleMmogbrainIndividualFleetMaintenanceUpdated_Params params {};
		params.fleetId = fleetId;
		params.maintenanceCost = maintenanceCost;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B570
	 * 		Name   -> Function DreadGame.YFleetManager.HandleMmogbrainFleetUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYFleetManager::HandleMmogbrainFleetUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.HandleMmogbrainFleetUpdated");
		
		UYFleetManager_HandleMmogbrainFleetUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B4E0
	 * 		Name   -> Function DreadGame.YFleetManager.HandleMmogbrainFleetMaintenance
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::HandleMmogbrainFleetMaintenance(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.HandleMmogbrainFleetMaintenance");
		
		UYFleetManager_HandleMmogbrainFleetMaintenance_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B4C0
	 * 		Name   -> Function DreadGame.YFleetManager.HandleMmogbrainEligibiltyTableUpdate
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYFleetManager::HandleMmogbrainEligibiltyTableUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.HandleMmogbrainEligibiltyTableUpdate");
		
		UYFleetManager_HandleMmogbrainEligibiltyTableUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B430
	 * 		Name   -> Function DreadGame.YFleetManager.HandleMmogbrainAddedToFleet
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYFleetManager::HandleMmogbrainAddedToFleet(bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YFleetManager.HandleMmogbrainAddedToFleet");
		
		UYFleetManager_HandleMmogbrainAddedToFleet_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYFleetManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYFleetManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YFleetManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AB40
	 * 		Name   -> Function DreadGame.YGameEngine.OnStartupMoviesFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYGameEngine::OnStartupMoviesFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameEngine.OnStartupMoviesFinished");
		
		UYGameEngine_OnStartupMoviesFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768A40
	 * 		Name   -> Function DreadGame.YGameEngine.OnReadyToSendMapLoadingTimesAnalytics
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYGameEngine::OnReadyToSendMapLoadingTimesAnalytics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameEngine.OnReadyToSendMapLoadingTimesAnalytics");
		
		UYGameEngine_OnReadyToSendMapLoadingTimesAnalytics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767C50
	 * 		Name   -> Function DreadGame.YGameEngine.OnPlayerDataLoaded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYGameEngine::OnPlayerDataLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameEngine.OnPlayerDataLoaded");
		
		UYGameEngine_OnPlayerDataLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765870
	 * 		Name   -> Function DreadGame.YGameEngine.OnNetworkFailureEvent
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      Category                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      additionalInfo                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldCauseDisconnection                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGameEngine::OnNetworkFailureEvent(const class FString& Category, const class FString& additionalInfo, bool bShouldCauseDisconnection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameEngine.OnNetworkFailureEvent");
		
		UYGameEngine_OnNetworkFailureEvent_Params params {};
		params.Category = Category;
		params.additionalInfo = additionalInfo;
		params.bShouldCauseDisconnection = bShouldCauseDisconnection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameEngine.OnMatchStart__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGameEngine::OnMatchStart__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameEngine.OnMatchStart__DelegateSignature");
		
		UYGameEngine_OnMatchStart__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameEngine.OnMatchEnd__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGameEngine::OnMatchEnd__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameEngine.OnMatchEnd__DelegateSignature");
		
		UYGameEngine_OnMatchEnd__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007647A0
	 * 		Name   -> Function DreadGame.YGameEngine.OnLoadingStarted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGameEngine::OnLoadingStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameEngine.OnLoadingStarted");
		
		UYGameEngine_OnLoadingStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameEngine.OnLoadingScreenOpen__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGameEngine::OnLoadingScreenOpen__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameEngine.OnLoadingScreenOpen__DelegateSignature");
		
		UYGameEngine_OnLoadingScreenOpen__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameEngine.OnLoadingScreenClosed__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGameEngine::OnLoadingScreenClosed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameEngine.OnLoadingScreenClosed__DelegateSignature");
		
		UYGameEngine_OnLoadingScreenClosed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameEngine.OnFinishedLoadingLevel__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGameEngine::OnFinishedLoadingLevel__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameEngine.OnFinishedLoadingLevel__DelegateSignature");
		
		UYGameEngine_OnFinishedLoadingLevel__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameEngine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameEngine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameEngine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767C70
	 * 		Name   -> Function DreadGame.YGameInstance.OnPlayerDataLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGameInstance::OnPlayerDataLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameInstance.OnPlayerDataLoaded");
		
		UYGameInstance_OnPlayerDataLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Menu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Menu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Menu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007806A0
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.StreamLevel
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FYStreamingOperation                        streamOperation                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Outpost::StreamLevel(const struct FYStreamingOperation& streamOperation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.StreamLevel");
		
		AYGameMode_Outpost_StreamLevel_Params params {};
		params.streamOperation = streamOperation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770600
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.SectionSelected
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYOutpostSection                                   newSection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Outpost::SectionSelected(EYOutpostSection newSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.SectionSelected");
		
		AYGameMode_Outpost_SectionSelected_Params params {};
		params.newSection = newSection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E840
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.ReloadCaptain
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameMode_Outpost::ReloadCaptain()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.ReloadCaptain");
		
		AYGameMode_Outpost_ReloadCaptain_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DA40
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.PlayerFlagshipChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        flagshipID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Outpost::PlayerFlagshipChanged(const class FName& flagshipID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.PlayerFlagshipChanged");
		
		AYGameMode_Outpost_PlayerFlagshipChanged_Params params {};
		params.flagshipID = flagshipID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D9C0
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.PlayerDisconnected
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameMode_Outpost::PlayerDisconnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.PlayerDisconnected");
		
		AYGameMode_Outpost_PlayerDisconnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameMode_Outpost.OnSubLevelLoaded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYGameMode_Outpost::OnSubLevelLoaded__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameMode_Outpost.OnSubLevelLoaded__DelegateSignature");
		
		AYGameMode_Outpost_OnSubLevelLoaded__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameMode_Outpost.OnOutpostTransitionCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYOutpostSection                                   newSection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Outpost::OnOutpostTransitionCompleted__DelegateSignature(EYOutpostSection newSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameMode_Outpost.OnOutpostTransitionCompleted__DelegateSignature");
		
		AYGameMode_Outpost_OnOutpostTransitionCompleted__DelegateSignature_Params params {};
		params.newSection = newSection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007641F0
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.OnHudAvailable
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameMode_Outpost::OnHudAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.OnHudAvailable");
		
		AYGameMode_Outpost_OnHudAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.LaunchTutorial
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        tutorialMap                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Outpost::LaunchTutorial(const class FName& tutorialMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.LaunchTutorial");
		
		AYGameMode_Outpost_LaunchTutorial_Params params {};
		params.tutorialMap = tutorialMap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D780
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.InitializeOutpostShipInternal
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameMode_Outpost::InitializeOutpostShipInternal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.InitializeOutpostShipInternal");
		
		AYGameMode_Outpost_InitializeOutpostShipInternal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D760
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.InitializeOutpostShip
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameMode_Outpost::InitializeOutpostShip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.InitializeOutpostShip");
		
		AYGameMode_Outpost_InitializeOutpostShip_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.InitAudioEvents
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameMode_Outpost::InitAudioEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.InitAudioEvents");
		
		AYGameMode_Outpost_InitAudioEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BA90
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.HandleOnLevelStreamed
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameMode_Outpost::HandleOnLevelStreamed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.HandleOnLevelStreamed");
		
		AYGameMode_Outpost_HandleOnLevelStreamed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BA70
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.HandleOnLevelFinalized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameMode_Outpost::HandleOnLevelFinalized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.HandleOnLevelFinalized");
		
		AYGameMode_Outpost_HandleOnLevelFinalized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007559D0
	 * 		Name   -> Function DreadGame.YGameMode_Outpost.GetOutpostHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYMenu* AYGameMode_Outpost::GetOutpostHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Outpost.GetOutpostHUD");
		
		AYGameMode_Outpost_GetOutpostHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Outpost.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Outpost::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Outpost");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783A20
	 * 		Name   -> Function DreadGame.YGameState.UpdateMusicState
	 * 		Flags  -> (Native, Protected)
	 */
	void AYGameState::UpdateMusicState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.UpdateMusicState");
		
		AYGameState_UpdateMusicState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A750
	 * 		Name   -> Function DreadGame.YGameState.SetRemainingTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState::SetRemainingTime(int32_t Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.SetRemainingTime");
		
		AYGameState_SetRemainingTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775890
	 * 		Name   -> Function DreadGame.YGameState.SetAllowWarpingOnSpawning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               allowWarping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYGameState::SetAllowWarpingOnSpawning(bool allowWarping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.SetAllowWarpingOnSpawning");
		
		AYGameState_SetAllowWarpingOnSpawning_Params params {};
		params.allowWarping = allowWarping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FAE0
	 * 		Name   -> Function DreadGame.YGameState.RequiresPawnToPlay
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	bool AYGameState::RequiresPawnToPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.RequiresPawnToPlay");
		
		AYGameState_RequiresPawnToPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameState.OnRep_ServerProfiling
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState::OnRep_ServerProfiling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.OnRep_ServerProfiling");
		
		AYGameState_OnRep_ServerProfiling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameState.OnRep_ServerFrameTime
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState::OnRep_ServerFrameTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.OnRep_ServerFrameTime");
		
		AYGameState_OnRep_ServerFrameTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768F60
	 * 		Name   -> Function DreadGame.YGameState.OnRep_RemainingTime
	 * 		Flags  -> (Native, Protected)
	 */
	void AYGameState::OnRep_RemainingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.OnRep_RemainingTime");
		
		AYGameState_OnRep_RemainingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768DC0
	 * 		Name   -> Function DreadGame.YGameState.OnRep_IsMatchStarted
	 * 		Flags  -> (Native, Protected)
	 */
	void AYGameState::OnRep_IsMatchStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.OnRep_IsMatchStarted");
		
		AYGameState_OnRep_IsMatchStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768DA0
	 * 		Name   -> Function DreadGame.YGameState.OnRep_IsMatchEnded
	 * 		Flags  -> (Native, Protected)
	 */
	void AYGameState::OnRep_IsMatchEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.OnRep_IsMatchEnded");
		
		AYGameState_OnRep_IsMatchEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768D20
	 * 		Name   -> Function DreadGame.YGameState.OnRep_FinalMatchResult
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState::OnRep_FinalMatchResult()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.OnRep_FinalMatchResult");
		
		AYGameState_OnRep_FinalMatchResult_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameState.OnPlayerLeaveMatch__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class APlayerState*                                playerLeaving                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState::OnPlayerLeaveMatch__DelegateSignature(class APlayerState* playerLeaving)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameState.OnPlayerLeaveMatch__DelegateSignature");
		
		AYGameState_OnPlayerLeaveMatch__DelegateSignature_Params params {};
		params.playerLeaving = playerLeaving;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameState.OnMatchStarted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYGameState::OnMatchStarted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameState.OnMatchStarted__DelegateSignature");
		
		AYGameState_OnMatchStarted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameState.OnMatchEnded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYGameState::OnMatchEnded__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameState.OnMatchEnded__DelegateSignature");
		
		AYGameState_OnMatchEnded__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761B40
	 * 		Name   -> Function DreadGame.YGameState.NewPlayerEntersOrbit
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AYGameState::NewPlayerEntersOrbit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.NewPlayerEntersOrbit");
		
		AYGameState_NewPlayerEntersOrbit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameState.KillDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPawn*                                      Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState::KillDelegate__DelegateSignature(class AYPawn* Killer, class AYPawn* victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameState.KillDelegate__DelegateSignature");
		
		AYGameState_KillDelegate__DelegateSignature_Params params {};
		params.Killer = Killer;
		params.victim = victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FF60
	 * 		Name   -> Function DreadGame.YGameState.IsWinner
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYGameState::IsWinner(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.IsWinner");
		
		AYGameState_IsWinner_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FCE0
	 * 		Name   -> Function DreadGame.YGameState.IsWarpingOnSpawningAllowed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYGameState::IsWarpingOnSpawningAllowed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.IsWarpingOnSpawningAllowed");
		
		AYGameState_IsWarpingOnSpawningAllowed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FC90
	 * 		Name   -> Function DreadGame.YGameState.IsWaitingForNewRound
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	bool AYGameState::IsWaitingForNewRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.IsWaitingForNewRound");
		
		AYGameState_IsWaitingForNewRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F110
	 * 		Name   -> Function DreadGame.YGameState.IsMatchStarted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYGameState::IsMatchStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.IsMatchStarted");
		
		AYGameState_IsMatchStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F0F0
	 * 		Name   -> Function DreadGame.YGameState.IsMatchEnded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYGameState::IsMatchEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.IsMatchEnded");
		
		AYGameState_IsMatchEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EF80
	 * 		Name   -> Function DreadGame.YGameState.IsInEndOfMatchScreen
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	bool AYGameState::IsInEndOfMatchScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.IsInEndOfMatchScreen");
		
		AYGameState_IsInEndOfMatchScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C370
	 * 		Name   -> Function DreadGame.YGameState.HasEnoughPlayersLeft
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	bool AYGameState::HasEnoughPlayersLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.HasEnoughPlayersLeft");
		
		AYGameState_HasEnoughPlayersLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759A50
	 * 		Name   -> Function DreadGame.YGameState.GetTeamScore
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYGameState::GetTeamScore(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetTeamScore");
		
		AYGameState_GetTeamScore_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759B50
	 * 		Name   -> Function DreadGame.YGameState.GetTeamsBoosterComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYTeamsBoosterComponent* AYGameState::GetTeamsBoosterComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetTeamsBoosterComponent");
		
		AYGameState_GetTeamsBoosterComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755BF0
	 * 		Name   -> Function DreadGame.YGameState.GetPRIArray
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class APlayerState*> AYGameState::GetPRIArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetPRIArray");
		
		AYGameState_GetPRIArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755A00
	 * 		Name   -> Function DreadGame.YGameState.GetOverlayMenuType
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYUIOverlayType AYGameState::GetOverlayMenuType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetOverlayMenuType");
		
		AYGameState_GetOverlayMenuType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753D50
	 * 		Name   -> Function DreadGame.YGameState.GetMPQuestsCollection
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYMPQuestsCollection* AYGameState::GetMPQuestsCollection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetMPQuestsCollection");
		
		AYGameState_GetMPQuestsCollection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753DE0
	 * 		Name   -> Function DreadGame.YGameState.GetMatchTimer
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	int32_t AYGameState::GetMatchTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetMatchTimer");
		
		AYGameState_GetMatchTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752080
	 * 		Name   -> Function DreadGame.YGameState.GetGameModeType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYGameModeType AYGameState::GetGameModeType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetGameModeType");
		
		AYGameState_GetGameModeType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752040
	 * 		Name   -> Function DreadGame.YGameState.GetGameModeHUDType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYGameModeType AYGameState::GetGameModeHUDType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetGameModeHUDType");
		
		AYGameState_GetGameModeHUDType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751670
	 * 		Name   -> Function DreadGame.YGameState.GetDefaultGameModeClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AGameMode* AYGameState::GetDefaultGameModeClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.GetDefaultGameModeClass");
		
		AYGameState_GetDefaultGameModeClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BB10
	 * 		Name   -> Function DreadGame.YGameState.ExecuteCleanup
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState::ExecuteCleanup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.ExecuteCleanup");
		
		AYGameState_ExecuteCleanup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745B10
	 * 		Name   -> Function DreadGame.YGameState.ClientNotifyKill
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class AYPawn*                                      Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState::ClientNotifyKill(class AYPawn* Killer, class AYPawn* victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.ClientNotifyKill");
		
		AYGameState_ClientNotifyKill_Params params {};
		params.Killer = Killer;
		params.victim = victim;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744800
	 * 		Name   -> Function DreadGame.YGameState.CleanUpOnMatchEnd
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState::CleanUpOnMatchEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.CleanUpOnMatchEnd");
		
		AYGameState_CleanUpOnMatchEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743D90
	 * 		Name   -> Function DreadGame.YGameState.CanPawnBeDamaged
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYGameState::CanPawnBeDamaged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState.CanPawnBeDamaged");
		
		AYGameState_CanPawnBeDamaged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784250
	 * 		Name   -> Function DreadGame.YGameState_Objective.UpdateUIForCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYGameState_Objective::UpdateUIForCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.UpdateUIForCompleted");
		
		AYGameState_Objective_UpdateUIForCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783C60
	 * 		Name   -> Function DreadGame.YGameState_Objective.UpdateRegisteredActor
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Objective::UpdateRegisteredActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.UpdateRegisteredActor");
		
		AYGameState_Objective_UpdateRegisteredActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783A40
	 * 		Name   -> Function DreadGame.YGameState_Objective.UpdateObjectiveUI
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_Objective::UpdateObjectiveUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.UpdateObjectiveUI");
		
		AYGameState_Objective_UpdateObjectiveUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781460
	 * 		Name   -> Function DreadGame.YGameState_Objective.ToggleObjectiveUIWidget
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool AYGameState_Objective::ToggleObjectiveUIWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.ToggleObjectiveUIWidget");
		
		AYGameState_Objective_ToggleObjectiveUIWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077DE00
	 * 		Name   -> Function DreadGame.YGameState_Objective.ShowObjectiveUIWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               enable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYGameState_Objective::ShowObjectiveUIWidget(bool enable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.ShowObjectiveUIWidget");
		
		AYGameState_Objective_ShowObjectiveUIWidget_Params params {};
		params.enable = enable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779490
	 * 		Name   -> Function DreadGame.YGameState_Objective.SetObjectiveState
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYObjectiveState                                   State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYGameState_Objective::SetObjectiveState(const class FName& ID, EYObjectiveState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.SetObjectiveState");
		
		AYGameState_Objective_SetObjectiveState_Params params {};
		params.ID = ID;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779240
	 * 		Name   -> Function DreadGame.YGameState_Objective.SetObjectiveCurrentCountToComplete
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Objective::SetObjectiveCurrentCountToComplete(const class FName& ID, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.SetObjectiveCurrentCountToComplete");
		
		AYGameState_Objective_SetObjectiveCurrentCountToComplete_Params params {};
		params.ID = ID;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778B10
	 * 		Name   -> Function DreadGame.YGameState_Objective.SetMainObjective
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isMainObjective                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Objective::SetMainObjective(const class FName& ID, bool isMainObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.SetMainObjective");
		
		AYGameState_Objective_SetMainObjective_Params params {};
		params.ID = ID;
		params.isMainObjective = isMainObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E7C0
	 * 		Name   -> Function DreadGame.YGameState_Objective.RegisterObjectiveActor
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Objective::RegisterObjectiveActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.RegisterObjectiveActor");
		
		AYGameState_Objective_RegisterObjectiveActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768EE0
	 * 		Name   -> Function DreadGame.YGameState_Objective.OnRep_Objectives
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_Objective::OnRep_Objectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.OnRep_Objectives");
		
		AYGameState_Objective_OnRep_Objectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761CC0
	 * 		Name   -> Function DreadGame.YGameState_Objective.NotifyObjectiveActors
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYObjectiveState                                   State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Objective::NotifyObjectiveActors(const class FName& ID, EYObjectiveState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.NotifyObjectiveActors");
		
		AYGameState_Objective_NotifyObjectiveActors_Params params {};
		params.ID = ID;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D6E0
	 * 		Name   -> Function DreadGame.YGameState_Objective.InitializeObjectivesFromDataTable
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UDataTable*                                  objectivesDataTable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Objective::InitializeObjectivesFromDataTable(class UDataTable* objectivesDataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.InitializeObjectivesFromDataTable");
		
		AYGameState_Objective_InitializeObjectivesFromDataTable_Params params {};
		params.objectivesDataTable = objectivesDataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757660
	 * 		Name   -> Function DreadGame.YGameState_Objective.GetQuestTextList
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		bool                                               main                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FText AYGameState_Objective::GetQuestTextList(bool main)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.GetQuestTextList");
		
		AYGameState_Objective_GetQuestTextList_Params params {};
		params.main = main;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755510
	 * 		Name   -> Function DreadGame.YGameState_Objective.GetObjectiveState
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYObjectiveState AYGameState_Objective::GetObjectiveState(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.GetObjectiveState");
		
		AYGameState_Objective_GetObjectiveState_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752B70
	 * 		Name   -> Function DreadGame.YGameState_Objective.GetIndexOfObjective
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYGameState_Objective::GetIndexOfObjective(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.GetIndexOfObjective");
		
		AYGameState_Objective_GetIndexOfObjective_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Objective.EventObjectiveStateChange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYObjectiveState                                   State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Objective::EventObjectiveStateChange(const class FName& ID, EYObjectiveState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.EventObjectiveStateChange");
		
		AYGameState_Objective_EventObjectiveStateChange_Params params {};
		params.ID = ID;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B3B0
	 * 		Name   -> Function DreadGame.YGameState_Objective.DumpRegObjectives
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_Objective::DumpRegObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.DumpRegObjectives");
		
		AYGameState_Objective_DumpRegObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749270
	 * 		Name   -> Function DreadGame.YGameState_Objective.CreateObjectiveUIWidget
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool AYGameState_Objective::CreateObjectiveUIWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.CreateObjectiveUIWidget");
		
		AYGameState_Objective_CreateObjectiveUIWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740290
	 * 		Name   -> Function DreadGame.YGameState_Objective.AddObjectiveCurrentCountToComplete
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYGameState_Objective::AddObjectiveCurrentCountToComplete(const class FName& ID, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Objective.AddObjectiveCurrentCountToComplete");
		
		AYGameState_Objective_AddObjectiveCurrentCountToComplete_Params params {};
		params.ID = ID;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Objective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Objective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Objective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007793D0
	 * 		Name   -> Function DreadGame.YGameMode_Objective.SetObjectiveState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYObjectiveState                                   State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Objective::SetObjectiveState(const class FName& ID, EYObjectiveState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Objective.SetObjectiveState");
		
		AYGameMode_Objective_SetObjectiveState_Params params {};
		params.ID = ID;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779180
	 * 		Name   -> Function DreadGame.YGameMode_Objective.SetObjectiveCurrentCountToComplete
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Objective::SetObjectiveCurrentCountToComplete(const class FName& ID, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Objective.SetObjectiveCurrentCountToComplete");
		
		AYGameMode_Objective_SetObjectiveCurrentCountToComplete_Params params {};
		params.ID = ID;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778A40
	 * 		Name   -> Function DreadGame.YGameMode_Objective.SetMainObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isMainObjective                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Objective::SetMainObjective(const class FName& ID, bool isMainObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Objective.SetMainObjective");
		
		AYGameMode_Objective_SetMainObjective_Params params {};
		params.ID = ID;
		params.isMainObjective = isMainObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755480
	 * 		Name   -> Function DreadGame.YGameMode_Objective.GetObjectiveState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EYObjectiveState AYGameMode_Objective::GetObjectiveState(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Objective.GetObjectiveState");
		
		AYGameMode_Objective_GetObjectiveState_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007401D0
	 * 		Name   -> Function DreadGame.YGameMode_Objective.AddObjectiveCurrentCountToComplete
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AYGameMode_Objective::AddObjectiveCurrentCountToComplete(const class FName& ID, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Objective.AddObjectiveCurrentCountToComplete");
		
		AYGameMode_Objective_AddObjectiveCurrentCountToComplete_Params params {};
		params.ID = ID;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Objective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Objective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Objective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768A20
	 * 		Name   -> Function DreadGame.YPlayerMPQuestCycle.OnQuestsRefresh
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYPlayerMPQuestCycle::OnQuestsRefresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerMPQuestCycle.OnQuestsRefresh");
		
		UYPlayerMPQuestCycle_OnQuestsRefresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerMPQuestCycle.OnQuestProgression__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class FText                                        questName                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            previousProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            currentProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            valueForCompleting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerMPQuestCycle::OnQuestProgression__DelegateSignature(const class FText& questName, int32_t previousProgress, int32_t currentProgress, int32_t valueForCompleting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerMPQuestCycle.OnQuestProgression__DelegateSignature");
		
		UYPlayerMPQuestCycle_OnQuestProgression__DelegateSignature_Params params {};
		params.questName = questName;
		params.previousProgress = previousProgress;
		params.currentProgress = currentProgress;
		params.valueForCompleting = valueForCompleting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerMPQuestCycle.OnQuestCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class FText                                        questName                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            previousProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            reliableFinalProgress                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerMPQuestCycle::OnQuestCompleted__DelegateSignature(const class FText& questName, int32_t previousProgress, int32_t reliableFinalProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerMPQuestCycle.OnQuestCompleted__DelegateSignature");
		
		UYPlayerMPQuestCycle_OnQuestCompleted__DelegateSignature_Params params {};
		params.questName = questName;
		params.previousProgress = previousProgress;
		params.reliableFinalProgress = reliableFinalProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007627A0
	 * 		Name   -> Function DreadGame.YPlayerMPQuestCycle.OnBackendDataAvailable
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerMPQuestCycle::OnBackendDataAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerMPQuestCycle.OnBackendDataAvailable");
		
		UYPlayerMPQuestCycle_OnBackendDataAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760D20
	 * 		Name   -> Function DreadGame.YPlayerMPQuestCycle.MatchEnded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerMPQuestCycle::MatchEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerMPQuestCycle.MatchEnded");
		
		UYPlayerMPQuestCycle_MatchEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D900
	 * 		Name   -> Function DreadGame.YPlayerMPQuestCycle.InitializeServerQuestCycle
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerMPQuestCycle::InitializeServerQuestCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerMPQuestCycle.InitializeServerQuestCycle");
		
		UYPlayerMPQuestCycle_InitializeServerQuestCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D330
	 * 		Name   -> Function DreadGame.YPlayerMPQuestCycle.InitializeClientQuestCycle
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerMPQuestCycle::InitializeClientQuestCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerMPQuestCycle.InitializeClientQuestCycle");
		
		UYPlayerMPQuestCycle_InitializeClientQuestCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745E20
	 * 		Name   -> Function DreadGame.YPlayerMPQuestCycle.ClientOnQuestProgression
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		class FText                                        questName                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FYMPQuestState                              State                                                      (Parm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            previousProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            currentProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            valueForCompleting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerMPQuestCycle::ClientOnQuestProgression(const class FText& questName, const struct FYMPQuestState& State, int32_t previousProgress, int32_t currentProgress, int32_t valueForCompleting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerMPQuestCycle.ClientOnQuestProgression");
		
		UYPlayerMPQuestCycle_ClientOnQuestProgression_Params params {};
		params.questName = questName;
		params.State = State;
		params.previousProgress = previousProgress;
		params.currentProgress = currentProgress;
		params.valueForCompleting = valueForCompleting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745BE0
	 * 		Name   -> Function DreadGame.YPlayerMPQuestCycle.ClientOnQuestCompleted
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		class FText                                        questName                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FYMPQuestState                              State                                                      (Parm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            previousProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            reliableFinalProgress                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerMPQuestCycle::ClientOnQuestCompleted(const class FText& questName, const struct FYMPQuestState& State, int32_t previousProgress, int32_t reliableFinalProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerMPQuestCycle.ClientOnQuestCompleted");
		
		UYPlayerMPQuestCycle_ClientOnQuestCompleted_Params params {};
		params.questName = questName;
		params.State = State;
		params.previousProgress = previousProgress;
		params.reliableFinalProgress = reliableFinalProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerMPQuestCycle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerMPQuestCycle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerMPQuestCycle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077EEC0
	 * 		Name   -> Function DreadGame.YGameMode_Multiplayer.SpawnNPC
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            npcIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               spawnInGivenLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SpawnLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    spawnRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYGameMode_Multiplayer::SpawnNPC(int32_t npcIndex, bool spawnInGivenLocation, const struct FVector& SpawnLocation, const struct FRotator& spawnRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Multiplayer.SpawnNPC");
		
		AYGameMode_Multiplayer_SpawnNPC_Params params {};
		params.npcIndex = npcIndex;
		params.spawnInGivenLocation = spawnInGivenLocation;
		params.SpawnLocation = SpawnLocation;
		params.spawnRotation = spawnRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E4D0
	 * 		Name   -> Function DreadGame.YGameMode_Multiplayer.ShuffleNPCPlayerCharacterProfiles
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYGameMode_Multiplayer::ShuffleNPCPlayerCharacterProfiles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Multiplayer.ShuffleNPCPlayerCharacterProfiles");
		
		AYGameMode_Multiplayer_ShuffleNPCPlayerCharacterProfiles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BF80
	 * 		Name   -> Function DreadGame.YGameMode_Multiplayer.SetTeamSizeAI
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            teamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Multiplayer::SetTeamSizeAI(EYTeam Team, int32_t teamSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Multiplayer.SetTeamSizeAI");
		
		AYGameMode_Multiplayer_SetTeamSizeAI_Params params {};
		params.Team = Team;
		params.teamSize = teamSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Multiplayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Multiplayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Multiplayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007659C0
	 * 		Name   -> Function DreadGame.YGameMode_CapturePoints.OnObjectiveCompleted
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CPIdx                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         objectiveCompletedController                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_CapturePoints::OnObjectiveCompleted(EYTeam Team, int32_t CPIdx, TArray<class AController*> objectiveCompletedController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_CapturePoints.OnObjectiveCompleted");
		
		AYGameMode_CapturePoints_OnObjectiveCompleted_Params params {};
		params.Team = Team;
		params.CPIdx = CPIdx;
		params.objectiveCompletedController = objectiveCompletedController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761D80
	 * 		Name   -> Function DreadGame.YGameMode_CapturePoints.NotifyObjectiveCompleted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             objectiveTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_CapturePoints::NotifyObjectiveCompleted(EYTeam objectiveTeam, const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_CapturePoints.NotifyObjectiveCompleted");
		
		AYGameMode_CapturePoints_NotifyObjectiveCompleted_Params params {};
		params.objectiveTeam = objectiveTeam;
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_CapturePoints.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_CapturePoints::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_CapturePoints");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DC20
	 * 		Name   -> Function DreadGame.YGameState_MP.PlayerReplicatedDataChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class AYPlayerReplicationInfo*                     pri                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_MP::PlayerReplicatedDataChanged(class AYPlayerReplicationInfo* pri)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.PlayerReplicatedDataChanged");
		
		AYGameState_MP_PlayerReplicatedDataChanged_Params params {};
		params.pri = pri;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C920
	 * 		Name   -> Function DreadGame.YGameState_MP.OrbitLevelReady
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AYGameState_MP::OrbitLevelReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.OrbitLevelReady");
		
		AYGameState_MP_OrbitLevelReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769240
	 * 		Name   -> Function DreadGame.YGameState_MP.OnRep_TeamName
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYGameState_MP::OnRep_TeamName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.OnRep_TeamName");
		
		AYGameState_MP_OnRep_TeamName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768EC0
	 * 		Name   -> Function DreadGame.YGameState_MP.OnRep_OTSVersion
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_MP::OnRep_OTSVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.OnRep_OTSVersion");
		
		AYGameState_MP_OnRep_OTSVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768E40
	 * 		Name   -> Function DreadGame.YGameState_MP.OnRep_LevelVariationIndex
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYGameState_MP::OnRep_LevelVariationIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.OnRep_LevelVariationIndex");
		
		AYGameState_MP_OnRep_LevelVariationIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameState_MP.OnReadyToStartOrbitTransition__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYGameState_MP::OnReadyToStartOrbitTransition__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameState_MP.OnReadyToStartOrbitTransition__DelegateSignature");
		
		AYGameState_MP_OnReadyToStartOrbitTransition__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763280
	 * 		Name   -> Function DreadGame.YGameState_MP.OnClientNPCSetLoaded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_MP::OnClientNPCSetLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.OnClientNPCSetLoaded");
		
		AYGameState_MP_OnClientNPCSetLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007617B0
	 * 		Name   -> Function DreadGame.YGameState_MP.NPCReplicatedDataChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class AYNPCReplicationInfo*                        npcri                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_MP::NPCReplicatedDataChanged(class AYNPCReplicationInfo* npcri)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.NPCReplicatedDataChanged");
		
		AYGameState_MP_NPCReplicatedDataChanged_Params params {};
		params.npcri = npcri;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761CA0
	 * 		Name   -> Function DreadGame.YGameState_MP.NotifyBackendReceivedEOMData
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AYGameState_MP::NotifyBackendReceivedEOMData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.NotifyBackendReceivedEOMData");
		
		AYGameState_MP_NotifyBackendReceivedEOMData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761B60
	 * 		Name   -> Function DreadGame.YGameState_MP.NewPlayerJoinMatch
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_MP::NewPlayerJoinMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.NewPlayerJoinMatch");
		
		AYGameState_MP_NewPlayerJoinMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760710
	 * 		Name   -> Function DreadGame.YGameState_MP.LoadNPCSetOnFleetInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_MP::LoadNPCSetOnFleetInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.LoadNPCSetOnFleetInitialized");
		
		AYGameState_MP_LoadNPCSetOnFleetInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007539B0
	 * 		Name   -> Function DreadGame.YGameState_MP.GetLevelVariationIndex
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_MP::GetLevelVariationIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.GetLevelVariationIndex");
		
		AYGameState_MP_GetLevelVariationIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751C90
	 * 		Name   -> Function DreadGame.YGameState_MP.GetFleetType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYFleetType AYGameState_MP::GetFleetType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.GetFleetType");
		
		AYGameState_MP_GetFleetType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CAC0
	 * 		Name   -> Function DreadGame.YGameState_MP.GetAIType
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYAIType AYGameState_MP::GetAIType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.GetAIType");
		
		AYGameState_MP_GetAIType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744380
	 * 		Name   -> Function DreadGame.YGameState_MP.CheckReadyToSetUpLevelsInOrbitManager
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_MP::CheckReadyToSetUpLevelsInOrbitManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.CheckReadyToSetUpLevelsInOrbitManager");
		
		AYGameState_MP_CheckReadyToSetUpLevelsInOrbitManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744360
	 * 		Name   -> Function DreadGame.YGameState_MP.CheckOTSDataAvailability
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_MP::CheckOTSDataAvailability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_MP.CheckOTSDataAvailability");
		
		AYGameState_MP_CheckOTSDataAvailability_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_MP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_MP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_MP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CE00
	 * 		Name   -> Function DreadGame.YGameState_CapturePointsGame.IncrementStationCount
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameState_CapturePointsGame::IncrementStationCount(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CapturePointsGame.IncrementStationCount");
		
		UYGameState_CapturePointsGame_IncrementStationCount_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759360
	 * 		Name   -> Function DreadGame.YGameState_CapturePointsGame.GetStationCountT2
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYGameState_CapturePointsGame::GetStationCountT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CapturePointsGame.GetStationCountT2");
		
		UYGameState_CapturePointsGame_GetStationCountT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752D10
	 * 		Name   -> Function DreadGame.YGameState_CapturePointsGame.GetStationCountT1
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYGameState_CapturePointsGame::GetStationCountT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CapturePointsGame.GetStationCountT1");
		
		UYGameState_CapturePointsGame_GetStationCountT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A410
	 * 		Name   -> Function DreadGame.YGameState_CapturePointsGame.DecrementStationCount
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameState_CapturePointsGame::DecrementStationCount(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CapturePointsGame.DecrementStationCount");
		
		UYGameState_CapturePointsGame_DecrementStationCount_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameState_CapturePointsGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameState_CapturePointsGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_CapturePointsGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752D10
	 * 		Name   -> Function DreadGame.YGameState_TicketsGame.GetMaxTickets
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYGameState_TicketsGame::GetMaxTickets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TicketsGame.GetMaxTickets");
		
		UYGameState_TicketsGame_GetMaxTickets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750E40
	 * 		Name   -> Function DreadGame.YGameState_TicketsGame.GetCurrentTicketsPercentageT2
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYGameState_TicketsGame::GetCurrentTicketsPercentageT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TicketsGame.GetCurrentTicketsPercentageT2");
		
		UYGameState_TicketsGame_GetCurrentTicketsPercentageT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750E10
	 * 		Name   -> Function DreadGame.YGameState_TicketsGame.GetCurrentTicketsPercentageT1
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYGameState_TicketsGame::GetCurrentTicketsPercentageT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TicketsGame.GetCurrentTicketsPercentageT1");
		
		UYGameState_TicketsGame_GetCurrentTicketsPercentageT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750DE0
	 * 		Name   -> Function DreadGame.YGameState_TicketsGame.GetCurrentTicketCountT2
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYGameState_TicketsGame::GetCurrentTicketCountT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TicketsGame.GetCurrentTicketCountT2");
		
		UYGameState_TicketsGame_GetCurrentTicketCountT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750D70
	 * 		Name   -> Function DreadGame.YGameState_TicketsGame.GetCurrentTicketCountT1
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYGameState_TicketsGame::GetCurrentTicketCountT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TicketsGame.GetCurrentTicketCountT1");
		
		UYGameState_TicketsGame_GetCurrentTicketCountT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameState_TicketsGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameState_TicketsGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_TicketsGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782340
	 * 		Name   -> Function DreadGame.YGameState_CP.TriggerIsCapturingVO
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      capturePointName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_CP::TriggerIsCapturingVO(bool Enemy, const class FString& capturePointName, class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.TriggerIsCapturingVO");
		
		AYGameState_CP_TriggerIsCapturingVO_Params params {};
		params.Enemy = Enemy;
		params.capturePointName = capturePointName;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782220
	 * 		Name   -> Function DreadGame.YGameState_CP.TriggerHasCapturedVO
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      capturePointName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_CP::TriggerHasCapturedVO(bool Enemy, const class FString& capturePointName, class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.TriggerHasCapturedVO");
		
		AYGameState_CP_TriggerHasCapturedVO_Params params {};
		params.Enemy = Enemy;
		params.capturePointName = capturePointName;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769280
	 * 		Name   -> Function DreadGame.YGameState_CP.OnRep_TicketCountChanged
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_CP::OnRep_TicketCountChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.OnRep_TicketCountChanged");
		
		AYGameState_CP_OnRep_TicketCountChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769020
	 * 		Name   -> Function DreadGame.YGameState_CP.OnRep_ScoreForWining
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_CP::OnRep_ScoreForWining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.OnRep_ScoreForWining");
		
		AYGameState_CP_OnRep_ScoreForWining_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761F50
	 * 		Name   -> Function DreadGame.YGameState_CP.ObjectiveCompleted
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		EYTeam                                             objectiveTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_CP::ObjectiveCompleted(EYTeam objectiveTeam, const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.ObjectiveCompleted");
		
		AYGameState_CP_ObjectiveCompleted_Params params {};
		params.objectiveTeam = objectiveTeam;
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753C70
	 * 		Name   -> Function DreadGame.YGameState_CP.GetLocalControlledPawn
	 * 		Flags  -> (Final, Native, Public)
	 */
	class AYPawn* AYGameState_CP::GetLocalControlledPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.GetLocalControlledPawn");
		
		AYGameState_CP_GetLocalControlledPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750DA0
	 * 		Name   -> Function DreadGame.YGameState_CP.GetCurrentTicketCountT2
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_CP::GetCurrentTicketCountT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.GetCurrentTicketCountT2");
		
		AYGameState_CP_GetCurrentTicketCountT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750D30
	 * 		Name   -> Function DreadGame.YGameState_CP.GetCurrentTicketCountT1
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_CP::GetCurrentTicketCountT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_CP.GetCurrentTicketCountT1");
		
		AYGameState_CP_GetCurrentTicketCountT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_CP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_CP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_CP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C920
	 * 		Name   -> Function DreadGame.YGameState_TER.OrbitLevelReady
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AYGameState_TER::OrbitLevelReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.OrbitLevelReady");
		
		AYGameState_TER_OrbitLevelReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769280
	 * 		Name   -> Function DreadGame.YGameState_TER.OnRep_TicketCountChanged
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_TER::OnRep_TicketCountChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.OnRep_TicketCountChanged");
		
		AYGameState_TER_OnRep_TicketCountChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769260
	 * 		Name   -> Function DreadGame.YGameState_TER.OnRep_TerritoryT2
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TER::OnRep_TerritoryT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.OnRep_TerritoryT2");
		
		AYGameState_TER_OnRep_TerritoryT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769260
	 * 		Name   -> Function DreadGame.YGameState_TER.OnRep_TerritoryT1
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TER::OnRep_TerritoryT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.OnRep_TerritoryT1");
		
		AYGameState_TER_OnRep_TerritoryT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007629E0
	 * 		Name   -> Function DreadGame.YGameState_TER.OnCapturePointHasBeenCaptured
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CPIdx                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      capturePointName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         objectiveCompletedController                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_TER::OnCapturePointHasBeenCaptured(EYTeam Team, int32_t CPIdx, const class FString& capturePointName, TArray<class AController*> objectiveCompletedController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.OnCapturePointHasBeenCaptured");
		
		AYGameState_TER_OnCapturePointHasBeenCaptured_Params params {};
		params.Team = Team;
		params.CPIdx = CPIdx;
		params.capturePointName = capturePointName;
		params.objectiveCompletedController = objectiveCompletedController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EA00
	 * 		Name   -> Function DreadGame.YGameState_TER.IsGainingControlOverThreshold
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              threshold                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYGameState_TER::IsGainingControlOverThreshold(EYTeam Team, float threshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.IsGainingControlOverThreshold");
		
		AYGameState_TER_IsGainingControlOverThreshold_Params params {};
		params.Team = Team;
		params.threshold = threshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758560
	 * 		Name   -> Function DreadGame.YGameState_TER.GetShipClassInfluenceRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipClass                                        shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AYGameState_TER::GetShipClassInfluenceRadius(EYShipClass shipclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.GetShipClassInfluenceRadius");
		
		AYGameState_TER_GetShipClassInfluenceRadius_Params params {};
		params.shipclass = shipclass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750D00
	 * 		Name   -> Function DreadGame.YGameState_TER.GetCurrentTerritoryT2
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_TER::GetCurrentTerritoryT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.GetCurrentTerritoryT2");
		
		AYGameState_TER_GetCurrentTerritoryT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750CD0
	 * 		Name   -> Function DreadGame.YGameState_TER.GetCurrentTerritoryT1
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_TER::GetCurrentTerritoryT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.GetCurrentTerritoryT1");
		
		AYGameState_TER_GetCurrentTerritoryT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744260
	 * 		Name   -> Function DreadGame.YGameState_TER.CheckForAudioFeedbackKillingIt
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TER::CheckForAudioFeedbackKillingIt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.CheckForAudioFeedbackKillingIt");
		
		AYGameState_TER_CheckForAudioFeedbackKillingIt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744240
	 * 		Name   -> Function DreadGame.YGameState_TER.CheckForAudioFeedbackForWinning
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TER::CheckForAudioFeedbackForWinning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.CheckForAudioFeedbackForWinning");
		
		AYGameState_TER_CheckForAudioFeedbackForWinning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744220
	 * 		Name   -> Function DreadGame.YGameState_TER.CheckForAudioFeedbackForEarlyLead
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TER::CheckForAudioFeedbackForEarlyLead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.CheckForAudioFeedbackForEarlyLead");
		
		AYGameState_TER_CheckForAudioFeedbackForEarlyLead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744200
	 * 		Name   -> Function DreadGame.YGameState_TER.CheckForAudioFeedbackForDominating
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TER::CheckForAudioFeedbackForDominating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TER.CheckForAudioFeedbackForDominating");
		
		AYGameState_TER_CheckForAudioFeedbackForDominating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_TER.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_TER::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_TER");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007659C0
	 * 		Name   -> Function DreadGame.YGameMode_Territory.OnObjectiveCompleted
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CPIdx                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         objectiveCompletedController                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Territory::OnObjectiveCompleted(EYTeam Team, int32_t CPIdx, TArray<class AController*> objectiveCompletedController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Territory.OnObjectiveCompleted");
		
		AYGameMode_Territory_OnObjectiveCompleted_Params params {};
		params.Team = Team;
		params.CPIdx = CPIdx;
		params.objectiveCompletedController = objectiveCompletedController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Territory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Territory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Territory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740810
	 * 		Name   -> Function DreadGame.YGameMode_PVE.SetTeamScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    scores                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::SetTeamScore(TArray<int32_t> scores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.SetTeamScore");
		
		AYGameMode_PVE_SetTeamScore_Params params {};
		params.scores = scores;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EF60
	 * 		Name   -> Function DreadGame.YGameMode_PVE.RemoveNPCFromEnemyList
	 * 		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            npcID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::RemoveNPCFromEnemyList(int32_t npcID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.RemoveNPCFromEnemyList");
		
		AYGameMode_PVE_RemoveNPCFromEnemyList_Params params {};
		params.npcID = npcID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_PVE.PlayersWin
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_PVE::PlayersWin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.PlayersWin");
		
		AYGameMode_PVE_PlayersWin_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_PVE.PlayersLose
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_PVE::PlayersLose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.PlayersLose");
		
		AYGameMode_PVE_PlayersLose_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_PVE.OnNPCSpawnedEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            npcID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::OnNPCSpawnedEvent(int32_t npcID, class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.OnNPCSpawnedEvent");
		
		AYGameMode_PVE_OnNPCSpawnedEvent_Params params {};
		params.npcID = npcID;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YGameMode_PVE.InitializeYAICombatSceneManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYAICombatSceneManager*                      YAICombatSceneManager                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::InitializeYAICombatSceneManager(class AYAICombatSceneManager* YAICombatSceneManager)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.InitializeYAICombatSceneManager");
		
		AYGameMode_PVE_InitializeYAICombatSceneManager_Params params {};
		params.YAICombatSceneManager = YAICombatSceneManager;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D4F0
	 * 		Name   -> Function DreadGame.YGameMode_PVE.InitializeGameModeFromEventManager
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPVEEventManager*                           pveEventManager                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::InitializeGameModeFromEventManager(class AYPVEEventManager* pveEventManager)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.InitializeGameModeFromEventManager");
		
		AYGameMode_PVE_InitializeGameModeFromEventManager_Params params {};
		params.pveEventManager = pveEventManager;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757DD0
	 * 		Name   -> Function DreadGame.YGameMode_PVE.GetTeamScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameMode_PVE::GetTeamScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.GetTeamScore");
		
		AYGameMode_PVE_GetTeamScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074FFD0
	 * 		Name   -> Function DreadGame.YGameMode_PVE.GetCombatSceneManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYAICombatSceneManager* AYGameMode_PVE::GetCombatSceneManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.GetCombatSceneManager");
		
		AYGameMode_PVE_GetCombatSceneManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YGameMode_PVE.AddWaveTeamKillScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::AddWaveTeamKillScore(int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.AddWaveTeamKillScore");
		
		AYGameMode_PVE_AddWaveTeamKillScore_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740810
	 * 		Name   -> Function DreadGame.YGameMode_PVE.AddTeamScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    scores                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::AddTeamScore(TArray<int32_t> scores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.AddTeamScore");
		
		AYGameMode_PVE_AddTeamScore_Params params {};
		params.scores = scores;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YGameMode_PVE.AddNPCToEnemyList
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            npcID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_PVE::AddNPCToEnemyList(int32_t npcID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_PVE.AddNPCToEnemyList");
		
		AYGameMode_PVE_AddNPCToEnemyList_Params params {};
		params.npcID = npcID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_PVE.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_PVE::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_PVE");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782FE0
	 * 		Name   -> Function DreadGame.YWaveScoringController.UpdateBonus
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWaveScoringController::UpdateBonus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.UpdateBonus");
		
		UYWaveScoringController_UpdateBonus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FFE0
	 * 		Name   -> Function DreadGame.YWaveScoringController.StartWave
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWaveScoringController::StartWave(int32_t idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.StartWave");
		
		UYWaveScoringController_StartWave_Params params {};
		params.idx = idx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D980
	 * 		Name   -> Function DreadGame.YWaveScoringController.InitializeTimeScoringFromDataTable
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDataTable*                                  DataTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWaveScoringController::InitializeTimeScoringFromDataTable(class UDataTable* DataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.InitializeTimeScoringFromDataTable");
		
		UYWaveScoringController_InitializeTimeScoringFromDataTable_Params params {};
		params.DataTable = DataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D800
	 * 		Name   -> Function DreadGame.YWaveScoringController.InitializeRemainingScoringFromDataTable
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDataTable*                                  DataTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWaveScoringController::InitializeRemainingScoringFromDataTable(class UDataTable* DataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.InitializeRemainingScoringFromDataTable");
		
		UYWaveScoringController_InitializeRemainingScoringFromDataTable_Params params {};
		params.DataTable = DataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D660
	 * 		Name   -> Function DreadGame.YWaveScoringController.InitializeKillScoringFromDataTable
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDataTable*                                  DataTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWaveScoringController::InitializeKillScoringFromDataTable(class UDataTable* DataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.InitializeKillScoringFromDataTable");
		
		UYWaveScoringController_InitializeKillScoringFromDataTable_Params params {};
		params.DataTable = DataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757DD0
	 * 		Name   -> Function DreadGame.YWaveScoringController.GetScoreForRemainingPlayers
	 * 		Flags  -> (Final, Native, Public)
	 */
	int32_t UYWaveScoringController::GetScoreForRemainingPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.GetScoreForRemainingPlayers");
		
		UYWaveScoringController_GetScoreForRemainingPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B910
	 * 		Name   -> Function DreadGame.YWaveScoringController.EndWave
	 * 		Flags  -> (Final, Native, Public)
	 */
	struct FYWaveScoringResult UYWaveScoringController::EndWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.EndWave");
		
		UYWaveScoringController_EndWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A490
	 * 		Name   -> Function DreadGame.YWaveScoringController.DeductScoreDueToPlayerDeath
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWaveScoringController::DeductScoreDueToPlayerDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.DeductScoreDueToPlayerDeath");
		
		UYWaveScoringController_DeductScoreDueToPlayerDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744970
	 * 		Name   -> Function DreadGame.YWaveScoringController.ClearTimers
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYWaveScoringController::ClearTimers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.ClearTimers");
		
		UYWaveScoringController_ClearTimers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007444D0
	 * 		Name   -> Function DreadGame.YWaveScoringController.CheckWhetherToDeductKillScore
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              killedNPCAliveTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWaveScoringController::CheckWhetherToDeductKillScore(float killedNPCAliveTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.CheckWhetherToDeductKillScore");
		
		UYWaveScoringController_CheckWhetherToDeductKillScore_Params params {};
		params.killedNPCAliveTime = killedNPCAliveTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740A70
	 * 		Name   -> Function DreadGame.YWaveScoringController.AddWaveKillScore
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWaveScoringController::AddWaveKillScore(int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWaveScoringController.AddWaveKillScore");
		
		UYWaveScoringController_AddWaveKillScore_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWaveScoringController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWaveScoringController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWaveScoringController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YKillScoringController.InitializeScoringFromDataTable
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDataTable*                                  DataTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYKillScoringController::InitializeScoringFromDataTable(class UDataTable* DataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKillScoringController.InitializeScoringFromDataTable");
		
		UYKillScoringController_InitializeScoringFromDataTable_Params params {};
		params.DataTable = DataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYKillScoringController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYKillScoringController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YKillScoringController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FF60
	 * 		Name   -> Function DreadGame.YGameMode_Destroy.StartWave
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Destroy::StartWave(int32_t idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Destroy.StartWave");
		
		AYGameMode_Destroy_StartWave_Params params {};
		params.idx = idx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B8F0
	 * 		Name   -> Function DreadGame.YGameMode_Destroy.EndWave
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_Destroy::EndWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Destroy.EndWave");
		
		AYGameMode_Destroy_EndWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Destroy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Destroy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Destroy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YGameMode_Escort.StartWave
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Escort::StartWave(int32_t idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.StartWave");
		
		AYGameMode_Escort_StartWave_Params params {};
		params.idx = idx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007519A0
	 * 		Name   -> Function DreadGame.YGameMode_Escort.GetEscortShipPawnID
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYGameMode_Escort::GetEscortShipPawnID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.GetEscortShipPawnID");
		
		AYGameMode_Escort_GetEscortShipPawnID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x016BB3F0
	 * 		Name   -> Function DreadGame.YGameMode_Escort.GetEscortShipPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYPawn* AYGameMode_Escort::GetEscortShipPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.GetEscortShipPawn");
		
		AYGameMode_Escort_GetEscortShipPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YGameMode_Escort.EscortShipSpawned
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            escortShipPawnID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Escort::EscortShipSpawned(int32_t escortShipPawnID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.EscortShipSpawned");
		
		AYGameMode_Escort_EscortShipSpawned_Params params {};
		params.escortShipPawnID = escortShipPawnID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_Escort.EscortShipHealed
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 instigatingController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Escort::EscortShipHealed(float amount, float newHealth, class AController* instigatingController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.EscortShipHealed");
		
		AYGameMode_Escort_EscortShipHealed_Params params {};
		params.amount = amount;
		params.newHealth = newHealth;
		params.instigatingController = instigatingController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_Escort.EscortShipDamaged
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 instigatingController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Escort::EscortShipDamaged(float amount, float newHealth, class AController* instigatingController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.EscortShipDamaged");
		
		AYGameMode_Escort_EscortShipDamaged_Params params {};
		params.amount = amount;
		params.newHealth = newHealth;
		params.instigatingController = instigatingController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_Escort.EndWave
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_Escort::EndWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.EndWave");
		
		AYGameMode_Escort_EndWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A5B0
	 * 		Name   -> Function DreadGame.YGameMode_Escort.DelegateEscortShipDamaged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 instigatingController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Escort::DelegateEscortShipDamaged(float amount, float newHealth, class AController* instigatingController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Escort.DelegateEscortShipDamaged");
		
		AYGameMode_Escort_DelegateEscortShipDamaged_Params params {};
		params.amount = amount;
		params.newHealth = newHealth;
		params.instigatingController = instigatingController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Escort.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Escort::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Escort");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D3F0
	 * 		Name   -> Function DreadGame.YMedalScoringController.InitializeFromDataTable
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDataTable*                                  DataTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMedalScoringController::InitializeFromDataTable(class UDataTable* DataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMedalScoringController.InitializeFromDataTable");
		
		UYMedalScoringController_InitializeFromDataTable_Params params {};
		params.DataTable = DataTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754100
	 * 		Name   -> Function DreadGame.YMedalScoringController.GetMedal
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            teamScore                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FYMedal UYMedalScoringController::GetMedal(int32_t teamScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMedalScoringController.GetMedal");
		
		UYMedalScoringController_GetMedal_Params params {};
		params.teamScore = teamScore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMedalScoringController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMedalScoringController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMedalScoringController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784270
	 * 		Name   -> Function DreadGame.YGameState_PVE.UpdateWaveScoreResultUI
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            waveIdx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::UpdateWaveScoreResultUI(int32_t waveIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.UpdateWaveScoreResultUI");
		
		AYGameState_PVE_UpdateWaveScoreResultUI_Params params {};
		params.waveIdx = waveIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783CE0
	 * 		Name   -> Function DreadGame.YGameState_PVE.UpdateTeamScoreUI
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_PVE::UpdateTeamScoreUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.UpdateTeamScoreUI");
		
		AYGameState_PVE_UpdateTeamScoreUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783A00
	 * 		Name   -> Function DreadGame.YGameState_PVE.UpdateMedalResultUI
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_PVE::UpdateMedalResultUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.UpdateMedalResultUI");
		
		AYGameState_PVE_UpdateMedalResultUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007831E0
	 * 		Name   -> Function DreadGame.YGameState_PVE.UpdateDefendResultUI
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_PVE::UpdateDefendResultUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.UpdateDefendResultUI");
		
		AYGameState_PVE_UpdateDefendResultUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781540
	 * 		Name   -> Function DreadGame.YGameState_PVE.ToggleScoringUIWidget
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool AYGameState_PVE::ToggleScoringUIWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.ToggleScoringUIWidget");
		
		AYGameState_PVE_ToggleScoringUIWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E310
	 * 		Name   -> Function DreadGame.YGameState_PVE.ShowScoringUIWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               enable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AYGameState_PVE::ShowScoringUIWidget(bool enable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.ShowScoringUIWidget");
		
		AYGameState_PVE_ShowScoringUIWidget_Params params {};
		params.enable = enable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D880
	 * 		Name   -> Function DreadGame.YGameState_PVE.ShowIncomingSpawnEffect
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::ShowIncomingSpawnEffect(class AActor* targetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.ShowIncomingSpawnEffect");
		
		AYGameState_PVE_ShowIncomingSpawnEffect_Params params {};
		params.targetActor = targetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D5D0
	 * 		Name   -> Function DreadGame.YGameState_PVE.ShowHUDMarkerOnActor
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUIQuestMarker                                    markerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::ShowHUDMarkerOnActor(EYUIQuestMarker markerType, class AActor* targetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.ShowHUDMarkerOnActor");
		
		AYGameState_PVE_ShowHUDMarkerOnActor_Params params {};
		params.markerType = markerType;
		params.targetActor = targetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BED0
	 * 		Name   -> Function DreadGame.YGameState_PVE.SetTeamScore
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<int32_t>                                    scores                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::SetTeamScore(TArray<int32_t> scores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.SetTeamScore");
		
		AYGameState_PVE_SetTeamScore_Params params {};
		params.scores = scores;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771070
	 * 		Name   -> Function DreadGame.YGameState_PVE.SendWaveScoreResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FYWaveScoringResult                         waveResult                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::SendWaveScoreResult(const struct FYWaveScoringResult& waveResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.SendWaveScoreResult");
		
		AYGameState_PVE_SendWaveScoreResult_Params params {};
		params.waveResult = waveResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770AE0
	 * 		Name   -> Function DreadGame.YGameState_PVE.SendMedalResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FYMedal                                     medal                                                      (Parm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::SendMedalResult(const struct FYMedal& medal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.SendMedalResult");
		
		AYGameState_PVE_SendMedalResult_Params params {};
		params.medal = medal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770A50
	 * 		Name   -> Function DreadGame.YGameState_PVE.SendDefendResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FYDefendScoringResult                       defendResult                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::SendDefendResult(const struct FYDefendScoringResult& defendResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.SendDefendResult");
		
		AYGameState_PVE_SendDefendResult_Params params {};
		params.defendResult = defendResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EEA0
	 * 		Name   -> Function DreadGame.YGameState_PVE.RemoveIncomingSpawnEffect
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::RemoveIncomingSpawnEffect(class AActor* targetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.RemoveIncomingSpawnEffect");
		
		AYGameState_PVE_RemoveIncomingSpawnEffect_Params params {};
		params.targetActor = targetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EE20
	 * 		Name   -> Function DreadGame.YGameState_PVE.RemoveHUDMarkerOnActor
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::RemoveHUDMarkerOnActor(class AActor* targetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.RemoveHUDMarkerOnActor");
		
		AYGameState_PVE_RemoveHUDMarkerOnActor_Params params {};
		params.targetActor = targetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_PVE.PVEMatchEnded
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               playersWon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::PVEMatchEnded(bool playersWon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.PVEMatchEnded");
		
		AYGameState_PVE_PVEMatchEnded_Params params {};
		params.playersWon = playersWon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_PVE.PlayerLivesChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            currentLiveTotal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::PlayerLivesChanged(int32_t currentLiveTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.PlayerLivesChanged");
		
		AYGameState_PVE_PlayerLivesChanged_Params params {};
		params.currentLiveTotal = currentLiveTotal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_PVE.OnTeamScoreChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::OnTeamScoreChanged(int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.OnTeamScoreChanged");
		
		AYGameState_PVE_OnTeamScoreChanged_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E5F250
	 * 		Name   -> Function DreadGame.YGameState_PVE.OnRep_TeamScoreChanged
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_PVE::OnRep_TeamScoreChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.OnRep_TeamScoreChanged");
		
		AYGameState_PVE_OnRep_TeamScoreChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768F00
	 * 		Name   -> Function DreadGame.YGameState_PVE.OnRep_PlayerTeamRespawnsLeft
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_PVE::OnRep_PlayerTeamRespawnsLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.OnRep_PlayerTeamRespawnsLeft");
		
		AYGameState_PVE_OnRep_PlayerTeamRespawnsLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_PVE.OnPVEEventManagerInitialized
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYGameState_PVE::OnPVEEventManagerInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.OnPVEEventManagerInitialized");
		
		AYGameState_PVE_OnPVEEventManagerInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007616E0
	 * 		Name   -> Function DreadGame.YGameState_PVE.MulticastShowIncomingSpawnEffect
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::MulticastShowIncomingSpawnEffect(class AActor* targetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.MulticastShowIncomingSpawnEffect");
		
		AYGameState_PVE_MulticastShowIncomingSpawnEffect_Params params {};
		params.targetActor = targetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761610
	 * 		Name   -> Function DreadGame.YGameState_PVE.MulticastShowHUDMarkerOnActor
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		EYUIQuestMarker                                    markerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::MulticastShowHUDMarkerOnActor(EYUIQuestMarker markerType, class AActor* targetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.MulticastShowHUDMarkerOnActor");
		
		AYGameState_PVE_MulticastShowHUDMarkerOnActor_Params params {};
		params.markerType = markerType;
		params.targetActor = targetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761580
	 * 		Name   -> Function DreadGame.YGameState_PVE.MulticastRemoveIncomingSpawnEffect
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::MulticastRemoveIncomingSpawnEffect(class AActor* targetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.MulticastRemoveIncomingSpawnEffect");
		
		AYGameState_PVE_MulticastRemoveIncomingSpawnEffect_Params params {};
		params.targetActor = targetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759AF0
	 * 		Name   -> Function DreadGame.YGameState_PVE.GetTeamScore_PVE
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_PVE::GetTeamScore_PVE()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.GetTeamScore_PVE");
		
		AYGameState_PVE_GetTeamScore_PVE_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757B50
	 * 		Name   -> Function DreadGame.YGameState_PVE.GetRemainingTeamRespawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_PVE::GetRemainingTeamRespawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.GetRemainingTeamRespawns");
		
		AYGameState_PVE_GetRemainingTeamRespawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755C90
	 * 		Name   -> Function DreadGame.YGameState_PVE.GetPVEMedal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText AYGameState_PVE::GetPVEMedal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.GetPVEMedal");
		
		AYGameState_PVE_GetPVEMedal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755C70
	 * 		Name   -> Function DreadGame.YGameState_PVE.GetPVEDifficulty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYPVEDifficulty AYGameState_PVE::GetPVEDifficulty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.GetPVEDifficulty");
		
		AYGameState_PVE_GetPVEDifficulty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007492D0
	 * 		Name   -> Function DreadGame.YGameState_PVE.CreateScoringUIWidget
	 * 		Flags  -> (Final, Native, Protected)
	 */
	bool AYGameState_PVE::CreateScoringUIWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.CreateScoringUIWidget");
		
		AYGameState_PVE_CreateScoringUIWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007408F0
	 * 		Name   -> Function DreadGame.YGameState_PVE.AddTeamScore
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<int32_t>                                    scores                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_PVE::AddTeamScore(TArray<int32_t> scores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_PVE.AddTeamScore");
		
		AYGameState_PVE_AddTeamScore_Params params {};
		params.scores = scores;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_PVE.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_PVE::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_PVE");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CD10
	 * 		Name   -> Function DreadGame.YGameState_Horde.SetWaveSpawningComplete
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameState_Horde::SetWaveSpawningComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.SetWaveSpawningComplete");
		
		AYGameState_Horde_SetWaveSpawningComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CC90
	 * 		Name   -> Function DreadGame.YGameState_Horde.SetWaveIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            newIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::SetWaveIndex(int32_t newIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.SetWaveIndex");
		
		AYGameState_Horde_SetWaveIndex_Params params {};
		params.newIndex = newIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777000
	 * 		Name   -> Function DreadGame.YGameState_Horde.SetSpecialWaveConditionsFulfilled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               fulfilled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::SetSpecialWaveConditionsFulfilled(bool fulfilled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.SetSpecialWaveConditionsFulfilled");
		
		AYGameState_Horde_SetSpecialWaveConditionsFulfilled_Params params {};
		params.fulfilled = fulfilled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007692C0
	 * 		Name   -> Function DreadGame.YGameState_Horde.OnRep_WaveStateChanged
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_Horde::OnRep_WaveStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.OnRep_WaveStateChanged");
		
		AYGameState_Horde_OnRep_WaveStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007692A0
	 * 		Name   -> Function DreadGame.YGameState_Horde.OnRep_WaveIndexChanged
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_Horde::OnRep_WaveIndexChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.OnRep_WaveIndexChanged");
		
		AYGameState_Horde_OnRep_WaveIndexChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768EA0
	 * 		Name   -> Function DreadGame.YGameState_Horde.OnRep_NumEnemiesKilledThisWave
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_Horde::OnRep_NumEnemiesKilledThisWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.OnRep_NumEnemiesKilledThisWave");
		
		AYGameState_Horde_OnRep_NumEnemiesKilledThisWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Horde.NumberOfKilledEnemiesChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            numberOfKilledEnemiesThisWave                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::NumberOfKilledEnemiesChanged(int32_t numberOfKilledEnemiesThisWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.NumberOfKilledEnemiesChanged");
		
		AYGameState_Horde_NumberOfKilledEnemiesChanged_Params params {};
		params.numberOfKilledEnemiesThisWave = numberOfKilledEnemiesThisWave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Horde.LastWaveEnemyRemaining
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            npcID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::LastWaveEnemyRemaining(int32_t npcID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.LastWaveEnemyRemaining");
		
		AYGameState_Horde_LastWaveEnemyRemaining_Params params {};
		params.npcID = npcID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Horde.HordeWaveStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYHordeWaveState                                   waveState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::HordeWaveStateChanged(EYHordeWaveState waveState, int32_t waveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.HordeWaveStateChanged");
		
		AYGameState_Horde_HordeWaveStateChanged_Params params {};
		params.waveState = waveState;
		params.waveIndex = waveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Horde.HordeWaveCleared
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::HordeWaveCleared(int32_t waveIndex, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.HordeWaveCleared");
		
		AYGameState_Horde_HordeWaveCleared_Params params {};
		params.waveIndex = waveIndex;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758F40
	 * 		Name   -> Function DreadGame.YGameState_Horde.GetSpecialWaveConditionsFulfilled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYGameState_Horde::GetSpecialWaveConditionsFulfilled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.GetSpecialWaveConditionsFulfilled");
		
		AYGameState_Horde_GetSpecialWaveConditionsFulfilled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007552D0
	 * 		Name   -> Function DreadGame.YGameState_Horde.GetNumberOfRemainingWaveEnemies
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_Horde::GetNumberOfRemainingWaveEnemies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.GetNumberOfRemainingWaveEnemies");
		
		AYGameState_Horde_GetNumberOfRemainingWaveEnemies_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750EB0
	 * 		Name   -> Function DreadGame.YGameState_Horde.GetCurrentWaveState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYHordeWaveState AYGameState_Horde::GetCurrentWaveState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.GetCurrentWaveState");
		
		AYGameState_Horde_GetCurrentWaveState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750E90
	 * 		Name   -> Function DreadGame.YGameState_Horde.GetCurrentWaveIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_Horde::GetCurrentWaveIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.GetCurrentWaveIndex");
		
		AYGameState_Horde_GetCurrentWaveIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750E70
	 * 		Name   -> Function DreadGame.YGameState_Horde.GetCurrentWaveDuration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_Horde::GetCurrentWaveDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.GetCurrentWaveDuration");
		
		AYGameState_Horde_GetCurrentWaveDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744C40
	 * 		Name   -> Function DreadGame.YGameState_Horde.ClientBossEnemySpawned
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		class AYPawn*                                      enemyPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::ClientBossEnemySpawned(class AYPawn* enemyPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.ClientBossEnemySpawned");
		
		AYGameState_Horde_ClientBossEnemySpawned_Params params {};
		params.enemyPawn = enemyPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744BB0
	 * 		Name   -> Function DreadGame.YGameState_Horde.ClientBossEnemyDied
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		class AYPawn*                                      enemyPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::ClientBossEnemyDied(class AYPawn* enemyPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.ClientBossEnemyDied");
		
		AYGameState_Horde_ClientBossEnemyDied_Params params {};
		params.enemyPawn = enemyPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Horde.BP_UpdateRegainingLivesTextVisibility
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsVisible                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Horde::BP_UpdateRegainingLivesTextVisibility(bool IsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Horde.BP_UpdateRegainingLivesTextVisibility");
		
		AYGameState_Horde_BP_UpdateRegainingLivesTextVisibility_Params params {};
		params.IsVisible = IsVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Horde.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Horde::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Horde");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_Horde.StartFirstWave
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_Horde::StartFirstWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Horde.StartFirstWave");
		
		AYGameMode_Horde_StartFirstWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_Horde.EndCurrentWave
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_Horde::EndCurrentWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Horde.EndCurrentWave");
		
		AYGameMode_Horde_EndCurrentWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_Horde.CheckWaveOver
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_Horde::CheckWaveOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Horde.CheckWaveOver");
		
		AYGameMode_Horde_CheckWaveOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Horde.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Horde::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Horde");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_Havoc.OnWaveStartDelayTimerOver
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYGameMode_Havoc::OnWaveStartDelayTimerOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Havoc.OnWaveStartDelayTimerOver");
		
		AYGameMode_Havoc_OnWaveStartDelayTimerOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_Havoc.OnWaveCompleteTimerOver
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYGameMode_Havoc::OnWaveCompleteTimerOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Havoc.OnWaveCompleteTimerOver");
		
		AYGameMode_Havoc_OnWaveCompleteTimerOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B930
	 * 		Name   -> Function DreadGame.YGameMode_Havoc.OnUpgradeSelectionTimerTick
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYGameMode_Havoc::OnUpgradeSelectionTimerTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Havoc.OnUpgradeSelectionTimerTick");
		
		AYGameMode_Havoc_OnUpgradeSelectionTimerTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B0D0
	 * 		Name   -> Function DreadGame.YGameMode_Havoc.OnSwitchToState
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		EYHordeWaveState                                   waveState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Havoc::OnSwitchToState(EYHordeWaveState waveState, int32_t waveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Havoc.OnSwitchToState");
		
		AYGameMode_Havoc_OnSwitchToState_Params params {};
		params.waveState = waveState;
		params.waveIndex = waveIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740AF0
	 * 		Name   -> Function DreadGame.YGameMode_Havoc.AddXPWithContributerPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            xp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Havoc::AddXPWithContributerPlayer(int32_t xp, class AController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Havoc.AddXPWithContributerPlayer");
		
		AYGameMode_Havoc_AddXPWithContributerPlayer_Params params {};
		params.xp = xp;
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740AF0
	 * 		Name   -> Function DreadGame.YGameMode_Havoc.AddXPWithContributerPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            xp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Havoc::AddXPWithContributerPawn(int32_t xp, class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Havoc.AddXPWithContributerPawn");
		
		AYGameMode_Havoc_AddXPWithContributerPawn_Params params {};
		params.xp = xp;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YGameMode_Havoc.AddXPForGroup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            xp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_Havoc::AddXPForGroup(int32_t xp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Havoc.AddXPForGroup");
		
		AYGameMode_Havoc_AddXPForGroup_Params params {};
		params.xp = xp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Havoc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Havoc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Havoc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_TeamDeathmatch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_TeamDeathmatch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_TeamDeathmatch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Benchmark.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Benchmark::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Benchmark");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Bootcamp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Bootcamp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Bootcamp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_Invasion.SetSpawnWaveTimeStamp
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameMode_Invasion::SetSpawnWaveTimeStamp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_Invasion.SetSpawnWaveTimeStamp");
		
		AYGameMode_Invasion_SetSpawnWaveTimeStamp_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Invasion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Invasion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Invasion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_PodTDM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_PodTDM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_PodTDM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_TeamElimination.OnRoundStarted
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameMode_TeamElimination::OnRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TeamElimination.OnRoundStarted");
		
		AYGameMode_TeamElimination_OnRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_TeamElimination.OnRoundEnded
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameMode_TeamElimination::OnRoundEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TeamElimination.OnRoundEnded");
		
		AYGameMode_TeamElimination_OnRoundEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775530
	 * 		Name   -> Function DreadGame.YGameMode_TeamElimination.DebugShowJetSpawning
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameMode_TeamElimination::DebugShowJetSpawning(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TeamElimination.DebugShowJetSpawning");
		
		AYGameMode_TeamElimination_DebugShowJetSpawning_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749D40
	 * 		Name   -> Function DreadGame.YGameMode_TeamElimination.DebugLogNumPlayers
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYGameMode_TeamElimination::DebugLogNumPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TeamElimination.DebugLogNumPlayers");
		
		AYGameMode_TeamElimination_DebugLogNumPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749D20
	 * 		Name   -> Function DreadGame.YGameMode_TeamElimination.DebugLogMatchState
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYGameMode_TeamElimination::DebugLogMatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TeamElimination.DebugLogMatchState");
		
		AYGameMode_TeamElimination_DebugLogMatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGameMode_TeamElimination.DebugEndRound
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AYGameMode_TeamElimination::DebugEndRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TeamElimination.DebugEndRound");
		
		AYGameMode_TeamElimination_DebugEndRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_TeamElimination.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_TeamElimination::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_TeamElimination");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DA20
	 * 		Name   -> Function DreadGame.YGameMode_TrainingMatch.PlayerEneteredBattleZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYGameMode_TrainingMatch::PlayerEneteredBattleZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TrainingMatch.PlayerEneteredBattleZone");
		
		AYGameMode_TrainingMatch_PlayerEneteredBattleZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765B20
	 * 		Name   -> Function DreadGame.YGameMode_TrainingMatch.OnObjectiveUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameMode_TrainingMatch::OnObjectiveUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TrainingMatch.OnObjectiveUpdated");
		
		AYGameMode_TrainingMatch_OnObjectiveUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameMode_TrainingMatch.OnMatchEnded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYGameMode_TrainingMatch::OnMatchEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameMode_TrainingMatch.OnMatchEnded");
		
		AYGameMode_TrainingMatch_OnMatchEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_TrainingMatch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_TrainingMatch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_TrainingMatch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_DemoMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_DemoMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_DemoMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_TurboTDM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_TurboTDM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_TurboTDM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_VisualAttraction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_VisualAttraction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_VisualAttraction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameMode_Singleplayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameMode_Singleplayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameMode_Singleplayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D190
	 * 		Name   -> Function DreadGame.YGameModeSettingsDataManager.Initialize
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameModeSettingsDataManager::Initialize(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameModeSettingsDataManager.Initialize");
		
		UYGameModeSettingsDataManager_Initialize_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameModeSettingsDataManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameModeSettingsDataManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameModeSettingsDataManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameModifierComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameModifierComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameModifierComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740080
	 * 		Name   -> Function DreadGame.YGameplayAttributeQueryContext.AddNumberQueryContextComplex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        mainSpecifier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier1                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeQueryContext::AddNumberQueryContextComplex(float contextValue, const class FName& mainSpecifier, const class FName& additionalSpecifier1, const class FName& additionalSpecifier2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeQueryContext.AddNumberQueryContextComplex");
		
		UYGameplayAttributeQueryContext_AddNumberQueryContextComplex_Params params {};
		params.contextValue = contextValue;
		params.mainSpecifier = mainSpecifier;
		params.additionalSpecifier1 = additionalSpecifier1;
		params.additionalSpecifier2 = additionalSpecifier2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FFB0
	 * 		Name   -> Function DreadGame.YGameplayAttributeQueryContext.AddNumberQueryContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextSpecifier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeQueryContext::AddNumberQueryContext(const class FName& contextSpecifier, float contextValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeQueryContext.AddNumberQueryContext");
		
		UYGameplayAttributeQueryContext_AddNumberQueryContext_Params params {};
		params.contextSpecifier = contextSpecifier;
		params.contextValue = contextValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FE60
	 * 		Name   -> Function DreadGame.YGameplayAttributeQueryContext.AddNameQueryContextComplex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        mainSpecifier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier1                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeQueryContext::AddNameQueryContextComplex(const class FName& contextValue, const class FName& mainSpecifier, const class FName& additionalSpecifier1, const class FName& additionalSpecifier2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeQueryContext.AddNameQueryContextComplex");
		
		UYGameplayAttributeQueryContext_AddNameQueryContextComplex_Params params {};
		params.contextValue = contextValue;
		params.mainSpecifier = mainSpecifier;
		params.additionalSpecifier1 = additionalSpecifier1;
		params.additionalSpecifier2 = additionalSpecifier2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FDA0
	 * 		Name   -> Function DreadGame.YGameplayAttributeQueryContext.AddNameQueryContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextSpecifier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeQueryContext::AddNameQueryContext(const class FName& contextSpecifier, const class FName& contextValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeQueryContext.AddNameQueryContext");
		
		UYGameplayAttributeQueryContext_AddNameQueryContext_Params params {};
		params.contextSpecifier = contextSpecifier;
		params.contextValue = contextValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E4D0
	 * 		Name   -> Function DreadGame.YGameplayAttributeQueryContext.AddBitMaskQueryContextComplex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        bitMaskIdentifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        mainSpecifier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier1                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeQueryContext::AddBitMaskQueryContextComplex(int32_t contextValue, const class FName& bitMaskIdentifier, const class FName& mainSpecifier, const class FName& additionalSpecifier1, const class FName& additionalSpecifier2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeQueryContext.AddBitMaskQueryContextComplex");
		
		UYGameplayAttributeQueryContext_AddBitMaskQueryContextComplex_Params params {};
		params.contextValue = contextValue;
		params.bitMaskIdentifier = bitMaskIdentifier;
		params.mainSpecifier = mainSpecifier;
		params.additionalSpecifier1 = additionalSpecifier1;
		params.additionalSpecifier2 = additionalSpecifier2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E350
	 * 		Name   -> Function DreadGame.YGameplayAttributeQueryContext.AddBitMaskQueryContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextSpecifier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        bitMaskIdentifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGameplayAttributeQueryContext::AddBitMaskQueryContext(const class FName& contextSpecifier, const class FName& bitMaskIdentifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameplayAttributeQueryContext.AddBitMaskQueryContext");
		
		UYGameplayAttributeQueryContext_AddBitMaskQueryContext_Params params {};
		params.contextSpecifier = contextSpecifier;
		params.bitMaskIdentifier = bitMaskIdentifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameplayAttributeQueryContext.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameplayAttributeQueryContext::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameplayAttributeQueryContext");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Destroy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Destroy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Destroy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751970
	 * 		Name   -> Function DreadGame.YGameState_Escort.GetEscortShipPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPawn* AYGameState_Escort::GetEscortShipPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Escort.GetEscortShipPawn");
		
		AYGameState_Escort_GetEscortShipPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751940
	 * 		Name   -> Function DreadGame.YGameState_Escort.GetEscortShipHealthPercent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AYGameState_Escort::GetEscortShipHealthPercent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Escort.GetEscortShipHealthPercent");
		
		AYGameState_Escort_GetEscortShipHealthPercent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Escort.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Escort::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Escort");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D230
	 * 		Name   -> Function DreadGame.YHavocDataManager.Initialize
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHavocDataManager::Initialize(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocDataManager.Initialize");
		
		UYHavocDataManager_Initialize_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHavocDataManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHavocDataManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHavocDataManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074EBC0
	 * 		Name   -> Function DreadGame.YInterface_ShipVanityAssetBase.GetLocName
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UYInterface_ShipVanityAssetBase::GetLocName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ShipVanityAssetBase.GetLocName");
		
		UYInterface_ShipVanityAssetBase_GetLocName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753B50
	 * 		Name   -> Function DreadGame.YInterface_ShipVanityAssetBase.GetLocDesc
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UYInterface_ShipVanityAssetBase::GetLocDesc()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ShipVanityAssetBase.GetLocDesc");
		
		UYInterface_ShipVanityAssetBase_GetLocDesc_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752D10
	 * 		Name   -> Function DreadGame.YInterface_ShipVanityAssetBase.GetItemID
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYInterface_ShipVanityAssetBase::GetItemID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_ShipVanityAssetBase.GetItemID");
		
		UYInterface_ShipVanityAssetBase_GetItemID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInterface_ShipVanityAssetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInterface_ShipVanityAssetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInterface_ShipVanityAssetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutUpdateFailed__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYLoadoutManagerComponent::OnLoadoutUpdateFailed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutUpdateFailed__DelegateSignature");
		
		UYLoadoutManagerComponent_OnLoadoutUpdateFailed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::OnLoadoutUpdated__DelegateSignature(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutUpdated__DelegateSignature");
		
		UYLoadoutManagerComponent_OnLoadoutUpdated__DelegateSignature_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutsInstalledSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYLoadoutManagerComponent::OnLoadoutsInstalledSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutsInstalledSignature__DelegateSignature");
		
		UYLoadoutManagerComponent_OnLoadoutsInstalledSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutRemoved__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::OnLoadoutRemoved__DelegateSignature(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutRemoved__DelegateSignature");
		
		UYLoadoutManagerComponent_OnLoadoutRemoved__DelegateSignature_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutAddFailed__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYLoadoutManagerComponent::OnLoadoutAddFailed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutAddFailed__DelegateSignature");
		
		UYLoadoutManagerComponent_OnLoadoutAddFailed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutAdded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::OnLoadoutAdded__DelegateSignature(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YLoadoutManagerComponent.OnLoadoutAdded__DelegateSignature");
		
		UYLoadoutManagerComponent_OnLoadoutAdded__DelegateSignature_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YLoadoutManagerComponent.OnInitializedFromPlayerData__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYLoadoutManagerComponent::OnInitializedFromPlayerData__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YLoadoutManagerComponent.OnInitializedFromPlayerData__DelegateSignature");
		
		UYLoadoutManagerComponent_OnInitializedFromPlayerData__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763090
	 * 		Name   -> Function DreadGame.YLoadoutManagerComponent.OnChunkDownloaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		uint32_t                                           chunkId                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::OnChunkDownloaded(uint32_t chunkId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLoadoutManagerComponent.OnChunkDownloaded");
		
		UYLoadoutManagerComponent_OnChunkDownloaded_Params params {};
		params.chunkId = chunkId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762230
	 * 		Name   -> Function DreadGame.YLoadoutManagerComponent.OnActivateLoadoutAfterLoad
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYShipLoadout*                               loadout                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::OnActivateLoadoutAfterLoad(class UYShipLoadout* loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLoadoutManagerComponent.OnActivateLoadoutAfterLoad");
		
		UYLoadoutManagerComponent_OnActivateLoadoutAfterLoad_Params params {};
		params.loadout = loadout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D490
	 * 		Name   -> Function DreadGame.YLoadoutManagerComponent.InitializeFromPlayerData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYLoadoutManagerComponent::InitializeFromPlayerData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLoadoutManagerComponent.InitializeFromPlayerData");
		
		UYLoadoutManagerComponent_InitializeFromPlayerData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B780
	 * 		Name   -> Function DreadGame.YLoadoutManagerComponent.HandleMmogbrainLoadoutUpdated
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::HandleMmogbrainLoadoutUpdated(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLoadoutManagerComponent.HandleMmogbrainLoadoutUpdated");
		
		UYLoadoutManagerComponent_HandleMmogbrainLoadoutUpdated_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B6F0
	 * 		Name   -> Function DreadGame.YLoadoutManagerComponent.HandleMmogbrainLoadoutDeleted
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::HandleMmogbrainLoadoutDeleted(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLoadoutManagerComponent.HandleMmogbrainLoadoutDeleted");
		
		UYLoadoutManagerComponent_HandleMmogbrainLoadoutDeleted_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B660
	 * 		Name   -> Function DreadGame.YLoadoutManagerComponent.HandleMmogbrainLoadoutAdded
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::HandleMmogbrainLoadoutAdded(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLoadoutManagerComponent.HandleMmogbrainLoadoutAdded");
		
		UYLoadoutManagerComponent_HandleMmogbrainLoadoutAdded_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D150
	 * 		Name   -> Function DreadGame.YLoadoutManagerComponent.ActivateLoadout
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYShipLoadout*                               loadout                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               assetLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYLoadoutManagerComponent::ActivateLoadout(class UYShipLoadout* loadout, bool assetLoad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLoadoutManagerComponent.ActivateLoadout");
		
		UYLoadoutManagerComponent_ActivateLoadout_Params params {};
		params.loadout = loadout;
		params.assetLoad = assetLoad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYLoadoutManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYLoadoutManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLoadoutManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnUpgradesUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameState_Havoc::OnUpgradesUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnUpgradesUpdated");
		
		AYGameState_Havoc_OnUpgradesUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameState_Havoc.OnUpgradeIconGotLoaded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYGameState_Havoc::OnUpgradeIconGotLoaded__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameState_Havoc.OnUpgradeIconGotLoaded__DelegateSignature");
		
		AYGameState_Havoc_OnUpgradeIconGotLoaded__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768B20
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnRepCurrentHavocState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_Havoc::OnRepCurrentHavocState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnRepCurrentHavocState");
		
		AYGameState_Havoc_OnRepCurrentHavocState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnPlayerReadyForNextWaveChanged
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<int32_t>                                    readyPlayersForNextWave                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::OnPlayerReadyForNextWaveChanged(TArray<int32_t> readyPlayersForNextWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnPlayerReadyForNextWaveChanged");
		
		AYGameState_Havoc_OnPlayerReadyForNextWaveChanged_Params params {};
		params.readyPlayersForNextWave = readyPlayersForNextWave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameState_Havoc.OnHavocStateChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYGameState_Havoc::OnHavocStateChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameState_Havoc.OnHavocStateChanged__DelegateSignature");
		
		AYGameState_Havoc_OnHavocStateChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnEnterWaveStartingState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameState_Havoc::OnEnterWaveStartingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnEnterWaveStartingState");
		
		AYGameState_Havoc_OnEnterWaveStartingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnEnterWaveInProgressState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameState_Havoc::OnEnterWaveInProgressState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnEnterWaveInProgressState");
		
		AYGameState_Havoc_OnEnterWaveInProgressState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnEnterWaveCompleteState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameState_Havoc::OnEnterWaveCompleteState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnEnterWaveCompleteState");
		
		AYGameState_Havoc_OnEnterWaveCompleteState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnEnterUpgradeSelectionState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameState_Havoc::OnEnterUpgradeSelectionState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnEnterUpgradeSelectionState");
		
		AYGameState_Havoc_OnEnterUpgradeSelectionState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnEnterGameOverState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AYGameState_Havoc::OnEnterGameOverState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnEnterGameOverState");
		
		AYGameState_Havoc_OnEnterGameOverState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.OnActiveWaveModiferUpdated
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class FName>                                activeModifierNames                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::OnActiveWaveModiferUpdated(TArray<class FName> activeModifierNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.OnActiveWaveModiferUpdated");
		
		AYGameState_Havoc_OnActiveWaveModiferUpdated_Params params {};
		params.activeModifierNames = activeModifierNames;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CE80
	 * 		Name   -> Function DreadGame.YGameState_Havoc.IncrementWavesReached
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYGameState_Havoc::IncrementWavesReached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.IncrementWavesReached");
		
		AYGameState_Havoc_IncrementWavesReached_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A620
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetWaveXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_Havoc::GetWaveXP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetWaveXP");
		
		AYGameState_Havoc_GetWaveXP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A3B0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetUpgradeUIData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        upgradeID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FYUIHavocUpgrade AYGameState_Havoc::GetUpgradeUIData(const class FName& upgradeID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetUpgradeUIData");
		
		AYGameState_Havoc_GetUpgradeUIData_Params params {};
		params.upgradeID = upgradeID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A020
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetTotalXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_Havoc::GetTotalXP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetTotalXP");
		
		AYGameState_Havoc_GetTotalXP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757010
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetPlayerWaveXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_Havoc::GetPlayerWaveXP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetPlayerWaveXP");
		
		AYGameState_Havoc_GetPlayerWaveXP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007552B0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetNumberOfReachedWaves
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYGameState_Havoc::GetNumberOfReachedWaves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetNumberOfReachedWaves");
		
		AYGameState_Havoc_GetNumberOfReachedWaves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750790
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetCurrentHavocState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYHavocState AYGameState_Havoc::GetCurrentHavocState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetCurrentHavocState");
		
		AYGameState_Havoc_GetCurrentHavocState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CE70
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetActiveWaveModiferUIData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        modifierID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FYUIHavocModifier AYGameState_Havoc::GetActiveWaveModiferUIData(const class FName& modifierID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetActiveWaveModiferUIData");
		
		AYGameState_Havoc_GetActiveWaveModiferUIData_Params params {};
		params.modifierID = modifierID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CDF0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetActiveWaveModifer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<struct FYHavocModifiersDataTableRow> AYGameState_Havoc::GetActiveWaveModifer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetActiveWaveModifer");
		
		AYGameState_Havoc_GetActiveWaveModifer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CD70
	 * 		Name   -> Function DreadGame.YGameState_Havoc.GetActivePermanentEnemyModifiers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<struct FYHavocPermanentEnemyModifiersDataTableRow> AYGameState_Havoc::GetActivePermanentEnemyModifiers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.GetActivePermanentEnemyModifiers");
		
		AYGameState_Havoc_GetActivePermanentEnemyModifiers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747D60
	 * 		Name   -> Function DreadGame.YGameState_Havoc.ClientUpdateWaveProgress
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public, BlueprintCallable)
	 */
	void AYGameState_Havoc::ClientUpdateWaveProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.ClientUpdateWaveProgress");
		
		AYGameState_Havoc_ClientUpdateWaveProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747CD0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.ClientUpdateTimeToNextWave
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		int32_t                                            timeToNextWave                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::ClientUpdateTimeToNextWave(int32_t timeToNextWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.ClientUpdateTimeToNextWave");
		
		AYGameState_Havoc_ClientUpdateTimeToNextWave_Params params {};
		params.timeToNextWave = timeToNextWave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747C30
	 * 		Name   -> Function DreadGame.YGameState_Havoc.ClientUpdateRewards
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		TArray<struct FYHavocRewardDataTableRow>           rewards                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::ClientUpdateRewards(TArray<struct FYHavocRewardDataTableRow> rewards)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.ClientUpdateRewards");
		
		AYGameState_Havoc_ClientUpdateRewards_Params params {};
		params.rewards = rewards;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747B90
	 * 		Name   -> Function DreadGame.YGameState_Havoc.ClientUpdatePlayerReadyForNextWave
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		TArray<int32_t>                                    readyPlayersForNextWave                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::ClientUpdatePlayerReadyForNextWave(TArray<int32_t> readyPlayersForNextWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.ClientUpdatePlayerReadyForNextWave");
		
		AYGameState_Havoc_ClientUpdatePlayerReadyForNextWave_Params params {};
		params.readyPlayersForNextWave = readyPlayersForNextWave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007479B0
	 * 		Name   -> Function DreadGame.YGameState_Havoc.ClientUpdateActiveWaveModifier
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		TArray<class FName>                                activeModifierNames                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                activePermanentEnemyModifierNames                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::ClientUpdateActiveWaveModifier(TArray<class FName> activeModifierNames, TArray<class FName> activePermanentEnemyModifierNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.ClientUpdateActiveWaveModifier");
		
		AYGameState_Havoc_ClientUpdateActiveWaveModifier_Params params {};
		params.activeModifierNames = activeModifierNames;
		params.activePermanentEnemyModifierNames = activePermanentEnemyModifierNames;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745520
	 * 		Name   -> Function DreadGame.YGameState_Havoc.ClientHavocStateChanged
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		EYHavocState                                       newHavocState                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::ClientHavocStateChanged(EYHavocState newHavocState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.ClientHavocStateChanged");
		
		AYGameState_Havoc_ClientHavocStateChanged_Params params {};
		params.newHavocState = newHavocState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745410
	 * 		Name   -> Function DreadGame.YGameState_Havoc.ClientHavocPlayersChanged
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		struct FYHavocHUDTeamInfo                          teamsInfo                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_Havoc::ClientHavocPlayersChanged(const struct FYHavocHUDTeamInfo& teamsInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Havoc.ClientHavocPlayersChanged");
		
		AYGameState_Havoc_ClientHavocPlayersChanged_Params params {};
		params.teamsInfo = teamsInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Havoc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Havoc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Havoc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768E20
	 * 		Name   -> Function DreadGame.YGameState_TDM.OnRep_KillsCountChanged
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_TDM::OnRep_KillsCountChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TDM.OnRep_KillsCountChanged");
		
		AYGameState_TDM_OnRep_KillsCountChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768DC0
	 * 		Name   -> Function DreadGame.YGameState_TDM.OnRep_IsMatchStarted
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_TDM::OnRep_IsMatchStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TDM.OnRep_IsMatchStarted");
		
		AYGameState_TDM_OnRep_IsMatchStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768DA0
	 * 		Name   -> Function DreadGame.YGameState_TDM.OnRep_IsMatchEnded
	 * 		Flags  -> (Native, Public)
	 */
	void AYGameState_TDM::OnRep_IsMatchEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TDM.OnRep_IsMatchEnded");
		
		AYGameState_TDM_OnRep_IsMatchEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_TDM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_TDM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_TDM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_BC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_BC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_BC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Benchmark.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Benchmark::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Benchmark");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744360
	 * 		Name   -> Function DreadGame.YGameState_DemoMode.CheckOTSDataAvailability
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_DemoMode::CheckOTSDataAvailability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_DemoMode.CheckOTSDataAvailability");
		
		AYGameState_DemoMode_CheckOTSDataAvailability_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_DemoMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_DemoMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_DemoMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007690E0
	 * 		Name   -> Function DreadGame.YGameState_Invasion.OnRep_SpawnCommandT2
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_Invasion::OnRep_SpawnCommandT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Invasion.OnRep_SpawnCommandT2");
		
		AYGameState_Invasion_OnRep_SpawnCommandT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007690C0
	 * 		Name   -> Function DreadGame.YGameState_Invasion.OnRep_SpawnCommandT1
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_Invasion::OnRep_SpawnCommandT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Invasion.OnRep_SpawnCommandT1");
		
		AYGameState_Invasion_OnRep_SpawnCommandT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768E00
	 * 		Name   -> Function DreadGame.YGameState_Invasion.OnRep_KillCommandT2
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_Invasion::OnRep_KillCommandT2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Invasion.OnRep_KillCommandT2");
		
		AYGameState_Invasion_OnRep_KillCommandT2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768DE0
	 * 		Name   -> Function DreadGame.YGameState_Invasion.OnRep_KillCommandT1
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_Invasion::OnRep_KillCommandT1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_Invasion.OnRep_KillCommandT1");
		
		AYGameState_Invasion_OnRep_KillCommandT1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Invasion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Invasion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Invasion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_PodTDM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_PodTDM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_PodTDM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768FE0
	 * 		Name   -> Function DreadGame.YGameState_TE.OnRep_RoundTransition
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TE::OnRep_RoundTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TE.OnRep_RoundTransition");
		
		AYGameState_TE_OnRep_RoundTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768FC0
	 * 		Name   -> Function DreadGame.YGameState_TE.OnRep_Round
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYGameState_TE::OnRep_Round()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TE.OnRep_Round");
		
		AYGameState_TE_OnRep_Round_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767A40
	 * 		Name   -> Function DreadGame.YGameState_TE.OnPlayerChangedLoadout
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UYLoadoutManagerComponent*                   loadoutManager                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYShipLoadout*                               shipLoadout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYLoadoutFilter*                             Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYGameState_TE::OnPlayerChangedLoadout(class UYLoadoutManagerComponent* loadoutManager, class UYShipLoadout* shipLoadout, class UYLoadoutFilter* Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TE.OnPlayerChangedLoadout");
		
		AYGameState_TE_OnPlayerChangedLoadout_Params params {};
		params.loadoutManager = loadoutManager;
		params.shipLoadout = shipLoadout;
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007475A0
	 * 		Name   -> Function DreadGame.YGameState_TE.ClientTeamEliminationPlayersChanged
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		struct FYTeamEliminationHUDTeamInfo                teamsInfo                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void AYGameState_TE::ClientTeamEliminationPlayersChanged(const struct FYTeamEliminationHUDTeamInfo& teamsInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TE.ClientTeamEliminationPlayersChanged");
		
		AYGameState_TE_ClientTeamEliminationPlayersChanged_Params params {};
		params.teamsInfo = teamsInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_TE.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_TE::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_TE");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768EC0
	 * 		Name   -> Function DreadGame.YGameState_TM.OnRep_OTSDataReplicatedToLocalServer
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_TM::OnRep_OTSDataReplicatedToLocalServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TM.OnRep_OTSDataReplicatedToLocalServer");
		
		AYGameState_TM_OnRep_OTSDataReplicatedToLocalServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757660
	 * 		Name   -> Function DreadGame.YGameState_TM.GetQuestTextList
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               isMainObjective                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FText AYGameState_TM::GetQuestTextList(bool isMainObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TM.GetQuestTextList");
		
		AYGameState_TM_GetQuestTextList_Params params {};
		params.isMainObjective = isMainObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744360
	 * 		Name   -> Function DreadGame.YGameState_TM.CheckOTSDataAvailability
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYGameState_TM::CheckOTSDataAvailability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGameState_TM.CheckOTSDataAvailability");
		
		AYGameState_TM_CheckOTSDataAvailability_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_TM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_TM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_TM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_TurboTDM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_TurboTDM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_TurboTDM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_VisualAttraction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_VisualAttraction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_VisualAttraction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Tutorial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Tutorial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Tutorial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYGameState_Outpost.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYGameState_Outpost::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameState_Outpost");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGameViewportClient.OnScreenshotProcessed__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGameViewportClient::OnScreenshotProcessed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGameViewportClient.OnScreenshotProcessed__DelegateSignature");
		
		UYGameViewportClient_OnScreenshotProcessed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGameViewportClient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGameViewportClient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGameViewportClient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVoiceLineEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVoiceLineEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVoiceLineEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A4A0
	 * 		Name   -> Function DreadGame.YGenericCharacterVoiceLines.GetVoiceLineToPlay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYKismetGameplayConditionQueryContext*       queryContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYVoiceLineUnique* UYGenericCharacterVoiceLines::GetVoiceLineToPlay(const class FName& EventName, class UYKismetGameplayConditionQueryContext* queryContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGenericCharacterVoiceLines.GetVoiceLineToPlay");
		
		UYGenericCharacterVoiceLines_GetVoiceLineToPlay_Params params {};
		params.EventName = EventName;
		params.queryContext = queryContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGenericCharacterVoiceLines.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGenericCharacterVoiceLines::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGenericCharacterVoiceLines");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGenericVoiceLineLoader.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGenericVoiceLineLoader::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGenericVoiceLineLoader");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGFxInputCharRestrictions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGFxInputCharRestrictions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGFxInputCharRestrictions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770820
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.SendBIEvent
	 * 		Flags  -> (Final, Native, Public, Const)
	 * Parameters:
	 * 		class FString                                      Type                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      parentName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::SendBIEvent(const class FString& Type, int32_t ID, const class FString& Name, const class FString& parentName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.SendBIEvent");
		
		UYGFxMoviePlayer_SendBIEvent_Params params {};
		params.Type = Type;
		params.ID = ID;
		params.Name = Name;
		params.parentName = parentName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F700
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.RequestBugReporterIssueTypes
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::RequestBugReporterIssueTypes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.RequestBugReporterIssueTypes");
		
		UYGFxMoviePlayer_RequestBugReporterIssueTypes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EF40
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.RemoveLocalUserSettings
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::RemoveLocalUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.RemoveLocalUserSettings");
		
		UYGFxMoviePlayer_RemoveLocalUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C830
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OpenWebpage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OpenWebpage(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OpenWebpage");
		
		UYGFxMoviePlayer_OpenWebpage_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B890
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnUpdateKeyboardSettingsData
	 * 		Flags  -> (Native, Public)
	 */
	void UYGFxMoviePlayer::OnUpdateKeyboardSettingsData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnUpdateKeyboardSettingsData");
		
		UYGFxMoviePlayer_OnUpdateKeyboardSettingsData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B810
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnUpdateGammaPicture
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnUpdateGammaPicture(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnUpdateGammaPicture");
		
		UYGFxMoviePlayer_OnUpdateGammaPicture_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YGFxMoviePlayer.OnUIReadyForInit__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYGFxMoviePlayer::OnUIReadyForInit__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YGFxMoviePlayer.OnUIReadyForInit__DelegateSignature");
		
		UYGFxMoviePlayer_OnUIReadyForInit__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B7D0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnUIReadyForInit
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::OnUIReadyForInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnUIReadyForInit");
		
		UYGFxMoviePlayer_OnUIReadyForInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AC80
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnSubmitBugReport
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		TArray<class FString>                              param0                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              param1                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              param2                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnSubmitBugReport(TArray<class FString> param0, TArray<class FString> param1, TArray<class FString> param2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnSubmitBugReport");
		
		UYGFxMoviePlayer_OnSubmitBugReport_Params params {};
		params.param0 = param0;
		params.param1 = param1;
		params.param2 = param2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769EF0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnSaveHotkeys
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::OnSaveHotkeys()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnSaveHotkeys");
		
		UYGFxMoviePlayer_OnSaveHotkeys_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769CB0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnResetHotkeys
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::OnResetHotkeys()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnResetHotkeys");
		
		UYGFxMoviePlayer_OnResetHotkeys_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769BB0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnRequestToolTipDataSecondaryLoadout
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            tooltipForcedType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            variationIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnRequestToolTipDataSecondaryLoadout(int32_t itemID, int32_t tooltipForcedType, int32_t variationIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnRequestToolTipDataSecondaryLoadout");
		
		UYGFxMoviePlayer_OnRequestToolTipDataSecondaryLoadout_Params params {};
		params.itemID = itemID;
		params.tooltipForcedType = tooltipForcedType;
		params.variationIndex = variationIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769AF0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnRequestToolTipDataItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            tooltipForcedType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnRequestToolTipDataItemId(int32_t itemID, int32_t tooltipForcedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnRequestToolTipDataItemId");
		
		UYGFxMoviePlayer_OnRequestToolTipDataItemId_Params params {};
		params.itemID = itemID;
		params.tooltipForcedType = tooltipForcedType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769AD0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnRequestSettingsData
	 * 		Flags  -> (Native, Public)
	 */
	void UYGFxMoviePlayer::OnRequestSettingsData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnRequestSettingsData");
		
		UYGFxMoviePlayer_OnRequestSettingsData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769A90
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnRequestScoreboardData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::OnRequestScoreboardData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnRequestScoreboardData");
		
		UYGFxMoviePlayer_OnRequestScoreboardData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769710
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnRequestMouseEventChange
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class FString                                      ActionName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            mouseConstantId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               shiftDown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               altDown                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               ctrlDown                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnRequestMouseEventChange(const class FString& ActionName, int32_t mouseConstantId, bool shiftDown, bool altDown, bool ctrlDown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnRequestMouseEventChange");
		
		UYGFxMoviePlayer_OnRequestMouseEventChange_Params params {};
		params.ActionName = ActionName;
		params.mouseConstantId = mouseConstantId;
		params.shiftDown = shiftDown;
		params.altDown = altDown;
		params.ctrlDown = ctrlDown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769520
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnRequestKeybindChange
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class FString                                      ActionName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            keyCode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               shiftDown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               altDown                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               ctrlDown                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnRequestKeybindChange(const class FString& ActionName, int32_t keyCode, bool shiftDown, bool altDown, bool ctrlDown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnRequestKeybindChange");
		
		UYGFxMoviePlayer_OnRequestKeybindChange_Params params {};
		params.ActionName = ActionName;
		params.keyCode = keyCode;
		params.shiftDown = shiftDown;
		params.altDown = altDown;
		params.ctrlDown = ctrlDown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007693E0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnRequestAVSMAvailability
	 * 		Flags  -> (Native, Public)
	 */
	void UYGFxMoviePlayer::OnRequestAVSMAvailability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnRequestAVSMAvailability");
		
		UYGFxMoviePlayer_OnRequestAVSMAvailability_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766B80
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnOverlayMenuButtonClicked
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		int32_t                                            buttonID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnOverlayMenuButtonClicked(int32_t buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnOverlayMenuButtonClicked");
		
		UYGFxMoviePlayer_OnOverlayMenuButtonClicked_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765DC0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnOpenCustomerSupport
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::OnOpenCustomerSupport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnOpenCustomerSupport");
		
		UYGFxMoviePlayer_OnOpenCustomerSupport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764090
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnGFxMovieInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::OnGFxMovieInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnGFxMovieInitialized");
		
		UYGFxMoviePlayer_OnGFxMovieInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763830
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnCustomerSupportMouseWheelEvent
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DeltaX                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DeltaY                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnCustomerSupportMouseWheelEvent(int32_t X, int32_t Y, int32_t DeltaX, int32_t DeltaY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnCustomerSupportMouseWheelEvent");
		
		UYGFxMoviePlayer_OnCustomerSupportMouseWheelEvent_Params params {};
		params.X = X;
		params.Y = Y;
		params.DeltaX = DeltaX;
		params.DeltaY = DeltaY;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763730
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnCustomerSupportMouseMoveEvent
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMouseOut                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnCustomerSupportMouseMoveEvent(int32_t X, int32_t Y, bool bMouseOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnCustomerSupportMouseMoveEvent");
		
		UYGFxMoviePlayer_OnCustomerSupportMouseMoveEvent_Params params {};
		params.X = X;
		params.Y = Y;
		params.bMouseOut = bMouseOut;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763630
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnCustomerSupportMouseClickEvent
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bButtonDown                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::OnCustomerSupportMouseClickEvent(int32_t X, int32_t Y, bool bButtonDown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnCustomerSupportMouseClickEvent");
		
		UYGFxMoviePlayer_OnCustomerSupportMouseClickEvent_Params params {};
		params.X = X;
		params.Y = Y;
		params.bButtonDown = bButtonDown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007632A0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnCloseCustomerSupport
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer::OnCloseCustomerSupport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnCloseCustomerSupport");
		
		UYGFxMoviePlayer_OnCloseCustomerSupport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.OnAcknowledgePawnPossesion
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 */
	void UYGFxMoviePlayer::OnAcknowledgePawnPossesion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.OnAcknowledgePawnPossesion");
		
		UYGFxMoviePlayer_OnAcknowledgePawnPossesion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007486F0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.CloseUserActionDialog
	 * 		Flags  -> (Native, Public)
	 */
	void UYGFxMoviePlayer::CloseUserActionDialog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.CloseUserActionDialog");
		
		UYGFxMoviePlayer_CloseUserActionDialog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007443A0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.CheckSettingDependency
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      Category                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::CheckSettingDependency(const class FString& Category, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.CheckSettingDependency");
		
		UYGFxMoviePlayer_CheckSettingDependency_Params params {};
		params.Category = Category;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073C600
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.ASPlayAudioEvent
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::ASPlayAudioEvent(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.ASPlayAudioEvent");
		
		UYGFxMoviePlayer_ASPlayAudioEvent_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741930
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer.ApplyUserSettings
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<float>                                      settingsAudio                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<float>                                      settingsChat                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<float>                                      settingsControls                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<float>                                      settingsGame                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<float>                                      settingsGraphics                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<float>                                      settingsAdvancedGraphics                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer::ApplyUserSettings(TArray<float>* settingsAudio, TArray<float>* settingsChat, TArray<float>* settingsControls, TArray<float>* settingsGame, TArray<float>* settingsGraphics, TArray<float>* settingsAdvancedGraphics)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer.ApplyUserSettings");
		
		UYGFxMoviePlayer_ApplyUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (settingsAudio != nullptr)
			*settingsAudio = params.settingsAudio;
		if (settingsChat != nullptr)
			*settingsChat = params.settingsChat;
		if (settingsControls != nullptr)
			*settingsControls = params.settingsControls;
		if (settingsGame != nullptr)
			*settingsGame = params.settingsGame;
		if (settingsGraphics != nullptr)
			*settingsGraphics = params.settingsGraphics;
		if (settingsAdvancedGraphics != nullptr)
			*settingsAdvancedGraphics = params.settingsAdvancedGraphics;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGFxMoviePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGFxMoviePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGFxMoviePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AAC0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.SetScoreboardVisibility
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               IsVisible                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::SetScoreboardVisibility(bool IsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.SetScoreboardVisibility");
		
		UYGFxMoviePlayer_YEndOfMatch_SetScoreboardVisibility_Params params {};
		params.IsVisible = IsVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AA40
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.SetScoreboardFadeInTime
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              fadeInTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::SetScoreboardFadeInTime(float fadeInTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.SetScoreboardFadeInTime");
		
		UYGFxMoviePlayer_YEndOfMatch_SetScoreboardFadeInTime_Params params {};
		params.fadeInTime = fadeInTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B990
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnUserTypedMessage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      author                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            filterId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      recipient                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::OnUserTypedMessage(const class FString& author, const class FString& message, int32_t filterId, const class FString& recipient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnUserTypedMessage");
		
		UYGFxMoviePlayer_YEndOfMatch_OnUserTypedMessage_Params params {};
		params.author = author;
		params.message = message;
		params.filterId = filterId;
		params.recipient = recipient;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769AB0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnRequestScoreboardData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::OnRequestScoreboardData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnRequestScoreboardData");
		
		UYGFxMoviePlayer_YEndOfMatch_OnRequestScoreboardData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769A70
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnRequestResultData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::OnRequestResultData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnRequestResultData");
		
		UYGFxMoviePlayer_YEndOfMatch_OnRequestResultData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnMovieLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::OnMovieLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnMovieLoaded");
		
		UYGFxMoviePlayer_YEndOfMatch_OnMovieLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763F70
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnFriendlistItem
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      friendId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::OnFriendlistItem(int32_t Action, const class FString& friendId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnFriendlistItem");
		
		UYGFxMoviePlayer_YEndOfMatch_OnFriendlistItem_Params params {};
		params.Action = Action;
		params.friendId = friendId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763B50
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnEomChatTextFieldClicked
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            chatMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YEndOfMatch::OnEomChatTextFieldClicked(int32_t chatMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YEndOfMatch.OnEomChatTextFieldClicked");
		
		UYGFxMoviePlayer_YEndOfMatch_OnEomChatTextFieldClicked_Params params {};
		params.chatMode = chatMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGFxMoviePlayer_YEndOfMatch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGFxMoviePlayer_YEndOfMatch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGFxMoviePlayer_YEndOfMatch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E190
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.ShowQuestUpdate
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      questTitle                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            pastValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            currentValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::ShowQuestUpdate(int32_t Type, const class FString& questTitle, int32_t pastValue, int32_t currentValue, int32_t MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.ShowQuestUpdate");
		
		UYGFxMoviePlayer_YHud_ShowQuestUpdate_Params params {};
		params.Type = Type;
		params.questTitle = questTitle;
		params.pastValue = pastValue;
		params.currentValue = currentValue;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B720
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.SetTargetMarkerSphericalPositionSettings
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               IsEnabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              xScaleValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              yScaleValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::SetTargetMarkerSphericalPositionSettings(bool IsEnabled, float xScaleValue, float yScaleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.SetTargetMarkerSphericalPositionSettings");
		
		UYGFxMoviePlayer_YHud_SetTargetMarkerSphericalPositionSettings_Params params {};
		params.IsEnabled = IsEnabled;
		params.xScaleValue = xScaleValue;
		params.yScaleValue = yScaleValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777A70
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.SetGameModeName
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      gameModeName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::SetGameModeName(const class FString& gameModeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.SetGameModeName");
		
		UYGFxMoviePlayer_YHud_SetGameModeName_Params params {};
		params.gameModeName = gameModeName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007778F0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.SetGameMode
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYGameModeType                                     gameModeHUDType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::SetGameMode(EYGameModeType gameModeHUDType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.SetGameMode");
		
		UYGFxMoviePlayer_YHud_SetGameMode_Params params {};
		params.gameModeHUDType = gameModeHUDType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076BF80
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnUserTypedMessageBroadcast
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      author                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            filterId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      recipient                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               broadcastToPlayers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnUserTypedMessageBroadcast(const class FString& author, const class FString& message, int32_t filterId, const class FString& recipient, bool broadcastToPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnUserTypedMessageBroadcast");
		
		UYGFxMoviePlayer_YHud_OnUserTypedMessageBroadcast_Params params {};
		params.author = author;
		params.message = message;
		params.filterId = filterId;
		params.recipient = recipient;
		params.broadcastToPlayers = broadcastToPlayers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076BBC0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnUserTypedMessage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      author                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            filterId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      recipient                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnUserTypedMessage(const class FString& author, const class FString& message, int32_t filterId, const class FString& recipient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnUserTypedMessage");
		
		UYGFxMoviePlayer_YHud_OnUserTypedMessage_Params params {};
		params.author = author;
		params.message = message;
		params.filterId = filterId;
		params.recipient = recipient;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B970
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnUserEscapesChat
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::OnUserEscapesChat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnUserEscapesChat");
		
		UYGFxMoviePlayer_YHud_OnUserEscapesChat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B540
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnToggleReadyUpRequest
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::OnToggleReadyUpRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnToggleReadyUpRequest");
		
		UYGFxMoviePlayer_YHud_OnToggleReadyUpRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AFD0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnSubmitDialogResult
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            responseCode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnSubmitDialogResult(int32_t Type, int32_t itemID, int32_t responseCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnSubmitDialogResult");
		
		UYGFxMoviePlayer_YHud_OnSubmitDialogResult_Params params {};
		params.Type = Type;
		params.itemID = itemID;
		params.responseCode = responseCode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AB00
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnStartEoM
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::OnStartEoM()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnStartEoM");
		
		UYGFxMoviePlayer_YHud_OnStartEoM_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A840
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnSkipVideoButtonPressed
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::OnSkipVideoButtonPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnSkipVideoButtonPressed");
		
		UYGFxMoviePlayer_YHud_OnSkipVideoButtonPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A220
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnSelectSpawnNode
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      selectedNode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnSelectSpawnNode(const class FString& selectedNode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnSelectSpawnNode");
		
		UYGFxMoviePlayer_YHud_OnSelectSpawnNode_Params params {};
		params.selectedNode = selectedNode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A0A0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnSelectLoadout
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      selectedLoadoutID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      spawnNode                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnSelectLoadout(const class FString& selectedLoadoutID, const class FString& spawnNode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnSelectLoadout");
		
		UYGFxMoviePlayer_YHud_OnSelectLoadout_Params params {};
		params.selectedLoadoutID = selectedLoadoutID;
		params.spawnNode = spawnNode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769F10
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnScaleformCaptureMouseInput
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               capture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnScaleformCaptureMouseInput(bool capture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnScaleformCaptureMouseInput");
		
		UYGFxMoviePlayer_YHud_OnScaleformCaptureMouseInput_Params params {};
		params.capture = capture;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769900
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnRequestNewLoadout
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      classId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnRequestNewLoadout(const class FString& classId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnRequestNewLoadout");
		
		UYGFxMoviePlayer_YHud_OnRequestNewLoadout_Params params {};
		params.classId = classId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765DE0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnOpenCustomization
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            selectedClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnOpenCustomization(int32_t selectedClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnOpenCustomization");
		
		UYGFxMoviePlayer_YHud_OnOpenCustomization_Params params {};
		params.selectedClass = selectedClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007650B0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnMenuOptionsToggle
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnMenuOptionsToggle(bool option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnMenuOptionsToggle");
		
		UYGFxMoviePlayer_YHud_OnMenuOptionsToggle_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764190
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnHandleRespawnInteraction
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::OnHandleRespawnInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnHandleRespawnInteraction");
		
		UYGFxMoviePlayer_YHud_OnHandleRespawnInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764150
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnGetCustomLoadouts
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::OnGetCustomLoadouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnGetCustomLoadouts");
		
		UYGFxMoviePlayer_YHud_OnGetCustomLoadouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764130
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnGetAbilityData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::OnGetAbilityData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnGetAbilityData");
		
		UYGFxMoviePlayer_YHud_OnGetAbilityData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763200
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnClickPlayerCard
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnClickPlayerCard(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnClickPlayerCard");
		
		UYGFxMoviePlayer_YHud_OnClickPlayerCard_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763110
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnClickLoadout
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      selectedLoadout                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnClickLoadout(const class FString& selectedLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnClickLoadout");
		
		UYGFxMoviePlayer_YHud_OnClickLoadout_Params params {};
		params.selectedLoadout = selectedLoadout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762FA0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.OnCheckUserName
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      recipient                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::OnCheckUserName(const class FString& recipient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.OnCheckUserName");
		
		UYGFxMoviePlayer_YHud_OnCheckUserName_Params params {};
		params.recipient = recipient;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007486F0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.CloseUserActionDialog
	 * 		Flags  -> (Native, Public)
	 */
	void UYGFxMoviePlayer_YHud::CloseUserActionDialog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.CloseUserActionDialog");
		
		UYGFxMoviePlayer_YHud_CloseUserActionDialog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742120
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YHud.BlockChat
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               block                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YHud::BlockChat(bool block)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YHud.BlockChat");
		
		UYGFxMoviePlayer_YHud_BlockChat_Params params {};
		params.block = block;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGFxMoviePlayer_YHud.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGFxMoviePlayer_YHud::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGFxMoviePlayer_YHud");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYUINavigationElement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYUINavigationElement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YUINavigationElement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YProgressionManagerBase.OnInitialization__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYProgressionManagerBase::OnInitialization__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YProgressionManagerBase.OnInitialization__DelegateSignature");
		
		UYProgressionManagerBase_OnInitialization__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E50000
	 * 		Name   -> Function DreadGame.YProgressionManagerBase.InitializeFromPlayerData
	 * 		Flags  -> (Native, Protected)
	 */
	void UYProgressionManagerBase::InitializeFromPlayerData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProgressionManagerBase.InitializeFromPlayerData");
		
		UYProgressionManagerBase_InitializeFromPlayerData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744280
	 * 		Name   -> Function DreadGame.YProgressionManagerBase.CheckForPlayerRankUp
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AYPlayerReplicationInfo*                     pri                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            newReputation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYProgressionManagerBase::CheckForPlayerRankUp(class AYPlayerReplicationInfo* pri, int32_t newReputation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProgressionManagerBase.CheckForPlayerRankUp");
		
		UYProgressionManagerBase_CheckForPlayerRankUp_Params params {};
		params.pri = pri;
		params.newReputation = newReputation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProgressionManagerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProgressionManagerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProgressionManagerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DC30
	 * 		Name   -> Function DreadGame.YItemIDList.GetBaseItemID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            inflatedItemID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYItemIDList::STATIC_GetBaseItemID(int32_t inflatedItemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YItemIDList.GetBaseItemID");
		
		UYItemIDList_GetBaseItemID_Params params {};
		params.inflatedItemID = inflatedItemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYItemIDList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYItemIDList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YItemIDList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YProgressionManagerClient.OnPlayerRankUp__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            newRank                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYProgressionManagerClient::OnPlayerRankUp__DelegateSignature(int32_t newRank)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YProgressionManagerClient.OnPlayerRankUp__DelegateSignature");
		
		UYProgressionManagerClient_OnPlayerRankUp__DelegateSignature_Params params {};
		params.newRank = newRank;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D920
	 * 		Name   -> Function DreadGame.YProgressionManagerClient.InitializeShopItems
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYProgressionManagerClient::InitializeShopItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProgressionManagerClient.InitializeShopItems");
		
		UYProgressionManagerClient_InitializeShopItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D7E0
	 * 		Name   -> Function DreadGame.YProgressionManagerClient.InitializeProgressionUnlocks
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYProgressionManagerClient::InitializeProgressionUnlocks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProgressionManagerClient.InitializeProgressionUnlocks");
		
		UYProgressionManagerClient_InitializeProgressionUnlocks_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProgressionManagerClient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProgressionManagerClient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProgressionManagerClient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FA20
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.RequestVanityPurchaseData
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               hasPriceChanged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::RequestVanityPurchaseData(int32_t itemID, bool hasPriceChanged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.RequestVanityPurchaseData");
		
		UYGFxMoviePlayer_YMenu_RequestVanityPurchaseData_Params params {};
		params.itemID = itemID;
		params.hasPriceChanged = hasPriceChanged;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F960
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.RequestTechTreePurchaseData
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               caatalogIsReloaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::RequestTechTreePurchaseData(int32_t itemID, bool caatalogIsReloaded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.RequestTechTreePurchaseData");
		
		UYGFxMoviePlayer_YMenu_RequestTechTreePurchaseData_Params params {};
		params.itemID = itemID;
		params.caatalogIsReloaded = caatalogIsReloaded;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F720
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.RequestBundlePurchaseData
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               checkGroupItems                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               hasPriceChanged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::RequestBundlePurchaseData(int32_t itemID, bool checkGroupItems, bool hasPriceChanged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.RequestBundlePurchaseData");
		
		UYGFxMoviePlayer_YMenu_RequestBundlePurchaseData_Params params {};
		params.itemID = itemID;
		params.checkGroupItems = checkGroupItems;
		params.hasPriceChanged = hasPriceChanged;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E110
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.PurchaseItem
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::PurchaseItem(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.PurchaseItem");
		
		UYGFxMoviePlayer_YMenu_PurchaseItem_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076BDF0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnUserTypedMessage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      author                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            filterId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      recipient                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::OnUserTypedMessage(const class FString& author, const class FString& message, int32_t filterId, const class FString& recipient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnUserTypedMessage");
		
		UYGFxMoviePlayer_YMenu_OnUserTypedMessage_Params params {};
		params.author = author;
		params.message = message;
		params.filterId = filterId;
		params.recipient = recipient;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A790
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnShowNextPromotionPopup
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YMenu::OnShowNextPromotionPopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnShowNextPromotionPopup");
		
		UYGFxMoviePlayer_YMenu_OnShowNextPromotionPopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007699F0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestNewMenuMetaState
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            selectedMetaState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::OnRequestNewMenuMetaState(int32_t selectedMetaState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestNewMenuMetaState");
		
		UYGFxMoviePlayer_YMenu_OnRequestNewMenuMetaState_Params params {};
		params.selectedMetaState = selectedMetaState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007694A0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestInformationPanelRibbonId
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::OnRequestInformationPanelRibbonId(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestInformationPanelRibbonId");
		
		UYGFxMoviePlayer_YMenu_OnRequestInformationPanelRibbonId_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769480
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestCloseTransmission
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYGFxMoviePlayer_YMenu::OnRequestCloseTransmission()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestCloseTransmission");
		
		UYGFxMoviePlayer_YMenu_OnRequestCloseTransmission_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769400
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestCharacterPreview
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::OnRequestCharacterPreview(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnRequestCharacterPreview");
		
		UYGFxMoviePlayer_YMenu_OnRequestCharacterPreview_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007651D0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnMenuSelection
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            selectedSate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::OnMenuSelection(int32_t selectedSate, int32_t Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnMenuSelection");
		
		UYGFxMoviePlayer_YMenu_OnMenuSelection_Params params {};
		params.selectedSate = selectedSate;
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765140
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.OnMenuOptionsToggle
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::OnMenuOptionsToggle(bool option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.OnMenuOptionsToggle");
		
		UYGFxMoviePlayer_YMenu_OnMenuOptionsToggle_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743600
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.CalloutButtonDisableByName
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::CalloutButtonDisableByName(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.CalloutButtonDisableByName");
		
		UYGFxMoviePlayer_YMenu_CalloutButtonDisableByName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007434A0
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu.CalloutButtonDisableByID
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ID                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYGFxMoviePlayer_YMenu::CalloutButtonDisableByID(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu.CalloutButtonDisableByID");
		
		UYGFxMoviePlayer_YMenu_CalloutButtonDisableByID_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGFxMoviePlayer_YMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGFxMoviePlayer_YMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGFxMoviePlayer_YMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F450
	 * 		Name   -> Function DreadGame.YGFxMoviePlayer_YMenu_PS4.IsOnConsole
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	bool UYGFxMoviePlayer_YMenu_PS4::STATIC_IsOnConsole()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YGFxMoviePlayer_YMenu_PS4.IsOnConsole");
		
		UYGFxMoviePlayer_YMenu_PS4_IsOnConsole_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGFxMoviePlayer_YMenu_PS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGFxMoviePlayer_YMenu_PS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGFxMoviePlayer_YMenu_PS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHangarStateManager.OnPropertiesChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYHangarStateManager::OnPropertiesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHangarStateManager.OnPropertiesChanged");
		
		AYHangarStateManager_OnPropertiesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYHangarStateManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYHangarStateManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHangarStateManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YHavocProgressionComponent.OnLoadoutAsyncLoaded
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHavocProgressionComponent::OnLoadoutAsyncLoaded(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocProgressionComponent.OnLoadoutAsyncLoaded");
		
		UYHavocProgressionComponent_OnLoadoutAsyncLoaded_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762660
	 * 		Name   -> Function DreadGame.YHavocProgressionComponent.OnApplyBoostAndModifiersData
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYHavocProgressionComponent::OnApplyBoostAndModifiersData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocProgressionComponent.OnApplyBoostAndModifiersData");
		
		UYHavocProgressionComponent_OnApplyBoostAndModifiersData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D2B0
	 * 		Name   -> Function DreadGame.YHavocProgressionComponent.Initialize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHavocProgressionComponent::Initialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocProgressionComponent.Initialize");
		
		UYHavocProgressionComponent_Initialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757F50
	 * 		Name   -> Function DreadGame.YHavocProgressionComponent.GetSelectedUpgrades
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class FName> UYHavocProgressionComponent::GetSelectedUpgrades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocProgressionComponent.GetSelectedUpgrades");
		
		UYHavocProgressionComponent_GetSelectedUpgrades_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHavocProgressionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHavocProgressionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHavocProgressionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHavocRewardsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHavocRewardsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHavocRewardsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YHavocWaveModifierComponent.OnEnteredWaveStartingState
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYHavocWaveModifierComponent::OnEnteredWaveStartingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocWaveModifierComponent.OnEnteredWaveStartingState");
		
		UYHavocWaveModifierComponent_OnEnteredWaveStartingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YHavocWaveModifierComponent.OnEnteredUpgradeSelection
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYHavocWaveModifierComponent::OnEnteredUpgradeSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocWaveModifierComponent.OnEnteredUpgradeSelection");
		
		UYHavocWaveModifierComponent_OnEnteredUpgradeSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CD40
	 * 		Name   -> Function DreadGame.YHavocWaveModifierComponent.GetActivePermanentEnemyModifierNames
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class FName> UYHavocWaveModifierComponent::GetActivePermanentEnemyModifierNames()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocWaveModifierComponent.GetActivePermanentEnemyModifierNames");
		
		UYHavocWaveModifierComponent_GetActivePermanentEnemyModifierNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CD10
	 * 		Name   -> Function DreadGame.YHavocWaveModifierComponent.GetActiveModifierNames
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class FName> UYHavocWaveModifierComponent::GetActiveModifierNames()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHavocWaveModifierComponent.GetActiveModifierNames");
		
		UYHavocWaveModifierComponent_GetActiveModifierNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHavocWaveModifierComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHavocWaveModifierComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHavocWaveModifierComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780C90
	 * 		Name   -> Function DreadGame.YHealthComponent.TakeHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              healingAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 healingInstigator                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UYHealthComponent::TakeHealth(float healingAmount, class AController* healingInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.TakeHealth");
		
		UYHealthComponent_TakeHealth_Params params {};
		params.healingAmount = healingAmount;
		params.healingInstigator = healingInstigator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780BC0
	 * 		Name   -> Function DreadGame.YHealthComponent.TakeDamage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 dctr                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UYHealthComponent::TakeDamage(float Damage, class AController* dctr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.TakeDamage");
		
		UYHealthComponent_TakeDamage_Params params {};
		params.Damage = Damage;
		params.dctr = dctr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768D80
	 * 		Name   -> Function DreadGame.YHealthComponent.OnRep_Health
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYHealthComponent::OnRep_Health()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.OnRep_Health");
		
		UYHealthComponent_OnRep_Health_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007670C0
	 * 		Name   -> Function DreadGame.YHealthComponent.OnOwningPawnDied
	 * 		Flags  -> (Final, Native, Private, HasDefaults)
	 * Parameters:
	 * 		float                                              ActualDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         FHitComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Momentum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHealthComponent::OnOwningPawnDied(float ActualDamage, class AController* Killer, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, const class FName& BoneName, const struct FVector& Momentum, class UDamageType* DamageType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.OnOwningPawnDied");
		
		UYHealthComponent_OnOwningPawnDied_Params params {};
		params.ActualDamage = ActualDamage;
		params.Killer = Killer;
		params.HitLocation = HitLocation;
		params.FHitComponent = FHitComponent;
		params.BoneName = BoneName;
		params.Momentum = Momentum;
		params.DamageType = DamageType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761060
	 * 		Name   -> Function DreadGame.YHealthComponent.ModifyRegeneration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UYHealthComponent::ModifyRegeneration(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.ModifyRegeneration");
		
		UYHealthComponent_ModifyRegeneration_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E9B0
	 * 		Name   -> Function DreadGame.YHealthComponent.IsFull
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHealthComponent::IsFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.IsFull");
		
		UYHealthComponent_IsFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E570
	 * 		Name   -> Function DreadGame.YHealthComponent.IsDead
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHealthComponent::IsDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.IsDead");
		
		UYHealthComponent_IsDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757A90
	 * 		Name   -> Function DreadGame.YHealthComponent.GetRecentDamage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UYHealthComponent::GetRecentDamage(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.GetRecentDamage");
		
		UYHealthComponent_GetRecentDamage_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754430
	 * 		Name   -> Function DreadGame.YHealthComponent.GetModifiedMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYHealthComponent::GetModifiedMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.GetModifiedMaxHealth");
		
		UYHealthComponent_GetModifiedMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007543A0
	 * 		Name   -> Function DreadGame.YHealthComponent.GetModifiedHealthRegeneration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYHealthComponent::GetModifiedHealthRegeneration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.GetModifiedHealthRegeneration");
		
		UYHealthComponent_GetModifiedHealthRegeneration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753FD0
	 * 		Name   -> Function DreadGame.YHealthComponent.GetMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYHealthComponent::GetMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.GetMaxHealth");
		
		UYHealthComponent_GetMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007507D0
	 * 		Name   -> Function DreadGame.YHealthComponent.GetCurrentHealthPercentage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYHealthComponent::GetCurrentHealthPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.GetCurrentHealthPercentage");
		
		UYHealthComponent_GetCurrentHealthPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007507B0
	 * 		Name   -> Function DreadGame.YHealthComponent.GetCurrentHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYHealthComponent::GetCurrentHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHealthComponent.GetCurrentHealth");
		
		UYHealthComponent_GetCurrentHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHealthComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHealthComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHealthComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHitzoneEditorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHitzoneEditorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHitzoneEditorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHitzoneRuntimeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHitzoneRuntimeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHitzoneRuntimeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHoveringFXSetup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHoveringFXSetup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHoveringFXSetup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHoveringFX.Tick
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHoveringFX::Tick(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHoveringFX.Tick");
		
		UYHoveringFX_Tick_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007796F0
	 * 		Name   -> Function DreadGame.YHoveringFX.SetOwnerPawn
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHoveringFX::SetOwnerPawn(class AYPawn* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHoveringFX.SetOwnerPawn");
		
		UYHoveringFX_SetOwnerPawn_Params params {};
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775640
	 * 		Name   -> Function DreadGame.YHoveringFX.SetActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHoveringFX::SetActive(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHoveringFX.SetActive");
		
		UYHoveringFX_SetActive_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHoveringFX.OnInit
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHoveringFX::OnInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHoveringFX.OnInit");
		
		UYHoveringFX_OnInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHoveringFX.Hit
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FHitResult                                  Result                                                     (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UYHoveringFX::Hit(const struct FHitResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHoveringFX.Hit");
		
		UYHoveringFX_Hit_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755A30
	 * 		Name   -> Function DreadGame.YHoveringFX.GetOwnerPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYPawn* UYHoveringFX::GetOwnerPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHoveringFX.GetOwnerPawn");
		
		UYHoveringFX_GetOwnerPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750AC0
	 * 		Name   -> Function DreadGame.YHoveringFX.GetCurrentPSTemplate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UParticleSystem* UYHoveringFX::GetCurrentPSTemplate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHoveringFX.GetCurrentPSTemplate");
		
		UYHoveringFX_GetCurrentPSTemplate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHoveringFX.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHoveringFX::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHoveringFX");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHoveringFXComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHoveringFXComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHoveringFXComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077DF70
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptManager.ShowOverlayPrompt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYPromptType                                       promptType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PromptManager::ShowOverlayPrompt(EYPromptType promptType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptManager.ShowOverlayPrompt");
		
		UYHUDWidget_PromptManager_ShowOverlayPrompt_Params params {};
		params.promptType = promptType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077DE90
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptManager.ShowOpenEnergyWheelPrompt
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        descriptionIdentifier                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   customPosition                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PromptManager::ShowOpenEnergyWheelPrompt(const class FName& descriptionIdentifier, const struct FVector2D& customPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptManager.ShowOpenEnergyWheelPrompt");
		
		UYHUDWidget_PromptManager_ShowOpenEnergyWheelPrompt_Params params {};
		params.descriptionIdentifier = descriptionIdentifier;
		params.customPosition = customPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D900
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptManager.ShowInformationPrompt
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        descriptionIdentifier                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<EYPlayerActionName>                         actionNamesToDismiss                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        delegateName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               useCustomPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              customPositionX                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              customPositionY                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               pauseGame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              displayTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               consumeInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PromptManager::ShowInformationPrompt(const class FName& descriptionIdentifier, TArray<EYPlayerActionName> actionNamesToDismiss, const class FName& delegateName, bool useCustomPosition, float customPositionX, float customPositionY, bool pauseGame, float displayTime, bool consumeInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptManager.ShowInformationPrompt");
		
		UYHUDWidget_PromptManager_ShowInformationPrompt_Params params {};
		params.descriptionIdentifier = descriptionIdentifier;
		params.actionNamesToDismiss = actionNamesToDismiss;
		params.delegateName = delegateName;
		params.useCustomPosition = useCustomPosition;
		params.customPositionX = customPositionX;
		params.customPositionY = customPositionY;
		params.pauseGame = pauseGame;
		params.displayTime = displayTime;
		params.consumeInput = consumeInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DF70
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptManager.PromptActionNameDisplayStringsRequested
	 * 		Flags  -> (Final, Native, Private, Const)
	 * Parameters:
	 * 		class FString                                      ActionName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FText> UYHUDWidget_PromptManager::PromptActionNameDisplayStringsRequested(const class FString& ActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptManager.PromptActionNameDisplayStringsRequested");
		
		UYHUDWidget_PromptManager_PromptActionNameDisplayStringsRequested_Params params {};
		params.ActionName = ActionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076CA60
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptManager.OverlayInteractiveCloseTriggered
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYHUDWidget_PromptManager::OverlayInteractiveCloseTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptManager.OverlayInteractiveCloseTriggered");
		
		UYHUDWidget_PromptManager_OverlayInteractiveCloseTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YHUDWidget_PromptManager.OnPromptDismissed__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void UYHUDWidget_PromptManager::OnPromptDismissed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YHUDWidget_PromptManager.OnPromptDismissed__DelegateSignature");
		
		UYHUDWidget_PromptManager_OnPromptDismissed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AB70
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptManager.DismissAllPrompts
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_PromptManager::DismissAllPrompts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptManager.DismissAllPrompts");
		
		UYHUDWidget_PromptManager_DismissAllPrompts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PromptManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PromptManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PromptManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007844E0
	 * 		Name   -> Function DreadGame.YHUD.WeaponFired
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      firingPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::WeaponFired(class AYPawn* firingPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.WeaponFired");
		
		AYHUD_WeaponFired_Params params {};
		params.firingPawn = firingPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007835E0
	 * 		Name   -> Function DreadGame.YHUD.UpdateHavocUpgradePanel
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::UpdateHavocUpgradePanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.UpdateHavocUpgradePanel");
		
		AYHUD_UpdateHavocUpgradePanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007815F0
	 * 		Name   -> Function DreadGame.YHUD.ToggleTargetMarkers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bToggleOn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::ToggleTargetMarkers(bool bToggleOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ToggleTargetMarkers");
		
		AYHUD_ToggleTargetMarkers_Params params {};
		params.bToggleOn = bToggleOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781490
	 * 		Name   -> Function DreadGame.YHUD.ToggleProjectileMarkers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bToggleOn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::ToggleProjectileMarkers(bool bToggleOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ToggleProjectileMarkers");
		
		AYHUD_ToggleProjectileMarkers_Params params {};
		params.bToggleOn = bToggleOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007813D0
	 * 		Name   -> Function DreadGame.YHUD.ToggleMinimap
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bToggleOn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::ToggleMinimap(bool bToggleOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ToggleMinimap");
		
		AYHUD_ToggleMinimap_Params params {};
		params.bToggleOn = bToggleOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781340
	 * 		Name   -> Function DreadGame.YHUD.ToggleLoadoutSelection
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               IsActive                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::ToggleLoadoutSelection(bool IsActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ToggleLoadoutSelection");
		
		AYHUD_ToggleLoadoutSelection_Params params {};
		params.IsActive = IsActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007811E0
	 * 		Name   -> Function DreadGame.YHUD.ToggleComponentGroupLock
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTutorialComponentLock                            lockGroup                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               lockState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::ToggleComponentGroupLock(EYTutorialComponentLock lockGroup, bool lockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ToggleComponentGroupLock");
		
		AYHUD_ToggleComponentGroupLock_Params params {};
		params.lockGroup = lockGroup;
		params.lockState = lockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780FF0
	 * 		Name   -> Function DreadGame.YHUD.ToggleAllComponentGroupLocks
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               lockState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::ToggleAllComponentGroupLocks(bool lockState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ToggleAllComponentGroupLocks");
		
		AYHUD_ToggleAllComponentGroupLocks_Params params {};
		params.lockState = lockState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780060
	 * 		Name   -> Function DreadGame.YHUD.StopAndCloseMovie
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYHUD::StopAndCloseMovie()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.StopAndCloseMovie");
		
		AYHUD_StopAndCloseMovie_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FB60
	 * 		Name   -> Function DreadGame.YHUD.StartEndOfMatchFlow
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::StartEndOfMatchFlow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.StartEndOfMatchFlow");
		
		AYHUD_StartEndOfMatchFlow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E4B0
	 * 		Name   -> Function DreadGame.YHUD.ShowUMGHUD
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::ShowUMGHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ShowUMGHUD");
		
		AYHUD_ShowUMGHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E010
	 * 		Name   -> Function DreadGame.YHUD.ShowQuestUpdate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      questTitle                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            pastValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            currentValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::ShowQuestUpdate(const class FString& questTitle, int32_t Type, int32_t pastValue, int32_t currentValue, int32_t MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ShowQuestUpdate");
		
		AYHUD_ShowQuestUpdate_Params params {};
		params.questTitle = questTitle;
		params.Type = Type;
		params.pastValue = pastValue;
		params.currentValue = currentValue;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077DFF0
	 * 		Name   -> Function DreadGame.YHUD.ShowPS4UMGEndOfMatch
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::ShowPS4UMGEndOfMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ShowPS4UMGEndOfMatch");
		
		AYHUD_ShowPS4UMGEndOfMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E9A320
	 * 		Name   -> Function DreadGame.YHUD.ShowHUD
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AYHUD::ShowHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ShowHUD");
		
		AYHUD_ShowHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D5B0
	 * 		Name   -> Function DreadGame.YHUD.ShowGFxHUD
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::ShowGFxHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ShowGFxHUD");
		
		AYHUD_ShowGFxHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007852B0
	 * 		Name   -> Function DreadGame.YHUD.shouldUseUMGhud
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool AYHUD::shouldUseUMGhud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.shouldUseUMGhud");
		
		AYHUD_shouldUseUMGhud_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00BBF7F0
	 * 		Name   -> Function DreadGame.YHUD.ShouldUsePS4Managers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYHUD::ShouldUsePS4Managers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ShouldUsePS4Managers");
		
		AYHUD_ShouldUsePS4Managers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CDB0
	 * 		Name   -> Function DreadGame.YHUD.SetYPawn
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::SetYPawn(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.SetYPawn");
		
		AYHUD_SetYPawn_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B3F0
	 * 		Name   -> Function DreadGame.YHUD.SetState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYHudState                                         hudState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::SetState(EYHudState hudState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.SetState");
		
		AYHUD_SetState_Params params {};
		params.hudState = hudState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A7D0
	 * 		Name   -> Function DreadGame.YHUD.SetRespawnNextWaveTimer
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              nextWaveTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               respawnPossible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::SetRespawnNextWaveTimer(float nextWaveTime, bool respawnPossible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.SetRespawnNextWaveTimer");
		
		AYHUD_SetRespawnNextWaveTimer_Params params {};
		params.nextWaveTime = nextWaveTime;
		params.respawnPossible = respawnPossible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778170
	 * 		Name   -> Function DreadGame.YHUD.SetHideHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               hudIsHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::SetHideHUD(bool hudIsHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.SetHideHUD");
		
		AYHUD_SetHideHUD_Params params {};
		params.hudIsHidden = hudIsHidden;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007779F0
	 * 		Name   -> Function DreadGame.YHUD.SetGameModeMatchOver
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            matchEndState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::SetGameModeMatchOver(int32_t matchEndState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.SetGameModeMatchOver");
		
		AYHUD_SetGameModeMatchOver_Params params {};
		params.matchEndState = matchEndState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777860
	 * 		Name   -> Function DreadGame.YHUD.SetForcedRespawnNextWaveState
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               forced                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::SetForcedRespawnNextWaveState(bool forced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.SetForcedRespawnNextWaveState");
		
		AYHUD_SetForcedRespawnNextWaveState_Params params {};
		params.forced = forced;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770270
	 * 		Name   -> Function DreadGame.YHUD.ScaleformPostMatchAnimationCompleted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::ScaleformPostMatchAnimationCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ScaleformPostMatchAnimationCompleted");
		
		AYHUD_ScaleformPostMatchAnimationCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E780
	 * 		Name   -> Function DreadGame.YHUD.RefreshLoadouts
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::RefreshLoadouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.RefreshLoadouts");
		
		AYHUD_RefreshLoadouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.ReceiveStartEndOfMatchTransition
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYHUD::ReceiveStartEndOfMatchTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ReceiveStartEndOfMatchTransition");
		
		AYHUD_ReceiveStartEndOfMatchTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.ReceiveShieldDamaged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYHUD::ReceiveShieldDamaged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.ReceiveShieldDamaged");
		
		AYHUD_ReceiveShieldDamaged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D250
	 * 		Name   -> Function DreadGame.YHUD.PlayMovieCutscene
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMediaPlayer*                                MediaPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      widgetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::PlayMovieCutscene(class UMediaPlayer* MediaPlayer, class UClass* widgetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.PlayMovieCutscene");
		
		AYHUD_PlayMovieCutscene_Params params {};
		params.MediaPlayer = MediaPlayer;
		params.widgetType = widgetType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DB80
	 * 		Name   -> Function DreadGame.YHUD.PlayerOverlapsVisibilityVolumeStart
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      overlappingPawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::PlayerOverlapsVisibilityVolumeStart(class AYPawn* overlappingPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.PlayerOverlapsVisibilityVolumeStart");
		
		AYHUD_PlayerOverlapsVisibilityVolumeStart_Params params {};
		params.overlappingPawn = overlappingPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DB00
	 * 		Name   -> Function DreadGame.YHUD.PlayerOverlapsVisibilityVolumeEnd
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      overlappingPawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::PlayerOverlapsVisibilityVolumeEnd(class AYPawn* overlappingPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.PlayerOverlapsVisibilityVolumeEnd");
		
		AYHUD_PlayerOverlapsVisibilityVolumeEnd_Params params {};
		params.overlappingPawn = overlappingPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076CA80
	 * 		Name   -> Function DreadGame.YHUD.OwningPawnDied
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OwningPawnDied()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OwningPawnDied");
		
		AYHUD_OwningPawnDied_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C400
	 * 		Name   -> Function DreadGame.YHUD.OpenChatWhisperWindow
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OpenChatWhisperWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OpenChatWhisperWindow");
		
		AYHUD_OpenChatWhisperWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C3E0
	 * 		Name   -> Function DreadGame.YHUD.OpenChatTeamWindow
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OpenChatTeamWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OpenChatTeamWindow");
		
		AYHUD_OpenChatTeamWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C3C0
	 * 		Name   -> Function DreadGame.YHUD.OpenChatSquadWindow
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OpenChatSquadWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OpenChatSquadWindow");
		
		AYHUD_OpenChatSquadWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C3A0
	 * 		Name   -> Function DreadGame.YHUD.OpenChatAllWindow
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OpenChatAllWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OpenChatAllWindow");
		
		AYHUD_OpenChatAllWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B950
	 * 		Name   -> Function DreadGame.YHUD.OnUserEscapedChat
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnUserEscapedChat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnUserEscapedChat");
		
		AYHUD_OnUserEscapedChat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B8B0
	 * 		Name   -> Function DreadGame.YHUD.OnUpdateReplicationInfo
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnUpdateReplicationInfo(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnUpdateReplicationInfo");
		
		AYHUD_OnUpdateReplicationInfo_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B790
	 * 		Name   -> Function DreadGame.YHUD.OnUIReadyForInit
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYHUD::OnUIReadyForInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnUIReadyForInit");
		
		AYHUD_OnUIReadyForInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.OnSkipVideoTriggeredBP
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYHUD::OnSkipVideoTriggeredBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnSkipVideoTriggeredBP");
		
		AYHUD_OnSkipVideoTriggeredBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A860
	 * 		Name   -> Function DreadGame.YHUD.OnSkipVideoTriggered
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnSkipVideoTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnSkipVideoTriggered");
		
		AYHUD_OnSkipVideoTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.OnScore
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Points                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnScore(int32_t Points, const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnScore");
		
		AYHUD_OnScore_Params params {};
		params.Points = Points;
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769FA0
	 * 		Name   -> Function DreadGame.YHUD.OnScheduledScoreboardUpdateTriggered
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYHUD::OnScheduledScoreboardUpdateTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnScheduledScoreboardUpdateTriggered");
		
		AYHUD_OnScheduledScoreboardUpdateTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YHUD.OnScaleformMovieHUDInitialized__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYHUD::OnScaleformMovieHUDInitialized__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YHUD.OnScaleformMovieHUDInitialized__DelegateSignature");
		
		AYHUD_OnScaleformMovieHUDInitialized__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768A60
	 * 		Name   -> Function DreadGame.YHUD.OnRecipentNameEntered
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      recipient                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnRecipentNameEntered(const class FString& recipient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnRecipentNameEntered");
		
		AYHUD_OnRecipentNameEntered_Params params {};
		params.recipient = recipient;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768870
	 * 		Name   -> Function DreadGame.YHUD.OnQuestProgression
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        questName                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            previousProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            currentProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            valueForCompleting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnQuestProgression(const class FText& questName, int32_t previousProgress, int32_t currentProgress, int32_t valueForCompleting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnQuestProgression");
		
		AYHUD_OnQuestProgression_Params params {};
		params.questName = questName;
		params.previousProgress = previousProgress;
		params.currentProgress = currentProgress;
		params.valueForCompleting = valueForCompleting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768720
	 * 		Name   -> Function DreadGame.YHUD.OnQuestCompletion
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        questName                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            previousProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            valueForCompleting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnQuestCompletion(const class FText& questName, int32_t previousProgress, int32_t valueForCompleting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnQuestCompletion");
		
		AYHUD_OnQuestCompletion_Params params {};
		params.questName = questName;
		params.previousProgress = previousProgress;
		params.valueForCompleting = valueForCompleting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768410
	 * 		Name   -> Function DreadGame.YHUD.OnPlayerStartHomeBaseSpawned
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPlayerStartHomeBase*                       base                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnPlayerStartHomeBaseSpawned(class AYPlayerStartHomeBase* base)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlayerStartHomeBaseSpawned");
		
		AYHUD_OnPlayerStartHomeBaseSpawned_Params params {};
		params.base = base;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768390
	 * 		Name   -> Function DreadGame.YHUD.OnPlayerStartHomeBaseEndPlay
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPlayerStartHomeBase*                       base                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnPlayerStartHomeBaseEndPlay(class AYPlayerStartHomeBase* base)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlayerStartHomeBaseEndPlay");
		
		AYHUD_OnPlayerStartHomeBaseEndPlay_Params params {};
		params.base = base;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768150
	 * 		Name   -> Function DreadGame.YHUD.OnPlayerReputationChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPlayerReplicationInfo*                     owningPRI                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            newReputation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnPlayerReputationChanged(class AYPlayerReplicationInfo* owningPRI, int32_t newReputation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlayerReputationChanged");
		
		AYHUD_OnPlayerReputationChanged_Params params {};
		params.owningPRI = owningPRI;
		params.newReputation = newReputation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767ED0
	 * 		Name   -> Function DreadGame.YHUD.OnPlayerRepScoringEvent
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class AYPlayerReplicationInfo*                     pri                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYPositiveReinforcement                     posReinf                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnPlayerRepScoringEvent(class AYPlayerReplicationInfo* pri, const struct FYPositiveReinforcement& posReinf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlayerRepScoringEvent");
		
		AYHUD_OnPlayerRepScoringEvent_Params params {};
		params.pri = pri;
		params.posReinf = posReinf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007657F0
	 * 		Name   -> Function DreadGame.YHUD.OnPlayerRepDataChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPlayerReplicationInfo*                     pri                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnPlayerRepDataChanged(class AYPlayerReplicationInfo* pri)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlayerRepDataChanged");
		
		AYHUD_OnPlayerRepDataChanged_Params params {};
		params.pri = pri;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.OnPlayerLeftKillzone
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYHUD::OnPlayerLeftKillzone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlayerLeftKillzone");
		
		AYHUD_OnPlayerLeftKillzone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.OnPlayerInsideKillzone
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              countdown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnPlayerInsideKillzone(float countdown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlayerInsideKillzone");
		
		AYHUD_OnPlayerInsideKillzone_Params params {};
		params.countdown = countdown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767A20
	 * 		Name   -> Function DreadGame.YHUD.OnPlaybackFinished
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnPlaybackFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPlaybackFinished");
		
		AYHUD_OnPlaybackFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767850
	 * 		Name   -> Function DreadGame.YHUD.OnPerkProgression
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            perkID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        description                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            previousProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            currentProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            valueForCompleting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnPerkProgression(int32_t perkID, const class FText& description, int32_t previousProgress, int32_t currentProgress, int32_t valueForCompleting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnPerkProgression");
		
		AYHUD_OnPerkProgression_Params params {};
		params.perkID = perkID;
		params.description = description;
		params.previousProgress = previousProgress;
		params.currentProgress = currentProgress;
		params.valueForCompleting = valueForCompleting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766C10
	 * 		Name   -> Function DreadGame.YHUD.OnOverlayMenuButtonPressed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            buttonID                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnOverlayMenuButtonPressed(int32_t buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnOverlayMenuButtonPressed");
		
		AYHUD_OnOverlayMenuButtonPressed_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007657F0
	 * 		Name   -> Function DreadGame.YHUD.OnNPCRepDataChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYNPCReplicationInfo*                        npcri                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnNPCRepDataChanged(class AYNPCReplicationInfo* npcri)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnNPCRepDataChanged");
		
		AYHUD_OnNPCRepDataChanged_Params params {};
		params.npcri = npcri;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765290
	 * 		Name   -> Function DreadGame.YHUD.OnMinimapVolumeSpawned
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYMinimapVolume*                             minimapVol                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnMinimapVolumeSpawned(class AYMinimapVolume* minimapVol)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnMinimapVolumeSpawned");
		
		AYHUD_OnMinimapVolumeSpawned_Params params {};
		params.minimapVol = minimapVol;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764BD0
	 * 		Name   -> Function DreadGame.YHUD.OnLoadoutSelected
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      spawnNode                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnLoadoutSelected(const class FName& loadoutId, const class FString& spawnNode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnLoadoutSelected");
		
		AYHUD_OnLoadoutSelected_Params params {};
		params.loadoutId = loadoutId;
		params.spawnNode = spawnNode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764A90
	 * 		Name   -> Function DreadGame.YHUD.OnLoadoutClicked
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnLoadoutClicked(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnLoadoutClicked");
		
		AYHUD_OnLoadoutClicked_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.OnLeaveWarpJumpVolume
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYHUD::OnLeaveWarpJumpVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnLeaveWarpJumpVolume");
		
		AYHUD_OnLeaveWarpJumpVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007641D0
	 * 		Name   -> Function DreadGame.YHUD.OnHealthBelowThresholdStop
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnHealthBelowThresholdStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnHealthBelowThresholdStop");
		
		AYHUD_OnHealthBelowThresholdStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007641B0
	 * 		Name   -> Function DreadGame.YHUD.OnHealthBelowThresholdStart
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnHealthBelowThresholdStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnHealthBelowThresholdStart");
		
		AYHUD_OnHealthBelowThresholdStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007640B0
	 * 		Name   -> Function DreadGame.YHUD.OnGFxMoviePlayerInit
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYHUD::OnGFxMoviePlayerInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnGFxMoviePlayerInit");
		
		AYHUD_OnGFxMoviePlayerInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763E90
	 * 		Name   -> Function DreadGame.YHUD.OnFetchCustomLoadouts
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnFetchCustomLoadouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnFetchCustomLoadouts");
		
		AYHUD_OnFetchCustomLoadouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763E70
	 * 		Name   -> Function DreadGame.YHUD.OnFetchAbilityData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnFetchAbilityData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnFetchAbilityData");
		
		AYHUD_OnFetchAbilityData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.OnEnterWarpJumpVolume
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYHUD::OnEnterWarpJumpVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnEnterWarpJumpVolume");
		
		AYHUD_OnEnterWarpJumpVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YHUD.OnEnemySpotted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnEnemySpotted__DelegateSignature(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YHUD.OnEnemySpotted__DelegateSignature");
		
		AYHUD_OnEnemySpotted__DelegateSignature_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007639B0
	 * 		Name   -> Function DreadGame.YHUD.OnEndOfMatch
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::OnEndOfMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnEndOfMatch");
		
		AYHUD_OnEndOfMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762D80
	 * 		Name   -> Function DreadGame.YHUD.OnChatMessageSent
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      author                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            filterId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      recipient                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               broadcastToPlayers                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnChatMessageSent(const class FString& author, const class FString& message, int32_t filterId, const class FString& recipient, bool broadcastToPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnChatMessageSent");
		
		AYHUD_OnChatMessageSent_Params params {};
		params.author = author;
		params.message = message;
		params.filterId = filterId;
		params.recipient = recipient;
		params.broadcastToPlayers = broadcastToPlayers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007627C0
	 * 		Name   -> Function DreadGame.YHUD.OnBlockChat
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               block                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYHUD::OnBlockChat(bool block)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.OnBlockChat");
		
		AYHUD_OnBlockChat_Params params {};
		params.block = block;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUD.MessageOnObjectiveCompleted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYTeam                                             objectiveTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::MessageOnObjectiveCompleted(EYTeam objectiveTeam, const class FString& message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.MessageOnObjectiveCompleted");
		
		AYHUD_MessageOnObjectiveCompleted_Params params {};
		params.objectiveTeam = objectiveTeam;
		params.message = message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760360
	 * 		Name   -> Function DreadGame.YHUD.LoadAndPlayMovie
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      movieName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ResX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ResY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::LoadAndPlayMovie(const class FString& movieName, int32_t ResX, int32_t ResY, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.LoadAndPlayMovie");
		
		AYHUD_LoadAndPlayMovie_Params params {};
		params.movieName = movieName;
		params.ResX = ResX;
		params.ResY = ResY;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F570
	 * 		Name   -> Function DreadGame.YHUD.IsPlayingVideo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYHUD::IsPlayingVideo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.IsPlayingVideo");
		
		AYHUD_IsPlayingVideo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ECE0
	 * 		Name   -> Function DreadGame.YHUD.IsHudReadyForInit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYHUD::IsHudReadyForInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.IsHudReadyForInit");
		
		AYHUD_IsHudReadyForInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D040
	 * 		Name   -> Function DreadGame.YHUD.InitHUDWeapon
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::InitHUDWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.InitHUDWeapon");
		
		AYHUD_InitHUDWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D020
	 * 		Name   -> Function DreadGame.YHUD.InitHUDGameState
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::InitHUDGameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.InitHUDGameState");
		
		AYHUD_InitHUDGameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D000
	 * 		Name   -> Function DreadGame.YHUD.InitGameMode
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::InitGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.InitGameMode");
		
		AYHUD_InitGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C920
	 * 		Name   -> Function DreadGame.YHUD.HideGFxHUD
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::HideGFxHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.HideGFxHUD");
		
		AYHUD_HideGFxHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C900
	 * 		Name   -> Function DreadGame.YHUD.HideClassSelection
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::HideClassSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.HideClassSelection");
		
		AYHUD_HideClassSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A070
	 * 		Name   -> Function DreadGame.YHUD.GetUMGStyleContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYHUDWidget_StyleContainer* AYHUD::GetUMGStyleContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetUMGStyleContainer");
		
		AYHUD_GetUMGStyleContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A070
	 * 		Name   -> Function DreadGame.YHUD.GetStyleContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYHUDWidget_StyleContainer* AYHUD::GetStyleContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetStyleContainer");
		
		AYHUD_GetStyleContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759300
	 * 		Name   -> Function DreadGame.YHUD.GetState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYHudState AYHUD::GetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetState");
		
		AYHUD_GetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758E40
	 * 		Name   -> Function DreadGame.YHUD.GetSortedPlayerArray
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            teamID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AYPawn*> AYHUD::GetSortedPlayerArray(int32_t teamID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetSortedPlayerArray");
		
		AYHUD_GetSortedPlayerArray_Params params {};
		params.teamID = teamID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758600
	 * 		Name   -> Function DreadGame.YHUD.GetShipClassName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      currentPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString AYHUD::GetShipClassName(class AYPawn* currentPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetShipClassName");
		
		AYHUD_GetShipClassName_Params params {};
		params.currentPawn = currentPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757420
	 * 		Name   -> Function DreadGame.YHUD.GetPromptManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYHUDWidget_PromptManager* AYHUD::GetPromptManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetPromptManager");
		
		AYHUD_GetPromptManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754E50
	 * 		Name   -> Function DreadGame.YHUD.GetMoviePlayer
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYGFxMoviePlayer* AYHUD::GetMoviePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetMoviePlayer");
		
		AYHUD_GetMoviePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752470
	 * 		Name   -> Function DreadGame.YHUD.GetHUDWidgetManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYHUDWidgetManager* AYHUD::GetHUDWidgetManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetHUDWidgetManager");
		
		AYHUD_GetHUDWidgetManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750CA0
	 * 		Name   -> Function DreadGame.YHUD.GetCurrentTargetedPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AYPawn* AYHUD::GetCurrentTargetedPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetCurrentTargetedPawn");
		
		AYHUD_GetCurrentTargetedPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E0E0
	 * 		Name   -> Function DreadGame.YHUD.GetCanvasSize
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector2D AYHUD::GetCanvasSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.GetCanvasSize");
		
		AYHUD_GetCanvasSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BA90
	 * 		Name   -> Function DreadGame.YHUD.EnergyStateChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYEnergySystemState                                energyState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::EnergyStateChanged(EYEnergySystemState energyState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.EnergyStateChanged");
		
		AYHUD_EnergyStateChanged_Params params {};
		params.energyState = energyState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BA50
	 * 		Name   -> Function DreadGame.YHUD.EnergyDepleted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYHUD::EnergyDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.EnergyDepleted");
		
		AYHUD_EnergyDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A720
	 * 		Name   -> Function DreadGame.YHUD.DetermineActionNameDisplayTexts
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      ActionName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               useFormatString                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class FText> AYHUD::DetermineActionNameDisplayTexts(const class FString& ActionName, bool useFormatString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.DetermineActionNameDisplayTexts");
		
		AYHUD_DetermineActionNameDisplayTexts_Params params {};
		params.ActionName = ActionName;
		params.useFormatString = useFormatString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A350
	 * 		Name   -> Function DreadGame.YHUD.DebugShowTeammateVoiceChat
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        teammateName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::DebugShowTeammateVoiceChat(const class FName& teammateName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.DebugShowTeammateVoiceChat");
		
		AYHUD_DebugShowTeammateVoiceChat_Params params {};
		params.teammateName = teammateName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748630
	 * 		Name   -> Function DreadGame.YHUD.CloseEnergyWheel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYHUD::CloseEnergyWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.CloseEnergyWheel");
		
		AYHUD_CloseEnergyWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742A10
	 * 		Name   -> Function DreadGame.YHUD.BuildSeparatedActionTextsFromLocalizedString
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FText                                        textToDisplay                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FYActionMappingText> AYHUD::BuildSeparatedActionTextsFromLocalizedString(const class FText& textToDisplay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.BuildSeparatedActionTextsFromLocalizedString");
		
		AYHUD_BuildSeparatedActionTextsFromLocalizedString_Params params {};
		params.textToDisplay = textToDisplay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007428F0
	 * 		Name   -> Function DreadGame.YHUD.BuildActionKeyArray
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<EYPlayerActionName>                         actionNamesToDismiss                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FKey> AYHUD::BuildActionKeyArray(TArray<EYPlayerActionName> actionNamesToDismiss)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.BuildActionKeyArray");
		
		AYHUD_BuildActionKeyArray_Params params {};
		params.actionNamesToDismiss = actionNamesToDismiss;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073C6A0
	 * 		Name   -> Function DreadGame.YHUD.AbilityActivated
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      firingPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHUD::AbilityActivated(class AYPawn* firingPawn, class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUD.AbilityActivated");
		
		AYHUD_AbilityActivated_Params params {};
		params.firingPawn = firingPawn;
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D4A0
	 * 		Name   -> Function DreadGame.YPlayerCameraManager.ActivatePostProcessEffect
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        effectName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInstance*                           postprocessMI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        scalarParameterName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 animationCurve                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerCameraManager::ActivatePostProcessEffect(const class FName& effectName, class UMaterialInstance* postprocessMI, const class FName& scalarParameterName, class UCurveFloat* animationCurve, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerCameraManager.ActivatePostProcessEffect");
		
		AYPlayerCameraManager_ActivatePostProcessEffect_Params params {};
		params.effectName = effectName;
		params.postprocessMI = postprocessMI;
		params.scalarParameterName = scalarParameterName;
		params.animationCurve = animationCurve;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerCameraManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerCameraManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerCameraManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076CF60
	 * 		Name   -> Function DreadGame.YWidgetBlueprintLibrary.PlayAnimationToFinalState
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UUserWidget*                                 targetWidget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidgetAnimation*                            Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidgetBlueprintLibrary::STATIC_PlayAnimationToFinalState(class UUserWidget* targetWidget, class UWidgetAnimation* Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidgetBlueprintLibrary.PlayAnimationToFinalState");
		
		UYWidgetBlueprintLibrary_PlayAnimationToFinalState_Params params {};
		params.targetWidget = targetWidget;
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B0B0
	 * 		Name   -> Function DreadGame.YWidgetBlueprintLibrary.DrawSpline
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPaintContext                               context                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   InStart                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   InStartDir                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   InEnd                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   InEndDir                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InThickness                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Tint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWidgetBlueprintLibrary::STATIC_DrawSpline(struct FPaintContext* context, const struct FVector2D& InStart, const struct FVector2D& InStartDir, const struct FVector2D& InEnd, const struct FVector2D& InEndDir, float InThickness, const struct FLinearColor& Tint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidgetBlueprintLibrary.DrawSpline");
		
		UYWidgetBlueprintLibrary_DrawSpline_Params params {};
		params.InStart = InStart;
		params.InStartDir = InStartDir;
		params.InEnd = InEnd;
		params.InEndDir = InEndDir;
		params.InThickness = InThickness;
		params.Tint = Tint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (context != nullptr)
			*context = params.context;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AEE0
	 * 		Name   -> Function DreadGame.YWidgetBlueprintLibrary.DrawCircle
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPaintContext                               context                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   InCenterOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InRadius                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InThickness                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Tint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseDrawSpaceCoords                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWidgetBlueprintLibrary::STATIC_DrawCircle(struct FPaintContext* context, const struct FVector2D& InCenterOffset, float InRadius, float InThickness, const struct FLinearColor& Tint, bool bUseDrawSpaceCoords)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidgetBlueprintLibrary.DrawCircle");
		
		UYWidgetBlueprintLibrary_DrawCircle_Params params {};
		params.InCenterOffset = InCenterOffset;
		params.InRadius = InRadius;
		params.InThickness = InThickness;
		params.Tint = Tint;
		params.bUseDrawSpaceCoords = bUseDrawSpaceCoords;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (context != nullptr)
			*context = params.context;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748EC0
	 * 		Name   -> Function DreadGame.YWidgetBlueprintLibrary.ConvertWorldToMinimapPos
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     inWorldPos                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     inWorldExtent                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     inWorldOrigin                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FYUIMinimapCanvas                           mapCanvas                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UYWidgetBlueprintLibrary::STATIC_ConvertWorldToMinimapPos(const struct FVector& inWorldPos, const struct FVector& inWorldExtent, const struct FVector& inWorldOrigin, const struct FYUIMinimapCanvas& mapCanvas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidgetBlueprintLibrary.ConvertWorldToMinimapPos");
		
		UYWidgetBlueprintLibrary_ConvertWorldToMinimapPos_Params params {};
		params.inWorldPos = inWorldPos;
		params.inWorldExtent = inWorldExtent;
		params.inWorldOrigin = inWorldOrigin;
		params.mapCanvas = mapCanvas;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748D00
	 * 		Name   -> Function DreadGame.YWidgetBlueprintLibrary.ConvertUUToMetric
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              distanceInUU                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYWidgetBlueprintLibrary::STATIC_ConvertUUToMetric(float distanceInUU)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidgetBlueprintLibrary.ConvertUUToMetric");
		
		UYWidgetBlueprintLibrary_ConvertUUToMetric_Params params {};
		params.distanceInUU = distanceInUU;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748BF0
	 * 		Name   -> Function DreadGame.YWidgetBlueprintLibrary.ConvertRelativeToScreenSpace
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              inRelX                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              inRelY                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYUIMinimapCanvas                           mapCanvas                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UYWidgetBlueprintLibrary::STATIC_ConvertRelativeToScreenSpace(float inRelX, float inRelY, const struct FYUIMinimapCanvas& mapCanvas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidgetBlueprintLibrary.ConvertRelativeToScreenSpace");
		
		UYWidgetBlueprintLibrary_ConvertRelativeToScreenSpace_Params params {};
		params.inRelX = inRelX;
		params.inRelY = inRelY;
		params.mapCanvas = mapCanvas;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidgetBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidgetBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidgetBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MinimapShipMarker.BP_OnTeamColorChanged
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FColor                                      Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MinimapShipMarker::BP_OnTeamColorChanged(const struct FColor& Color)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MinimapShipMarker.BP_OnTeamColorChanged");
		
		UYHUDWidget_MinimapShipMarker_BP_OnTeamColorChanged_Params params {};
		params.Color = Color;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MinimapShipMarker.BP_OnShipIconChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_MinimapShipMarker::BP_OnShipIconChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MinimapShipMarker.BP_OnShipIconChanged");
		
		UYHUDWidget_MinimapShipMarker_BP_OnShipIconChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_MinimapShipMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_MinimapShipMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_MinimapShipMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C180
	 * 		Name   -> Function DreadGame.YHUDWidget_ScrollBox_PC.SetToStartPosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_ScrollBox_PC::SetToStartPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScrollBox_PC.SetToStartPosition");
		
		UYHUDWidget_ScrollBox_PC_SetToStartPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C140
	 * 		Name   -> Function DreadGame.YHUDWidget_ScrollBox_PC.HandleOnUserScrolled
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              InScrollOffsetFraction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScrollBox_PC::HandleOnUserScrolled(float InScrollOffsetFraction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScrollBox_PC.HandleOnUserScrolled");
		
		UYHUDWidget_ScrollBox_PC_HandleOnUserScrolled_Params params {};
		params.InScrollOffsetFraction = InScrollOffsetFraction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ScrollBox_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ScrollBox_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ScrollBox_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00BC06F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.OnMatchStarted
	 * 		Flags  -> (Native, Public)
	 */
	void UYHUDWidget_Territory::OnMatchStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.OnMatchStarted");
		
		UYHUDWidget_Territory_OnMatchStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765070
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.OnMatchEnded
	 * 		Flags  -> (Native, Public)
	 */
	void UYHUDWidget_Territory::OnMatchEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.OnMatchEnded");
		
		UYHUDWidget_Territory_OnMatchEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnUpdateScore
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_Territory::BP_OnUpdateScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnUpdateScore");
		
		UYHUDWidget_Territory_BP_OnUpdateScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnLinkWidgetStateChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FYPooledLinkWidget                          linkWidget                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Territory::BP_OnLinkWidgetStateChanged(const struct FYPooledLinkWidget& linkWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnLinkWidgetStateChanged");
		
		UYHUDWidget_Territory_BP_OnLinkWidgetStateChanged_Params params {};
		params.linkWidget = linkWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnLinkWidgetPosUpdated
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class UUserWidget*                                 linkWidget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   p1Loc                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   p2Loc                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Territory::BP_OnLinkWidgetPosUpdated(class UUserWidget* linkWidget, const struct FVector2D& p1Loc, const struct FVector2D& p2Loc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnLinkWidgetPosUpdated");
		
		UYHUDWidget_Territory_BP_OnLinkWidgetPosUpdated_Params params {};
		params.linkWidget = linkWidget;
		params.p1Loc = p1Loc;
		params.p2Loc = p2Loc;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnLinkWidgetCreated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FYPooledLinkWidget                          linkWidget                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Territory::BP_OnLinkWidgetCreated(const struct FYPooledLinkWidget& linkWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnLinkWidgetCreated");
		
		UYHUDWidget_Territory_BP_OnLinkWidgetCreated_Params params {};
		params.linkWidget = linkWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnInitialize
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_Territory::BP_OnInitialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnInitialize");
		
		UYHUDWidget_Territory_BP_OnInitialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnCPWidgetUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UUserWidget*                                 newCPWidget                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHighlighted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Territory::BP_OnCPWidgetUpdated(class UUserWidget* newCPWidget, bool bHighlighted, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnCPWidgetUpdated");
		
		UYHUDWidget_Territory_BP_OnCPWidgetUpdated_Params params {};
		params.newCPWidget = newCPWidget;
		params.bHighlighted = bHighlighted;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnCPWidgetCreated
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class UUserWidget*                                 newCPWidget                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYCapturePoint*                              CPActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      t1Color                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      t2Color                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsOnMinimap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Territory::BP_OnCPWidgetCreated(class UUserWidget* newCPWidget, class AYCapturePoint* CPActor, const struct FColor& t1Color, const struct FColor& t2Color, bool bIsOnMinimap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnCPWidgetCreated");
		
		UYHUDWidget_Territory_BP_OnCPWidgetCreated_Params params {};
		params.newCPWidget = newCPWidget;
		params.CPActor = CPActor;
		params.t1Color = t1Color;
		params.t2Color = t2Color;
		params.bIsOnMinimap = bIsOnMinimap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Territory.BP_OnBubbleWidgetUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UUserWidget*                                 bubbleWidget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHighlighted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Territory::BP_OnBubbleWidgetUpdated(class UUserWidget* bubbleWidget, int32_t percentage, bool bHighlighted, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Territory.BP_OnBubbleWidgetUpdated");
		
		UYHUDWidget_Territory_BP_OnBubbleWidgetUpdated_Params params {};
		params.bubbleWidget = bubbleWidget;
		params.percentage = percentage;
		params.bHighlighted = bHighlighted;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_Territory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_Territory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_Territory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D370
	 * 		Name   -> Function DreadGame.YHUDWidgetManager.ShowAllWidgets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidgetManager::ShowAllWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidgetManager.ShowAllWidgets");
		
		UYHUDWidgetManager_ShowAllWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D2B0
	 * 		Name   -> Function DreadGame.YHUDWidgetManager.ShouldUsePS4Widgets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidgetManager::ShouldUsePS4Widgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidgetManager.ShouldUsePS4Widgets");
		
		UYHUDWidgetManager_ShouldUsePS4Widgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761C80
	 * 		Name   -> Function DreadGame.YHUDWidgetManager.NotifyAllWidgetReferencesSet
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYHUDWidgetManager::NotifyAllWidgetReferencesSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidgetManager.NotifyAllWidgetReferencesSet");
		
		UYHUDWidgetManager_NotifyAllWidgetReferencesSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F0C0
	 * 		Name   -> Function DreadGame.YHUDWidgetManager.IsLocalPlayerFighter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidgetManager::IsLocalPlayerFighter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidgetManager.IsLocalPlayerFighter");
		
		UYHUDWidgetManager_IsLocalPlayerFighter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C830
	 * 		Name   -> Function DreadGame.YHUDWidgetManager.HideAllWidgets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidgetManager::HideAllWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidgetManager.HideAllWidgets");
		
		UYHUDWidgetManager_HideAllWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A890
	 * 		Name   -> Function DreadGame.YHUDWidgetManager.GetWidgetByType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      classType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYHUDWidget* UYHUDWidgetManager::GetWidgetByType(class UClass* classType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidgetManager.GetWidgetByType");
		
		UYHUDWidgetManager_GetWidgetByType_Params params {};
		params.classType = classType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidgetManager.BP_InitBlueprintLinks
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYGameModeType                                     GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidgetManager::BP_InitBlueprintLinks(EYGameModeType GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidgetManager.BP_InitBlueprintLinks");
		
		UYHUDWidgetManager_BP_InitBlueprintLinks_Params params {};
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidgetManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidgetManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidgetManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YInterface_Talk.SetTalking
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isTalking                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYInterface_Talk::SetTalking(bool isTalking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Talk.SetTalking");
		
		UYInterface_Talk_SetTalking_Params params {};
		params.isTalking = isTalking;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YInterface_Talk.SetQuestGiverMode
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isQuestGiver                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYInterface_Talk::SetQuestGiverMode(bool isQuestGiver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Talk.SetQuestGiverMode");
		
		UYInterface_Talk_SetQuestGiverMode_Params params {};
		params.isQuestGiver = isQuestGiver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YInterface_Talk.SetPosture
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		EYCharacterTalkPosture                             posture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInterface_Talk::SetPosture(EYCharacterTalkPosture posture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInterface_Talk.SetPosture");
		
		UYInterface_Talk_SetPosture_Params params {};
		params.posture = posture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInterface_Talk.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInterface_Talk::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInterface_Talk");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YInventoryManager.OnUpdatedInventory__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYInventoryManager::OnUpdatedInventory__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YInventoryManager.OnUpdatedInventory__DelegateSignature");
		
		UYInventoryManager_OnUpdatedInventory__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YInventoryManager.OnOfferPurchaseCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      offerId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            quantity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInventoryManager::OnOfferPurchaseCompleted__DelegateSignature(int32_t Result, const class FString& offerId, int32_t quantity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YInventoryManager.OnOfferPurchaseCompleted__DelegateSignature");
		
		UYInventoryManager_OnOfferPurchaseCompleted__DelegateSignature_Params params {};
		params.Result = Result;
		params.offerId = offerId;
		params.quantity = quantity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765B40
	 * 		Name   -> Function DreadGame.YInventoryManager.OnOfferPurchaseComplete
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      offerId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            quantity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInventoryManager::OnOfferPurchaseComplete(int32_t Result, const class FString& offerId, int32_t quantity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInventoryManager.OnOfferPurchaseComplete");
		
		UYInventoryManager_OnOfferPurchaseComplete_Params params {};
		params.Result = Result;
		params.offerId = offerId;
		params.quantity = quantity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764640
	 * 		Name   -> Function DreadGame.YInventoryManager.OnItemRemoved
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInventoryManager::OnItemRemoved(int32_t itemID, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInventoryManager.OnItemRemoved");
		
		UYInventoryManager_OnItemRemoved_Params params {};
		params.itemID = itemID;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YInventoryManager.OnItemClaimCompletedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYInventoryManager::OnItemClaimCompletedSignature__DelegateSignature(int32_t itemID, bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YInventoryManager.OnItemClaimCompletedSignature__DelegateSignature");
		
		UYInventoryManager_OnItemClaimCompletedSignature__DelegateSignature_Params params {};
		params.itemID = itemID;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007644C0
	 * 		Name   -> Function DreadGame.YInventoryManager.OnItemClaimComplete
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYInventoryManager::OnItemClaimComplete(int32_t itemID, bool Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInventoryManager.OnItemClaimComplete");
		
		UYInventoryManager_OnItemClaimComplete_Params params {};
		params.itemID = itemID;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764400
	 * 		Name   -> Function DreadGame.YInventoryManager.OnItemAdded
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInventoryManager::OnItemAdded(int32_t itemID, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInventoryManager.OnItemAdded");
		
		UYInventoryManager_OnItemAdded_Params params {};
		params.itemID = itemID;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YInventoryManager.OnInventoryInitialization__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYInventoryManager::OnInventoryInitialization__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YInventoryManager.OnInventoryInitialization__DelegateSignature");
		
		UYInventoryManager_OnInventoryInitialization__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YInventoryManager.OnAddedItem__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            itemID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYInventoryManager::OnAddedItem__DelegateSignature(int32_t itemID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YInventoryManager.OnAddedItem__DelegateSignature");
		
		UYInventoryManager_OnAddedItem__DelegateSignature_Params params {};
		params.itemID = itemID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D640
	 * 		Name   -> Function DreadGame.YInventoryManager.InitializeItemsFromInventory
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYInventoryManager::InitializeItemsFromInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YInventoryManager.InitializeItemsFromInventory");
		
		UYInventoryManager_InitializeItemsFromInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYInventoryManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYInventoryManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YInventoryManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766780
	 * 		Name   -> Function DreadGame.YKillZoneVolume.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYKillZoneVolume::OnOverlapEnd(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKillZoneVolume.OnOverlapEnd");
		
		AYKillZoneVolume_OnOverlapEnd_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766010
	 * 		Name   -> Function DreadGame.YKillZoneVolume.OnOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYKillZoneVolume::OnOverlap(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKillZoneVolume.OnOverlap");
		
		AYKillZoneVolume_OnOverlap_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYKillZoneVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYKillZoneVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YKillZoneVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749240
	 * 		Name   -> Function DreadGame.YKismetGameplayConditionQueryContext.CreateGameplayConditionQueryContext
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class UYKismetGameplayConditionQueryContext* UYKismetGameplayConditionQueryContext::STATIC_CreateGameplayConditionQueryContext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKismetGameplayConditionQueryContext.CreateGameplayConditionQueryContext");
		
		UYKismetGameplayConditionQueryContext_CreateGameplayConditionQueryContext_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740080
	 * 		Name   -> Function DreadGame.YKismetGameplayConditionQueryContext.AddNumberQueryContextComplex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        mainSpecifier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier1                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYKismetGameplayConditionQueryContext::AddNumberQueryContextComplex(float contextValue, const class FName& mainSpecifier, const class FName& additionalSpecifier1, const class FName& additionalSpecifier2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKismetGameplayConditionQueryContext.AddNumberQueryContextComplex");
		
		UYKismetGameplayConditionQueryContext_AddNumberQueryContextComplex_Params params {};
		params.contextValue = contextValue;
		params.mainSpecifier = mainSpecifier;
		params.additionalSpecifier1 = additionalSpecifier1;
		params.additionalSpecifier2 = additionalSpecifier2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FFB0
	 * 		Name   -> Function DreadGame.YKismetGameplayConditionQueryContext.AddNumberQueryContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextSpecifier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYKismetGameplayConditionQueryContext::AddNumberQueryContext(const class FName& contextSpecifier, float contextValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKismetGameplayConditionQueryContext.AddNumberQueryContext");
		
		UYKismetGameplayConditionQueryContext_AddNumberQueryContext_Params params {};
		params.contextSpecifier = contextSpecifier;
		params.contextValue = contextValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FE60
	 * 		Name   -> Function DreadGame.YKismetGameplayConditionQueryContext.AddNameQueryContextComplex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        mainSpecifier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier1                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYKismetGameplayConditionQueryContext::AddNameQueryContextComplex(const class FName& contextValue, const class FName& mainSpecifier, const class FName& additionalSpecifier1, const class FName& additionalSpecifier2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKismetGameplayConditionQueryContext.AddNameQueryContextComplex");
		
		UYKismetGameplayConditionQueryContext_AddNameQueryContextComplex_Params params {};
		params.contextValue = contextValue;
		params.mainSpecifier = mainSpecifier;
		params.additionalSpecifier1 = additionalSpecifier1;
		params.additionalSpecifier2 = additionalSpecifier2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073FDA0
	 * 		Name   -> Function DreadGame.YKismetGameplayConditionQueryContext.AddNameQueryContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextSpecifier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYKismetGameplayConditionQueryContext::AddNameQueryContext(const class FName& contextSpecifier, const class FName& contextValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKismetGameplayConditionQueryContext.AddNameQueryContext");
		
		UYKismetGameplayConditionQueryContext_AddNameQueryContext_Params params {};
		params.contextSpecifier = contextSpecifier;
		params.contextValue = contextValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E640
	 * 		Name   -> Function DreadGame.YKismetGameplayConditionQueryContext.AddBitMaskQueryContextComplex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            contextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        bitMaskIdentifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        mainSpecifier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier1                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        additionalSpecifier2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYKismetGameplayConditionQueryContext::AddBitMaskQueryContextComplex(int32_t contextValue, const class FName& bitMaskIdentifier, const class FName& mainSpecifier, const class FName& additionalSpecifier1, const class FName& additionalSpecifier2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKismetGameplayConditionQueryContext.AddBitMaskQueryContextComplex");
		
		UYKismetGameplayConditionQueryContext_AddBitMaskQueryContextComplex_Params params {};
		params.contextValue = contextValue;
		params.bitMaskIdentifier = bitMaskIdentifier;
		params.mainSpecifier = mainSpecifier;
		params.additionalSpecifier1 = additionalSpecifier1;
		params.additionalSpecifier2 = additionalSpecifier2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E410
	 * 		Name   -> Function DreadGame.YKismetGameplayConditionQueryContext.AddBitMaskQueryContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        contextSpecifier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        bitMaskIdentifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYKismetGameplayConditionQueryContext::AddBitMaskQueryContext(const class FName& contextSpecifier, const class FName& bitMaskIdentifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YKismetGameplayConditionQueryContext.AddBitMaskQueryContext");
		
		UYKismetGameplayConditionQueryContext_AddBitMaskQueryContext_Params params {};
		params.contextSpecifier = contextSpecifier;
		params.bitMaskIdentifier = bitMaskIdentifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYKismetGameplayConditionQueryContext.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYKismetGameplayConditionQueryContext::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YKismetGameplayConditionQueryContext");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C9B0
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.SetUpPawnDelegates
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::SetUpPawnDelegates(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.SetUpPawnDelegates");
		
		UYLEDLightingComponent_SetUpPawnDelegates_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076CBF0
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.PawnIsDead
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		float                                              ActualDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         FHitComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Momentum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::PawnIsDead(float ActualDamage, class AController* Killer, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, const class FName& BoneName, const struct FVector& Momentum, class UDamageType* DamageType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.PawnIsDead");
		
		UYLEDLightingComponent_PawnIsDead_Params params {};
		params.ActualDamage = ActualDamage;
		params.Killer = Killer;
		params.HitLocation = HitLocation;
		params.FHitComponent = FHitComponent;
		params.BoneName = BoneName;
		params.Momentum = Momentum;
		params.DamageType = DamageType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765090
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.OnMatchEnded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYLEDLightingComponent::OnMatchEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.OnMatchEnded");
		
		UYLEDLightingComponent_OnMatchEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007640F0
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.OnGameStateInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYLEDLightingComponent::OnGameStateInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.OnGameStateInitialized");
		
		UYLEDLightingComponent_OnGameStateInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762330
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.OnActiveEnergyWheelFunctionChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             energyWheelFunction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::OnActiveEnergyWheelFunctionChanged(EYEnergyWheelSelection energyWheelFunction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.OnActiveEnergyWheelFunctionChanged");
		
		UYLEDLightingComponent_OnActiveEnergyWheelFunctionChanged_Params params {};
		params.energyWheelFunction = energyWheelFunction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C3E0
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.FinshCoolDownForAbilityKey
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::FinshCoolDownForAbilityKey(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.FinshCoolDownForAbilityKey");
		
		UYLEDLightingComponent_FinshCoolDownForAbilityKey_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CB60
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.AbilityHasTargetLock
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::AbilityHasTargetLock(class AYPawn* Pawn, int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.AbilityHasTargetLock");
		
		UYLEDLightingComponent_AbilityHasTargetLock_Params params {};
		params.Pawn = Pawn;
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CAE0
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.AbilityHasLostTargetLock
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::AbilityHasLostTargetLock(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.AbilityHasLostTargetLock");
		
		UYLEDLightingComponent_AbilityHasLostTargetLock_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CA60
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.AbilityDeactivated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::AbilityDeactivated(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.AbilityDeactivated");
		
		UYLEDLightingComponent_AbilityDeactivated_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073C820
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.AbilityActivated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               succeeded                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYLEDLightingComponent::AbilityActivated(bool succeeded, int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.AbilityActivated");
		
		UYLEDLightingComponent_AbilityActivated_Params params {};
		params.succeeded = succeeded;
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073C680
	 * 		Name   -> Function DreadGame.YLEDLightingComponent.AbilitiesInitialized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYLEDLightingComponent::AbilitiesInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLEDLightingComponent.AbilitiesInitialized");
		
		UYLEDLightingComponent_AbilitiesInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYLEDLightingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYLEDLightingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLEDLightingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766800
	 * 		Name   -> Function DreadGame.YLevelBoundariesHeightVolume.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelBoundariesHeightVolume::OnOverlapEnd(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelBoundariesHeightVolume.OnOverlapEnd");
		
		AYLevelBoundariesHeightVolume_OnOverlapEnd_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766090
	 * 		Name   -> Function DreadGame.YLevelBoundariesHeightVolume.OnOverlap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelBoundariesHeightVolume::OnOverlap(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelBoundariesHeightVolume.OnOverlap");
		
		AYLevelBoundariesHeightVolume_OnOverlap_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYLevelBoundariesHeightVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYLevelBoundariesHeightVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLevelBoundariesHeightVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766880
	 * 		Name   -> Function DreadGame.YLevelBoundariesWarningVolume.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelBoundariesWarningVolume::OnOverlapEnd(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelBoundariesWarningVolume.OnOverlapEnd");
		
		AYLevelBoundariesWarningVolume_OnOverlapEnd_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766110
	 * 		Name   -> Function DreadGame.YLevelBoundariesWarningVolume.OnOverlap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelBoundariesWarningVolume::OnOverlap(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelBoundariesWarningVolume.OnOverlap");
		
		AYLevelBoundariesWarningVolume_OnOverlap_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYLevelBoundariesWarningVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYLevelBoundariesWarningVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLevelBoundariesWarningVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DE10
	 * 		Name   -> Function DreadGame.YWarpJumpTargetVolume.PostLoad
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYWarpJumpTargetVolume::PostLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpJumpTargetVolume.PostLoad");
		
		AYWarpJumpTargetVolume_PostLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768CE0
	 * 		Name   -> Function DreadGame.YWarpJumpTargetVolume.OnRep_Extent
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYWarpJumpTargetVolume::OnRep_Extent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpJumpTargetVolume.OnRep_Extent");
		
		AYWarpJumpTargetVolume_OnRep_Extent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766A40
	 * 		Name   -> Function DreadGame.YWarpJumpTargetVolume.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYWarpJumpTargetVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpJumpTargetVolume.OnOverlapEnd");
		
		AYWarpJumpTargetVolume_OnOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766480
	 * 		Name   -> Function DreadGame.YWarpJumpTargetVolume.OnOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               FromSweep                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AYWarpJumpTargetVolume::OnOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpJumpTargetVolume.OnOverlap");
		
		AYWarpJumpTargetVolume_OnOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.FromSweep = FromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYWarpJumpTargetVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYWarpJumpTargetVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWarpJumpTargetVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766190
	 * 		Name   -> Function DreadGame.YLevelBoundariesWarpVolume.OnOverlap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelBoundariesWarpVolume::OnOverlap(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelBoundariesWarpVolume.OnOverlap");
		
		AYLevelBoundariesWarpVolume_OnOverlap_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYLevelBoundariesWarpVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYLevelBoundariesWarpVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLevelBoundariesWarpVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C860
	 * 		Name   -> Function DreadGame.YLevelScriptActor.SetUpOupostMatineeActors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AMatineeActor*                               shipSelectedRight_pt1                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AMatineeActor*                               shipSelectedRight_pt2                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AMatineeActor*                               shipSelectedLeft_pt1                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AMatineeActor*                               shipSelectedLeft_pt2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::SetUpOupostMatineeActors(class AMatineeActor* shipSelectedRight_pt1, class AMatineeActor* shipSelectedRight_pt2, class AMatineeActor* shipSelectedLeft_pt1, class AMatineeActor* shipSelectedLeft_pt2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.SetUpOupostMatineeActors");
		
		AYLevelScriptActor_SetUpOupostMatineeActors_Params params {};
		params.shipSelectedRight_pt1 = shipSelectedRight_pt1;
		params.shipSelectedRight_pt2 = shipSelectedRight_pt2;
		params.shipSelectedLeft_pt1 = shipSelectedLeft_pt1;
		params.shipSelectedLeft_pt2 = shipSelectedLeft_pt2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C6A0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.SetUpOupostCharacterSpawners
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYCharacterSpawner*                          comCharSpawner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYCharacterSpawner*                          weaponsCharSpawner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYCharacterSpawner*                          navigationCharSpawner                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYCharacterSpawner*                          engineerCharSpawner                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYCharacterSpawner*                          captainCharSpawner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYCharacterSpawner*                          officerDetailCharSpawner                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::SetUpOupostCharacterSpawners(class AYCharacterSpawner* comCharSpawner, class AYCharacterSpawner* weaponsCharSpawner, class AYCharacterSpawner* navigationCharSpawner, class AYCharacterSpawner* engineerCharSpawner, class AYCharacterSpawner* captainCharSpawner, class AYCharacterSpawner* officerDetailCharSpawner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.SetUpOupostCharacterSpawners");
		
		AYLevelScriptActor_SetUpOupostCharacterSpawners_Params params {};
		params.comCharSpawner = comCharSpawner;
		params.weaponsCharSpawner = weaponsCharSpawner;
		params.navigationCharSpawner = navigationCharSpawner;
		params.engineerCharSpawner = engineerCharSpawner;
		params.captainCharSpawner = captainCharSpawner;
		params.officerDetailCharSpawner = officerDetailCharSpawner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C3A0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.SetUpOupostCameraActors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ACameraActor*                                Cam_Login_View                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Hangar_Main                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Hangar_Customization                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Quarters_General                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Quarters_Officers                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Quarters_Captain                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Quarters_Market_Captain                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_TechTree                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Market                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Market_Preview                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                Cam_Dashboard                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::SetUpOupostCameraActors(class ACameraActor* Cam_Login_View, class ACameraActor* Cam_Hangar_Main, class ACameraActor* Cam_Hangar_Customization, class ACameraActor* Cam_Quarters_General, class ACameraActor* Cam_Quarters_Officers, class ACameraActor* Cam_Quarters_Captain, class ACameraActor* Cam_Quarters_Market_Captain, class ACameraActor* Cam_TechTree, class ACameraActor* Cam_Market, class ACameraActor* Cam_Market_Preview, class ACameraActor* Cam_Dashboard)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.SetUpOupostCameraActors");
		
		AYLevelScriptActor_SetUpOupostCameraActors_Params params {};
		params.Cam_Login_View = Cam_Login_View;
		params.Cam_Hangar_Main = Cam_Hangar_Main;
		params.Cam_Hangar_Customization = Cam_Hangar_Customization;
		params.Cam_Quarters_General = Cam_Quarters_General;
		params.Cam_Quarters_Officers = Cam_Quarters_Officers;
		params.Cam_Quarters_Captain = Cam_Quarters_Captain;
		params.Cam_Quarters_Market_Captain = Cam_Quarters_Market_Captain;
		params.Cam_TechTree = Cam_TechTree;
		params.Cam_Market = Cam_Market;
		params.Cam_Market_Preview = Cam_Market_Preview;
		params.Cam_Dashboard = Cam_Dashboard;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C2E0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.SetUpLevelCameraActorForSection
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ACameraActor*                                CameraActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYOutpostSection                                   outpostSection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::SetUpLevelCameraActorForSection(class ACameraActor* CameraActor, EYOutpostSection outpostSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.SetUpLevelCameraActorForSection");
		
		AYLevelScriptActor_SetUpLevelCameraActorForSection_Params params {};
		params.CameraActor = CameraActor;
		params.outpostSection = outpostSection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C220
	 * 		Name   -> Function DreadGame.YLevelScriptActor.SetUpCharacterSpawnerForCharacterType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYCharacterSpawner*                          characterSpawner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYOutpostCharacterType                             outpostCharacterType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::SetUpCharacterSpawnerForCharacterType(class AYCharacterSpawner* characterSpawner, EYOutpostCharacterType outpostCharacterType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.SetUpCharacterSpawnerForCharacterType");
		
		AYLevelScriptActor_SetUpCharacterSpawnerForCharacterType_Params params {};
		params.characterSpawner = characterSpawner;
		params.outpostCharacterType = outpostCharacterType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A8A0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.SetRestartPointID
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            restartPointID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::SetRestartPointID(int32_t restartPointID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.SetRestartPointID");
		
		AYLevelScriptActor_SetRestartPointID_Params params {};
		params.restartPointID = restartPointID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777E00
	 * 		Name   -> Function DreadGame.YLevelScriptActor.SetGenericMissionMarker
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUIQuestMarker                                    markerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::SetGenericMissionMarker(class AActor* targetActor, EYUIQuestMarker markerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.SetGenericMissionMarker");
		
		AYLevelScriptActor_SetGenericMissionMarker_Params params {};
		params.targetActor = targetActor;
		params.markerType = markerType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnTurretSpawned
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYTurretActor*                               turret                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnTurretSpawned(class AYTurretActor* turret)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnTurretSpawned");
		
		AYLevelScriptActor_OnTurretSpawned_Params params {};
		params.turret = turret;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnTurretDied
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            turretId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnTurretDied(int32_t turretId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnTurretDied");
		
		AYLevelScriptActor_OnTurretDied_Params params {};
		params.turretId = turretId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnTeleportPlayerIntoLevel
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              randomJumpOutTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnTeleportPlayerIntoLevel(class AYPlayerController* Player, class AYPawn* Pawn, EYTeam Team, float randomJumpOutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnTeleportPlayerIntoLevel");
		
		AYLevelScriptActor_OnTeleportPlayerIntoLevel_Params params {};
		params.Player = Player;
		params.Pawn = Pawn;
		params.Team = Team;
		params.randomJumpOutTime = randomJumpOutTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStopPreviewingShip
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStopPreviewingShip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStopPreviewingShip");
		
		AYLevelScriptActor_OnStopPreviewingShip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartVisualAttractionLevelScript
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStartVisualAttractionLevelScript()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartVisualAttractionLevelScript");
		
		AYLevelScriptActor_OnStartVisualAttractionLevelScript_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartPreviewingShip
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStartPreviewingShip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartPreviewingShip");
		
		AYLevelScriptActor_OnStartPreviewingShip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartOrbitTransition
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStartOrbitTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartOrbitTransition");
		
		AYLevelScriptActor_OnStartOrbitTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartMapAutomationTest
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStartMapAutomationTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartMapAutomationTest");
		
		AYLevelScriptActor_OnStartMapAutomationTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartDebugCombat
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            teamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnStartDebugCombat(int32_t teamSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartDebugCombat");
		
		AYLevelScriptActor_OnStartDebugCombat_Params params {};
		params.teamSize = teamSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartCreeps
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStartCreeps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartCreeps");
		
		AYLevelScriptActor_OnStartCreeps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartCombatAutomationTest
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            tierLoadout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnStartCombatAutomationTest(int32_t tierLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartCombatAutomationTest");
		
		AYLevelScriptActor_OnStartCombatAutomationTest_Params params {};
		params.tierLoadout = tierLoadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartCombat
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStartCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartCombat");
		
		AYLevelScriptActor_OnStartCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnStartBenchmarkLevelScript
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnStartBenchmarkLevelScript()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnStartBenchmarkLevelScript");
		
		AYLevelScriptActor_OnStartBenchmarkLevelScript_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnSetUpSpawnPoints
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnSetUpSpawnPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnSetUpSpawnPoints");
		
		AYLevelScriptActor_OnSetUpSpawnPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnSetUpCapturePoints
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnSetUpCapturePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnSetUpCapturePoints");
		
		AYLevelScriptActor_OnSetUpCapturePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnRoundOver
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnRoundOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnRoundOver");
		
		AYLevelScriptActor_OnRoundOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnRequestedCRLIsVisible
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYCharacterRenderLevelType                         levelType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnRequestedCRLIsVisible(EYCharacterRenderLevelType levelType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnRequestedCRLIsVisible");
		
		AYLevelScriptActor_OnRequestedCRLIsVisible_Params params {};
		params.levelType = levelType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnReceivedTravel
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      Map                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      gameType                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnReceivedTravel(const class FString& Map, const class FString& gameType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnReceivedTravel");
		
		AYLevelScriptActor_OnReceivedTravel_Params params {};
		params.Map = Map;
		params.gameType = gameType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnPlayerSpawned
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnPlayerSpawned(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnPlayerSpawned");
		
		AYLevelScriptActor_OnPlayerSpawned_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnPlayerDied
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnPlayerDied(class AYPawn* victim, class AYPawn* Killer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnPlayerDied");
		
		AYLevelScriptActor_OnPlayerDied_Params params {};
		params.victim = victim;
		params.Killer = Killer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnPlayerDamaged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnPlayerDamaged(class AYPawn* victim, float Damage, class AYPawn* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnPlayerDamaged");
		
		AYLevelScriptActor_OnPlayerDamaged_Params params {};
		params.victim = victim;
		params.Damage = Damage;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnPawnBeginPlay
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnPawnBeginPlay(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnPawnBeginPlay");
		
		AYLevelScriptActor_OnPawnBeginPlay_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnOrbitTransitionEnded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnOrbitTransitionEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnOrbitTransitionEnded");
		
		AYLevelScriptActor_OnOrbitTransitionEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnOfficerSelected
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UYCharacterTemplate*                         characterTemplate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        officerName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnOfficerSelected(class UYCharacterTemplate* characterTemplate, const class FName& officerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnOfficerSelected");
		
		AYLevelScriptActor_OnOfficerSelected_Params params {};
		params.characterTemplate = characterTemplate;
		params.officerName = officerName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnOfficerRotated
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FRotator                                    deltaRot                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnOfficerRotated(const struct FRotator& deltaRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnOfficerRotated");
		
		AYLevelScriptActor_OnOfficerRotated_Params params {};
		params.deltaRot = deltaRot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnNPCSpawned
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            npcID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnNPCSpawned(int32_t npcID, class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnNPCSpawned");
		
		AYLevelScriptActor_OnNPCSpawned_Params params {};
		params.npcID = npcID;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnNPCDied
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            npcID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               jumpOut                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnNPCDied(int32_t npcID, bool jumpOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnNPCDied");
		
		AYLevelScriptActor_OnNPCDied_Params params {};
		params.npcID = npcID;
		params.jumpOut = jumpOut;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnNPCDamaged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            npcID                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnNPCDamaged(int32_t npcID, float Damage, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnNPCDamaged");
		
		AYLevelScriptActor_OnNPCDamaged_Params params {};
		params.npcID = npcID;
		params.Damage = Damage;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnNewCaptainAppearanceSelected
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UYCharacterTemplate*                         characterTemplate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        captainName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnNewCaptainAppearanceSelected(class UYCharacterTemplate* characterTemplate, const class FName& captainName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnNewCaptainAppearanceSelected");
		
		AYLevelScriptActor_OnNewCaptainAppearanceSelected_Params params {};
		params.characterTemplate = characterTemplate;
		params.captainName = captainName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnLightingSettingChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bUsingSimpleLighting                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnLightingSettingChanged(bool bUsingSimpleLighting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnLightingSettingChanged");
		
		AYLevelScriptActor_OnLightingSettingChanged_Params params {};
		params.bUsingSimpleLighting = bUsingSimpleLighting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnLevelLoaded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            restartPointID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnLevelLoaded(int32_t restartPointID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnLevelLoaded");
		
		AYLevelScriptActor_OnLevelLoaded_Params params {};
		params.restartPointID = restartPointID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnInitializeLevelScript
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnInitializeLevelScript()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnInitializeLevelScript");
		
		AYLevelScriptActor_OnInitializeLevelScript_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnInitializeBenchmark
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnInitializeBenchmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnInitializeBenchmark");
		
		AYLevelScriptActor_OnInitializeBenchmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnHudLoaded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnHudLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnHudLoaded");
		
		AYLevelScriptActor_OnHudLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnHordeWaveStarting
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnHordeWaveStarting(int32_t waveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnHordeWaveStarting");
		
		AYLevelScriptActor_OnHordeWaveStarting_Params params {};
		params.waveIndex = waveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnHordeWaveStarted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnHordeWaveStarted(int32_t waveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnHordeWaveStarted");
		
		AYLevelScriptActor_OnHordeWaveStarted_Params params {};
		params.waveIndex = waveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnHordeWaveEnded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnHordeWaveEnded(int32_t waveIndex, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnHordeWaveEnded");
		
		AYLevelScriptActor_OnHordeWaveEnded_Params params {};
		params.waveIndex = waveIndex;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnClientRestart
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPlayerController*                          PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnClientRestart(class AYPawn* Pawn, class AYPlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnClientRestart");
		
		AYLevelScriptActor_OnClientRestart_Params params {};
		params.Pawn = Pawn;
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnCaptainRotated
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FRotator                                    deltaRot                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnCaptainRotated(const struct FRotator& deltaRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnCaptainRotated");
		
		AYLevelScriptActor_OnCaptainRotated_Params params {};
		params.deltaRot = deltaRot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnCameraPanAnimation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnCameraPanAnimation(class AYPlayerController* Player, class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnCameraPanAnimation");
		
		AYLevelScriptActor_OnCameraPanAnimation_Params params {};
		params.Player = Player;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnBeginBattle
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 */
	void AYLevelScriptActor::OnBeginBattle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnBeginBattle");
		
		AYLevelScriptActor_OnBeginBattle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor.OnActorDestroyed
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      dActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::OnActorDestroyed(class AActor* dActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.OnActorDestroyed");
		
		AYLevelScriptActor_OnActorDestroyed_Params params {};
		params.dActor = dActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742630
	 * 		Name   -> Function DreadGame.YLevelScriptActor.BroadcastFName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor::BroadcastFName(const class FName& Name, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor.BroadcastFName");
		
		AYLevelScriptActor_BroadcastFName_Params params {};
		params.Name = Name;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYLevelScriptActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYLevelScriptActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLevelScriptActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YLevelScriptActor_CharRenderLevel.OnSwitchedToSceneCapture
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      Tag                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYLevelScriptActor_CharRenderLevel::OnSwitchedToSceneCapture(const class FString& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelScriptActor_CharRenderLevel.OnSwitchedToSceneCapture");
		
		AYLevelScriptActor_CharRenderLevel_OnSwitchedToSceneCapture_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYLevelScriptActor_CharRenderLevel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYLevelScriptActor_CharRenderLevel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLevelScriptActor_CharRenderLevel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782E00
	 * 		Name   -> Function DreadGame.YLevelStreamingUtils.UnloadStreamingLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYLevelStreamingUtils::STATIC_UnloadStreamingLevel(class UWorld* World, const class FString& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelStreamingUtils.UnloadStreamingLevel");
		
		UYLevelStreamingUtils_UnloadStreamingLevel_Params params {};
		params.World = World;
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760730
	 * 		Name   -> Function DreadGame.YLevelStreamingUtils.LoadStreamingLevel
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               shouldBeVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               blockOnLoad                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  levelTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               loadTransient                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UYLevelStreamingUtils::STATIC_LoadStreamingLevel(class UWorld* World, const class FString& LevelName, bool shouldBeVisible, bool blockOnLoad, const struct FTransform& levelTransform, bool loadTransient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelStreamingUtils.LoadStreamingLevel");
		
		UYLevelStreamingUtils_LoadStreamingLevel_Params params {};
		params.World = World;
		params.LevelName = LevelName;
		params.shouldBeVisible = shouldBeVisible;
		params.blockOnLoad = blockOnLoad;
		params.levelTransform = levelTransform;
		params.loadTransient = loadTransient;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYLevelStreamingUtils.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYLevelStreamingUtils::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLevelStreamingUtils");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757EE0
	 * 		Name   -> Function DreadGame.YLevelVariationManager.GetSelectedLevelVariationIndex
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	int32_t AYLevelVariationManager::GetSelectedLevelVariationIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLevelVariationManager.GetSelectedLevelVariationIndex");
		
		AYLevelVariationManager_GetSelectedLevelVariationIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYLevelVariationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYLevelVariationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLevelVariationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYLoadoutFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYLoadoutFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLoadoutFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076CAA0
	 * 		Name   -> Function DreadGame.YLocalizationUtilities.ParseArgumentsFromLocTextMacroString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      stringToParse                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> UYLocalizationUtilities::STATIC_ParseArgumentsFromLocTextMacroString(const class FString& stringToParse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLocalizationUtilities.ParseArgumentsFromLocTextMacroString");
		
		UYLocalizationUtilities_ParseArgumentsFromLocTextMacroString_Params params {};
		params.stringToParse = stringToParse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753BD0
	 * 		Name   -> Function DreadGame.YLocalizationUtilities.GetLocTextMacroStringFormat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      stringToParse                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EParseLocTextMacroStringResult UYLocalizationUtilities::STATIC_GetLocTextMacroStringFormat(const class FString& stringToParse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YLocalizationUtilities.GetLocTextMacroStringFormat");
		
		UYLocalizationUtilities_GetLocTextMacroStringFormat_Params params {};
		params.stringToParse = stringToParse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYLocalizationUtilities.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYLocalizationUtilities::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YLocalizationUtilities");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782CE0
	 * 		Name   -> Function DreadGame.YMapAutomationTestsFunctionLibrary.TryShutdownEngine
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYMapAutomationTestsFunctionLibrary::STATIC_TryShutdownEngine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMapAutomationTestsFunctionLibrary.TryShutdownEngine");
		
		UYMapAutomationTestsFunctionLibrary_TryShutdownEngine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007802C0
	 * 		Name   -> Function DreadGame.YMapAutomationTestsFunctionLibrary.StopPerformanceCaptureAndSendInformation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      performanceCaptureName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      timeSeriesSpecifier                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMapAutomationTestsFunctionLibrary::STATIC_StopPerformanceCaptureAndSendInformation(const class FString& performanceCaptureName, const class FString& timeSeriesSpecifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMapAutomationTestsFunctionLibrary.StopPerformanceCaptureAndSendInformation");
		
		UYMapAutomationTestsFunctionLibrary_StopPerformanceCaptureAndSendInformation_Params params {};
		params.performanceCaptureName = performanceCaptureName;
		params.timeSeriesSpecifier = timeSeriesSpecifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FE10
	 * 		Name   -> Function DreadGame.YMapAutomationTestsFunctionLibrary.StartPerformanceCapture
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYMapAutomationTestsFunctionLibrary::STATIC_StartPerformanceCapture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMapAutomationTestsFunctionLibrary.StartPerformanceCapture");
		
		UYMapAutomationTestsFunctionLibrary_StartPerformanceCapture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B780
	 * 		Name   -> Function DreadGame.YMapAutomationTestsFunctionLibrary.EnableStatTracking
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYMapAutomationTestsFunctionLibrary::STATIC_EnableStatTracking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMapAutomationTestsFunctionLibrary.EnableStatTracking");
		
		UYMapAutomationTestsFunctionLibrary_EnableStatTracking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AB50
	 * 		Name   -> Function DreadGame.YMapAutomationTestsFunctionLibrary.DisableStatTracking
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYMapAutomationTestsFunctionLibrary::STATIC_DisableStatTracking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMapAutomationTestsFunctionLibrary.DisableStatTracking");
		
		UYMapAutomationTestsFunctionLibrary_DisableStatTracking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E9ED60
	 * 		Name   -> Function DreadGame.YMapAutomationTestsFunctionLibrary.CaptureAndSendPerformanceInformationOneFrame
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      captureName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMapAutomationTestsFunctionLibrary::STATIC_CaptureAndSendPerformanceInformationOneFrame(const class FString& captureName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMapAutomationTestsFunctionLibrary.CaptureAndSendPerformanceInformationOneFrame");
		
		UYMapAutomationTestsFunctionLibrary_CaptureAndSendPerformanceInformationOneFrame_Params params {};
		params.captureName = captureName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A9C0
	 * 		Name   -> Function DreadGame.YMapAutomationTestsFunctionLibrary.CaptureAndSendMemoryInformation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UYMapAutomationTestsFunctionLibrary::STATIC_CaptureAndSendMemoryInformation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMapAutomationTestsFunctionLibrary.CaptureAndSendMemoryInformation");
		
		UYMapAutomationTestsFunctionLibrary_CaptureAndSendMemoryInformation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMapAutomationTestsFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMapAutomationTestsFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMapAutomationTestsFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMenuNavigationSlotBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMenuNavigationSlotBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenuNavigationSlotBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMenuNavigationSlotAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMenuNavigationSlotAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenuNavigationSlotAbility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMenuNavigationSlotAppearance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMenuNavigationSlotAppearance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenuNavigationSlotAppearance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMenuNavigationSlotOfficer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMenuNavigationSlotOfficer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenuNavigationSlotOfficer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMenuNavigationSlotWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMenuNavigationSlotWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenuNavigationSlotWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742090
	 * 		Name   -> Function DreadGame.YMenuWidget_DropdownList.BP_SetListVisible
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsVisible                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYMenuWidget_DropdownList::BP_SetListVisible(bool IsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenuWidget_DropdownList.BP_SetListVisible");
		
		UYMenuWidget_DropdownList_BP_SetListVisible_Params params {};
		params.IsVisible = IsVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenuWidget_DropdownList.BP_SetHighlightedListItem
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FYDropdownItemData                          listItem                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	void UYMenuWidget_DropdownList::BP_SetHighlightedListItem(const struct FYDropdownItemData& listItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenuWidget_DropdownList.BP_SetHighlightedListItem");
		
		UYMenuWidget_DropdownList_BP_SetHighlightedListItem_Params params {};
		params.listItem = listItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenuWidget_DropdownList.BP_SetActiveListItem
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FYDropdownItemData                          listItem                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	void UYMenuWidget_DropdownList::BP_SetActiveListItem(const struct FYDropdownItemData& listItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenuWidget_DropdownList.BP_SetActiveListItem");
		
		UYMenuWidget_DropdownList_BP_SetActiveListItem_Params params {};
		params.listItem = listItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YMenuWidget_DropdownList.BP_PopulateList
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<struct FYDropdownItemData>                  itemDataList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYMenuWidget_DropdownList::BP_PopulateList(TArray<struct FYDropdownItemData> itemDataList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMenuWidget_DropdownList.BP_PopulateList");
		
		UYMenuWidget_DropdownList_BP_PopulateList_Params params {};
		params.itemDataList = itemDataList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMenuWidget_DropdownList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMenuWidget_DropdownList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenuWidget_DropdownList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMergedNativeAnimationUpdate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMergedNativeAnimationUpdate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMergedNativeAnimationUpdate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMeshAutomationTestLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMeshAutomationTestLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMeshAutomationTestLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766900
	 * 		Name   -> Function DreadGame.YMinimapVisibilityVolume.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYMinimapVisibilityVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMinimapVisibilityVolume.OnOverlapEnd");
		
		AYMinimapVisibilityVolume_OnOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00766210
	 * 		Name   -> Function DreadGame.YMinimapVisibilityVolume.OnOverlap
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               FromSweep                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AYMinimapVisibilityVolume::OnOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMinimapVisibilityVolume.OnOverlap");
		
		AYMinimapVisibilityVolume_OnOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.FromSweep = FromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYMinimapVisibilityVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYMinimapVisibilityVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMinimapVisibilityVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYMinimapVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYMinimapVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMinimapVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMovieManagerSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMovieManagerSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMovieManagerSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMovieManager.OnMovieSuspended
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYMovieManager::OnMovieSuspended()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.OnMovieSuspended");
		
		UYMovieManager_OnMovieSuspended_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YMovieManager.OnMovieResumed
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYMovieManager::OnMovieResumed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.OnMovieResumed");
		
		UYMovieManager_OnMovieResumed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007654E0
	 * 		Name   -> Function DreadGame.YMovieManager.OnMovieOpenFailed
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FString                                      FailedUrl                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMovieManager::OnMovieOpenFailed(const class FString& FailedUrl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.OnMovieOpenFailed");
		
		UYMovieManager_OnMovieOpenFailed_Params params {};
		params.FailedUrl = FailedUrl;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007655D0
	 * 		Name   -> Function DreadGame.YMovieManager.OnMovieOpened
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FString                                      OpenedUrl                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMovieManager::OnMovieOpened(const class FString& OpenedUrl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.OnMovieOpened");
		
		UYMovieManager_OnMovieOpened_Params params {};
		params.OpenedUrl = OpenedUrl;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007654C0
	 * 		Name   -> Function DreadGame.YMovieManager.OnMovieEndReached
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYMovieManager::OnMovieEndReached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.OnMovieEndReached");
		
		UYMovieManager_OnMovieEndReached_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007654A0
	 * 		Name   -> Function DreadGame.YMovieManager.OnMovieClosed
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYMovieManager::OnMovieClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.OnMovieClosed");
		
		UYMovieManager_OnMovieClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749300
	 * 		Name   -> Function DreadGame.YMovieManager.CreateUIWidget
	 * 		Flags  -> (Final, Native, Protected)
	 */
	bool UYMovieManager::CreateUIWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.CreateUIWidget");
		
		UYMovieManager_CreateUIWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749080
	 * 		Name   -> Function DreadGame.YMovieManager.CreateAmbientSoundActor
	 * 		Flags  -> (Final, Native, Protected)
	 */
	bool UYMovieManager::CreateAmbientSoundActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMovieManager.CreateAmbientSoundActor");
		
		UYMovieManager_CreateAmbientSoundActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMovieManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMovieManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMovieManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest_AbilitiesUsed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest_AbilitiesUsed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest_AbilitiesUsed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest_DamageDealt.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest_DamageDealt::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest_DamageDealt");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest_EndOfMatchScore.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest_EndOfMatchScore::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest_EndOfMatchScore");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest_GamePlayed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest_GamePlayed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest_GamePlayed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest_PlayerKills.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest_PlayerKills::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest_PlayerKills");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest_Repair.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest_Repair::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest_Repair");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuest_Ribbons.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuest_Ribbons::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuest_Ribbons");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuestData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuestData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuestData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768A00
	 * 		Name   -> Function DreadGame.YMPQuestsCollection.OnQuestsLoaded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYMPQuestsCollection::OnQuestsLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMPQuestsCollection.OnQuestsLoaded");
		
		UYMPQuestsCollection_OnQuestsLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YMPQuestsCollection.OnQuestsLoadCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYMPQuestsCollection::OnQuestsLoadCompleted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YMPQuestsCollection.OnQuestsLoadCompleted__DelegateSignature");
		
		UYMPQuestsCollection_OnQuestsLoadCompleted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMPQuestsCollection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMPQuestsCollection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMPQuestsCollection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMusicCue_Background.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMusicCue_Background::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMusicCue_Background");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DD90
	 * 		Name   -> Function DreadGame.YMusicManager.PostCustomMusicEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               AkEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMusicManager::PostCustomMusicEvent(class UAkAudioEvent* AkEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMusicManager.PostCustomMusicEvent");
		
		UYMusicManager_PostCustomMusicEvent_Params params {};
		params.AkEvent = AkEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DCD0
	 * 		Name   -> Function DreadGame.YMusicManager.PlayerThreatUpdated
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              threat                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMusicManager::PlayerThreatUpdated(float threat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMusicManager.PlayerThreatUpdated");
		
		UYMusicManager_PlayerThreatUpdated_Params params {};
		params.threat = threat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E50000
	 * 		Name   -> Function DreadGame.YMusicManager.PlayerScored
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UYMusicManager::PlayerScored()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMusicManager.PlayerScored");
		
		UYMusicManager_PlayerScored_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E702B0
	 * 		Name   -> Function DreadGame.YMusicManager.PlayerHealthChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              healthPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYMusicManager::PlayerHealthChanged(float healthPercent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YMusicManager.PlayerHealthChanged");
		
		UYMusicManager_PlayerHealthChanged_Params params {};
		params.healthPercent = healthPercent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMusicManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMusicManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMusicManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FFD0
	 * 		Name   -> Function DreadGame.YPerk.RetrieveFeatName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName UYPerk::RetrieveFeatName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPerk.RetrieveFeatName");
		
		UYPerk_RetrieveFeatName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FED0
	 * 		Name   -> Function DreadGame.YPerk.RetrieveDescription
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString UYPerk::RetrieveDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPerk.RetrieveDescription");
		
		UYPerk_RetrieveDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPerk.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPerk::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPerk");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYNPCPawnData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYNPCPawnData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YNPCPawnData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077DD70
	 * 		Name   -> Function DreadGame.YObjectiveComponent.ShowObjectiveMarker
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Show                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYObjectiveComponent::ShowObjectiveMarker(bool Show)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YObjectiveComponent.ShowObjectiveMarker");
		
		UYObjectiveComponent_ShowObjectiveMarker_Params params {};
		params.Show = Show;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779300
	 * 		Name   -> Function DreadGame.YObjectiveComponent.SetObjectiveID
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        objectiveID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               updateToState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYObjectiveComponent::SetObjectiveID(const class FName& objectiveID, bool updateToState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YObjectiveComponent.SetObjectiveID");
		
		UYObjectiveComponent_SetObjectiveID_Params params {};
		params.objectiveID = objectiveID;
		params.updateToState = updateToState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778BE0
	 * 		Name   -> Function DreadGame.YObjectiveComponent.SetMarkerText
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYObjectiveComponent::SetMarkerText(const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YObjectiveComponent.SetMarkerText");
		
		UYObjectiveComponent_SetMarkerText_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D580
	 * 		Name   -> Function DreadGame.YObjectiveComponent.InitializeGameState
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYObjectiveComponent::InitializeGameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YObjectiveComponent.InitializeGameState");
		
		UYObjectiveComponent_InitializeGameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYObjectiveComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYObjectiveComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YObjectiveComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOfficerFixed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOfficerFixed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOfficerFixed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FE50
	 * 		Name   -> Function DreadGame.YOfficerManager.RetrieveAvailableOfficers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class UYOfficer*> UYOfficerManager::RetrieveAvailableOfficers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficerManager.RetrieveAvailableOfficers");
		
		UYOfficerManager_RetrieveAvailableOfficers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YOfficerManager.OnOfficerUpdateFailed__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYOfficerManager::OnOfficerUpdateFailed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YOfficerManager.OnOfficerUpdateFailed__DelegateSignature");
		
		UYOfficerManager_OnOfficerUpdateFailed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YOfficerManager.OnOfficerUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOfficerManager::OnOfficerUpdated__DelegateSignature(int32_t Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YOfficerManager.OnOfficerUpdated__DelegateSignature");
		
		UYOfficerManager_OnOfficerUpdated__DelegateSignature_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YOfficerManager.OnInitializationCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYOfficerManager::OnInitializationCompleted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YOfficerManager.OnInitializationCompleted__DelegateSignature");
		
		UYOfficerManager_OnInitializationCompleted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D4B0
	 * 		Name   -> Function DreadGame.YOfficerManager.InitializeFromPlayerData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYOfficerManager::InitializeFromPlayerData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficerManager.InitializeFromPlayerData");
		
		UYOfficerManager_InitializeFromPlayerData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757880
	 * 		Name   -> Function DreadGame.YOfficerManager.GetRankForRP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            rp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYOfficerManager::GetRankForRP(int32_t rp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOfficerManager.GetRankForRP");
		
		UYOfficerManager_GetRankForRP_Params params {};
		params.rp = rp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOfficerManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOfficerManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOfficerManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOfficerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOfficerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOfficerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOnboardingHighlightCalloutButtonNames.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOnboardingHighlightCalloutButtonNames::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOnboardingHighlightCalloutButtonNames");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOnboardingSavedData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOnboardingSavedData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOnboardingSavedData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FEB0
	 * 		Name   -> Function DreadGame.YOnboardingManager.StartTutorial
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UYOnboardingManager::StartTutorial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.StartTutorial");
		
		UYOnboardingManager_StartTutorial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FE70
	 * 		Name   -> Function DreadGame.YOnboardingManager.StartTrainingMatch
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UYOnboardingManager::StartTrainingMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.StartTrainingMatch");
		
		UYOnboardingManager_StartTrainingMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776A80
	 * 		Name   -> Function DreadGame.YOnboardingManager.SetDashboardEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::SetDashboardEnabled(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.SetDashboardEnabled");
		
		UYOnboardingManager_SetDashboardEnabled_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E50000
	 * 		Name   -> Function DreadGame.YOnboardingManager.SaveStates
	 * 		Flags  -> (Native, Public)
	 */
	void UYOnboardingManager::SaveStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.SaveStates");
		
		UYOnboardingManager_SaveStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E83BF0
	 * 		Name   -> Function DreadGame.YOnboardingManager.ResetStates
	 * 		Flags  -> (Native, Public)
	 */
	void UYOnboardingManager::ResetStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.ResetStates");
		
		UYOnboardingManager_ResetStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F8A0
	 * 		Name   -> Function DreadGame.YOnboardingManager.RequestMenuState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYMenuState                                        onboardingMenuState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuSubState                                     onboardingSubMenuState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::RequestMenuState(EYMenuState onboardingMenuState, EYMenuSubState onboardingSubMenuState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.RequestMenuState");
		
		UYOnboardingManager_RequestMenuState_Params params {};
		params.onboardingMenuState = onboardingMenuState;
		params.onboardingSubMenuState = onboardingSubMenuState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YOnboardingManager.PromptTutorial_PS4
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      m_UMGPopupClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::PromptTutorial_PS4(class UClass* m_UMGPopupClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.PromptTutorial_PS4");
		
		UYOnboardingManager_PromptTutorial_PS4_Params params {};
		params.m_UMGPopupClass = m_UMGPopupClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YOnboardingManager.PromptTraining_PS4
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      m_UMGPopupClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::PromptTraining_PS4(class UClass* m_UMGPopupClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.PromptTraining_PS4");
		
		UYOnboardingManager_PromptTraining_PS4_Params params {};
		params.m_UMGPopupClass = m_UMGPopupClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DF50
	 * 		Name   -> Function DreadGame.YOnboardingManager.ProcessNotificationQueue
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYOnboardingManager::ProcessNotificationQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.ProcessNotificationQueue");
		
		UYOnboardingManager_ProcessNotificationQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760CA0
	 * 		Name   -> Function DreadGame.YOnboardingManager.ManuallyTriggerRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::ManuallyTriggerRule(const class FName& ruleName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.ManuallyTriggerRule");
		
		UYOnboardingManager_ManuallyTriggerRule_Params params {};
		params.ruleName = ruleName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760C20
	 * 		Name   -> Function DreadGame.YOnboardingManager.ManuallyResetRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::ManuallyResetRule(const class FName& ruleName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.ManuallyResetRule");
		
		UYOnboardingManager_ManuallyResetRule_Params params {};
		params.ruleName = ruleName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760BA0
	 * 		Name   -> Function DreadGame.YOnboardingManager.ManuallyCompleteRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::ManuallyCompleteRule(const class FName& ruleName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.ManuallyCompleteRule");
		
		UYOnboardingManager_ManuallyCompleteRule_Params params {};
		params.ruleName = ruleName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01EA0F10
	 * 		Name   -> Function DreadGame.YOnboardingManager.LoadStates
	 * 		Flags  -> (Native, Public)
	 */
	bool UYOnboardingManager::LoadStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.LoadStates");
		
		UYOnboardingManager_LoadStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007605D0
	 * 		Name   -> Function DreadGame.YOnboardingManager.LoadData
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYOnboardingManager::LoadData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.LoadData");
		
		UYOnboardingManager_LoadData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F900
	 * 		Name   -> Function DreadGame.YOnboardingManager.IsRuleInProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYOnboardingManager::IsRuleInProgress(const class FName& ruleName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.IsRuleInProgress");
		
		UYOnboardingManager_IsRuleInProgress_Params params {};
		params.ruleName = ruleName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F870
	 * 		Name   -> Function DreadGame.YOnboardingManager.IsRuleCompleted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYOnboardingManager::IsRuleCompleted(const class FName& ruleName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.IsRuleCompleted");
		
		UYOnboardingManager_IsRuleCompleted_Params params {};
		params.ruleName = ruleName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DA90
	 * 		Name   -> Function DreadGame.YOnboardingManager.Initialized
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYOnboardingManager::Initialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.Initialized");
		
		UYOnboardingManager_Initialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BD70
	 * 		Name   -> Function DreadGame.YOnboardingManager.HandleOnPlayerControllerSet
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPlayerControllerBase*                      PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::HandleOnPlayerControllerSet(class AYPlayerControllerBase* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.HandleOnPlayerControllerSet");
		
		UYOnboardingManager_HandleOnPlayerControllerSet_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744860
	 * 		Name   -> Function DreadGame.YOnboardingManager.ClearAllRules
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYOnboardingManager::ClearAllRules()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.ClearAllRules");
		
		UYOnboardingManager_ClearAllRules_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007409A0
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddTutorialDoneRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddTutorialDoneRule(const class FName& ruleName, bool completeManually)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddTutorialDoneRule");
		
		UYOnboardingManager_AddTutorialDoneRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740660
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FYOnboardingEventRule                       Rule                                                       (Parm, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddRule(const struct FYOnboardingEventRule& Rule)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddRule");
		
		UYOnboardingManager_AddRule_Params params {};
		params.Rule = Rule;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007404A0
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddRankReachedRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            reachedRank                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddRankReachedRule(const class FName& ruleName, bool completeManually, int32_t reachedRank)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddRankReachedRule");
		
		UYOnboardingManager_AddRankReachedRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.reachedRank = reachedRank;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F9E0
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddMetaMenuReachedRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYMenuMetaState                                    metaMenuState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddMetaMenuReachedRule(const class FName& ruleName, bool completeManually, EYMenuMetaState metaMenuState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddMetaMenuReachedRule");
		
		UYOnboardingManager_AddMetaMenuReachedRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.metaMenuState = metaMenuState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F850
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddMenuReachedWithShipClassRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYMenuState                                        reachedMenu                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuSubState                                     reachedSubMenu                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYShipClass                                        shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddMenuReachedWithShipClassRule(const class FName& ruleName, bool completeManually, EYMenuState reachedMenu, EYMenuSubState reachedSubMenu, EYShipClass shipclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddMenuReachedWithShipClassRule");
		
		UYOnboardingManager_AddMenuReachedWithShipClassRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.reachedMenu = reachedMenu;
		params.reachedSubMenu = reachedSubMenu;
		params.shipclass = shipclass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F700
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddMenuReachedRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYMenuState                                        reachedMenu                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYMenuSubState                                     reachedSubMenu                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddMenuReachedRule(const class FName& ruleName, bool completeManually, EYMenuState reachedMenu, EYMenuSubState reachedSubMenu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddMenuReachedRule");
		
		UYOnboardingManager_AddMenuReachedRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.reachedMenu = reachedMenu;
		params.reachedSubMenu = reachedSubMenu;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F4A0
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddItemUnlockedRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      classUnlocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddItemUnlockedRule(const class FName& ruleName, bool completeManually, class UClass* classUnlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddItemUnlockedRule");
		
		UYOnboardingManager_AddItemUnlockedRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.classUnlocked = classUnlocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F3A0
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddItemEquipedRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      itemEquiped                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddItemEquipedRule(const class FName& ruleName, bool completeManually, class UClass* itemEquiped)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddItemEquipedRule");
		
		UYOnboardingManager_AddItemEquipedRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.itemEquiped = itemEquiped;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F200
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddItemBoughtRuleWithPrerequisite
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      itemBought                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        prerequisiteRuleName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYShopPurchaseSource                               itemPurchaseSource                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddItemBoughtRuleWithPrerequisite(const class FName& ruleName, bool completeManually, class UClass* itemBought, const class FName& prerequisiteRuleName, EYShopPurchaseSource itemPurchaseSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddItemBoughtRuleWithPrerequisite");
		
		UYOnboardingManager_AddItemBoughtRuleWithPrerequisite_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.itemBought = itemBought;
		params.prerequisiteRuleName = prerequisiteRuleName;
		params.itemPurchaseSource = itemPurchaseSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073F0B0
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddItemBoughtRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      itemBought                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYShopPurchaseSource                               itemPurchaseSource                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddItemBoughtRule(const class FName& ruleName, bool completeManually, class UClass* itemBought, EYShopPurchaseSource itemPurchaseSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddItemBoughtRule");
		
		UYOnboardingManager_AddItemBoughtRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.itemBought = itemBought;
		params.itemPurchaseSource = itemPurchaseSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073EF40
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddFirstLoginRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddFirstLoginRule(const class FName& ruleName, bool completeManually)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddFirstLoginRule");
		
		UYOnboardingManager_AddFirstLoginRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E980
	 * 		Name   -> Function DreadGame.YOnboardingManager.AddCustomizationMenuReachedRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ruleName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               completeManually                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYUILoadoutItemType                                itemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOnboardingManager::AddCustomizationMenuReachedRule(const class FName& ruleName, bool completeManually, EYUILoadoutItemType itemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOnboardingManager.AddCustomizationMenuReachedRule");
		
		UYOnboardingManager_AddCustomizationMenuReachedRule_Params params {};
		params.ruleName = ruleName;
		params.completeManually = completeManually;
		params.itemType = itemType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOnboardingManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOnboardingManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOnboardingManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C940
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OrbitLoaded
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void AYOrbitTransitionManager::OrbitLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OrbitLoaded");
		
		AYOrbitTransitionManager_OrbitLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OnStartProfileEndOfMatchScreen
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYOrbitTransitionManager::OnStartProfileEndOfMatchScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OnStartProfileEndOfMatchScreen");
		
		AYOrbitTransitionManager_OnStartProfileEndOfMatchScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OnPlayCameraPanAnimation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UYPlayerOrbitComponent*                      playerOrbitComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOrbitTransitionManager::OnPlayCameraPanAnimation(class UYPlayerOrbitComponent* playerOrbitComponent, class AYPlayerController* Player, class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OnPlayCameraPanAnimation");
		
		AYOrbitTransitionManager_OnPlayCameraPanAnimation_Params params {};
		params.playerOrbitComponent = playerOrbitComponent;
		params.Player = Player;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OnOrbitTransitionStarts
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOrbitTransitionManager::OnOrbitTransitionStarts(class AYPlayerController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OnOrbitTransitionStarts");
		
		AYOrbitTransitionManager_OnOrbitTransitionStarts_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OnOrbitTransitionEnds
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYPlayerOrbitComponent*                      orbitComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOrbitTransitionManager::OnOrbitTransitionEnds(class AYPlayerController* Player, class UYPlayerOrbitComponent* orbitComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OnOrbitTransitionEnds");
		
		AYOrbitTransitionManager_OnOrbitTransitionEnds_Params params {};
		params.Player = Player;
		params.orbitComponent = orbitComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OnOrbitLevelSetUp
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYGameState_MP*                              multiplayerGameState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            levelVariationIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOrbitTransitionManager::OnOrbitLevelSetUp(class AYGameState_MP* multiplayerGameState, int32_t levelVariationIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OnOrbitLevelSetUp");
		
		AYOrbitTransitionManager_OnOrbitLevelSetUp_Params params {};
		params.multiplayerGameState = multiplayerGameState;
		params.levelVariationIndex = levelVariationIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OnEndOfMatchOrbitSetUp
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOrbitTransitionManager::OnEndOfMatchOrbitSetUp(class AYPlayerController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OnEndOfMatchOrbitSetUp");
		
		AYOrbitTransitionManager_OnEndOfMatchOrbitSetUp_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.OnCameraFadeComplete
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOrbitTransitionManager::OnCameraFadeComplete(class AYPlayerController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.OnCameraFadeComplete");
		
		AYOrbitTransitionManager_OnCameraFadeComplete_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758CC0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.GetSkeletalMeshForCameraPan
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class ASkeletalMeshActor* AYOrbitTransitionManager::GetSkeletalMeshForCameraPan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.GetSkeletalMeshForCameraPan");
		
		AYOrbitTransitionManager_GetSkeletalMeshForCameraPan_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007542A0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.GetMinTimeRequiredForPlayingOrbitTransition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYOrbitTransitionManager::GetMinTimeRequiredForPlayingOrbitTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.GetMinTimeRequiredForPlayingOrbitTransition");
		
		AYOrbitTransitionManager_GetMinTimeRequiredForPlayingOrbitTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753930
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.GetLevelTargetPointTeam2
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class ATargetPoint*> AYOrbitTransitionManager::GetLevelTargetPointTeam2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.GetLevelTargetPointTeam2");
		
		AYOrbitTransitionManager_GetLevelTargetPointTeam2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007538B0
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.GetLevelTargetPointTeam1
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class ATargetPoint*> AYOrbitTransitionManager::GetLevelTargetPointTeam1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.GetLevelTargetPointTeam1");
		
		AYOrbitTransitionManager_GetLevelTargetPointTeam1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753790
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.GetLevelStreamingDataRow
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYLevelStreamingDataTableRow                rowOut                                                     (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool AYOrbitTransitionManager::GetLevelStreamingDataRow(const class FName& Name, struct FYLevelStreamingDataTableRow* rowOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.GetLevelStreamingDataRow");
		
		AYOrbitTransitionManager_GetLevelStreamingDataRow_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (rowOut != nullptr)
			*rowOut = params.rowOut;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E070
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.GetCameraActorForCameraPan
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class ACameraActor* AYOrbitTransitionManager::GetCameraActorForCameraPan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.GetCameraActorForCameraPan");
		
		AYOrbitTransitionManager_GetCameraActorForCameraPan_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B870
	 * 		Name   -> Function DreadGame.YOrbitTransitionManager.EndOfMatchOrbitLoaded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPlayerController*                          Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOrbitTransitionManager::EndOfMatchOrbitLoaded(class AYPlayerController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOrbitTransitionManager.EndOfMatchOrbitLoaded");
		
		AYOrbitTransitionManager_EndOfMatchOrbitLoaded_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYOrbitTransitionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYOrbitTransitionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOrbitTransitionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E7A0
	 * 		Name   -> Function DreadGame.YOutpostCamera.RegisterForHudNotifications
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYOutpostCamera::RegisterForHudNotifications()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCamera.RegisterForHudNotifications");
		
		AYOutpostCamera_RegisterForHudNotifications_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C9A0
	 * 		Name   -> Function DreadGame.YOutpostCamera.OutpostSectionChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYOutpostSection                                   prevSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYOutpostSection                                   newSection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYOutpostCamera::OutpostSectionChanged(EYOutpostSection prevSection, EYOutpostSection newSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCamera.OutpostSectionChanged");
		
		AYOutpostCamera_OutpostSectionChanged_Params params {};
		params.prevSection = prevSection;
		params.newSection = newSection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYOutpostCamera.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYOutpostCamera::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOutpostCamera");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784F40
	 * 		Name   -> Function DreadGame.YPlayerController.ZoomOut
	 * 		Flags  -> (Native, Public)
	 */
	void AYPlayerController::ZoomOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ZoomOut");
		
		AYPlayerController_ZoomOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784F20
	 * 		Name   -> Function DreadGame.YPlayerController.ZoomIn
	 * 		Flags  -> (Native, Public)
	 */
	void AYPlayerController::ZoomIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ZoomIn");
		
		AYPlayerController_ZoomIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.YSoloAudio
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::YSoloAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.YSoloAudio");
		
		AYPlayerController_YSoloAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784E50
	 * 		Name   -> Function DreadGame.YPlayerController.YSetCinematicMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInCinematicMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bAffectsHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::YSetCinematicMode(bool bInCinematicMode, bool bAffectsHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.YSetCinematicMode");
		
		AYPlayerController_YSetCinematicMode_Params params {};
		params.bInCinematicMode = bInCinematicMode;
		params.bAffectsHUD = bAffectsHUD;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerController.YPlayerControllerDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPlayerController*                          source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::YPlayerControllerDelegate__DelegateSignature(class AYPlayerController* source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerController.YPlayerControllerDelegate__DelegateSignature");
		
		AYPlayerController_YPlayerControllerDelegate__DelegateSignature_Params params {};
		params.source = source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YPlayerController.YouHaveTheCon
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        clientBotName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::YouHaveTheCon(const class FName& clientBotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.YouHaveTheCon");
		
		AYPlayerController_YouHaveTheCon_Params params {};
		params.clientBotName = clientBotName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.YClearSoloAudio
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::YClearSoloAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.YClearSoloAudio");
		
		AYPlayerController_YClearSoloAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.WeaponDebugMode
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::WeaponDebugMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.WeaponDebugMode");
		
		AYPlayerController_WeaponDebugMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007825C0
	 * 		Name   -> Function DreadGame.YPlayerController.TriggerMatchStartVO
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerController::TriggerMatchStartVO()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.TriggerMatchStartVO");
		
		AYPlayerController_TriggerMatchStartVO_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781760
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleVerticalVisualDebug
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleVerticalVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleVerticalVisualDebug");
		
		AYPlayerController_ToggleVerticalVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781740
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleThrottleVisualDebug
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleThrottleVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleThrottleVisualDebug");
		
		AYPlayerController_ToggleThrottleVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007815D0
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleSteeringVisualDebug
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleSteeringVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleSteeringVisualDebug");
		
		AYPlayerController_ToggleSteeringVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007815B0
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleSpringVisualDebug
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleSpringVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleSpringVisualDebug");
		
		AYPlayerController_ToggleSpringVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781570
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleShowTargetVolumes
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleShowTargetVolumes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleShowTargetVolumes");
		
		AYPlayerController_ToggleShowTargetVolumes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781520
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleProjectileVisualDebug
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleProjectileVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleProjectileVisualDebug");
		
		AYPlayerController_ToggleProjectileVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007812E0
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleDragVisualDebug
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleDragVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleDragVisualDebug");
		
		AYPlayerController_ToggleDragVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleDebugAbilityPerimiterDefense
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleDebugAbilityPerimiterDefense()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleDebugAbilityPerimiterDefense");
		
		AYPlayerController_ToggleDebugAbilityPerimiterDefense_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781080
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleCharacterSelectionHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsActive                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               closeRespawnInfoPanel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ToggleCharacterSelectionHUD(bool IsActive, bool closeRespawnInfoPanel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleCharacterSelectionHUD");
		
		AYPlayerController_ToggleCharacterSelectionHUD_Params params {};
		params.IsActive = IsActive;
		params.closeRespawnInfoPanel = closeRespawnInfoPanel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.ToggleAbilityCooldowns
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ToggleAbilityCooldowns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ToggleAbilityCooldowns");
		
		AYPlayerController_ToggleAbilityCooldowns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780EA0
	 * 		Name   -> Function DreadGame.YPlayerController.TicketCountPercentageChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              team1TicketCountPercentage                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              team2TicketCountPercentage                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              team1TicketActualScore                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              team2TicketActualScore                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::TicketCountPercentageChanged(float team1TicketCountPercentage, float team2TicketCountPercentage, float team1TicketActualScore, float team2TicketActualScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.TicketCountPercentageChanged");
		
		AYPlayerController_TicketCountPercentageChanged_Params params {};
		params.team1TicketCountPercentage = team1TicketCountPercentage;
		params.team2TicketCountPercentage = team2TicketCountPercentage;
		params.team1TicketActualScore = team1TicketActualScore;
		params.team2TicketActualScore = team2TicketActualScore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780E80
	 * 		Name   -> Function DreadGame.YPlayerController.TestSingleCaptainView
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::TestSingleCaptainView()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.TestSingleCaptainView");
		
		AYPlayerController_TestSingleCaptainView_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.StopServerProfiling
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::StopServerProfiling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.StopServerProfiling");
		
		AYPlayerController_StopServerProfiling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.StopClientProfiling
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::StopClientProfiling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.StopClientProfiling");
		
		AYPlayerController_StopClientProfiling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FCD0
	 * 		Name   -> Function DreadGame.YPlayerController.StartMatch
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::StartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.StartMatch");
		
		AYPlayerController_StartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FBD0
	 * 		Name   -> Function DreadGame.YPlayerController.StartLocalSrvMapInternal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      mapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      gameModeAlias                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AYPlayerController::StartLocalSrvMapInternal(const class FString& mapName, const class FString& gameModeAlias)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.StartLocalSrvMapInternal");
		
		AYPlayerController_StartLocalSrvMapInternal_Params params {};
		params.mapName = mapName;
		params.gameModeAlias = gameModeAlias;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F650
	 * 		Name   -> Function DreadGame.YPlayerController.SpreadChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              spread                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SpreadChanged(float spread)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SpreadChanged");
		
		AYPlayerController_SpreadChanged_Params params {};
		params.spread = spread;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077E940
	 * 		Name   -> Function DreadGame.YPlayerController.SoftCollisionDebugMode
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SoftCollisionDebugMode(int32_t mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SoftCollisionDebugMode");
		
		AYPlayerController_SoftCollisionDebugMode_Params params {};
		params.mode = mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YPlayerController.ShowMissileMarkers
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ShowMissileMarkers(int32_t option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ShowMissileMarkers");
		
		AYPlayerController_ShowMissileMarkers_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D100
	 * 		Name   -> Function DreadGame.YPlayerController.ShieldDamageReceived
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::ShieldDamageReceived()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ShieldDamageReceived");
		
		AYPlayerController_ShieldDamageReceived_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D0E0
	 * 		Name   -> Function DreadGame.YPlayerController.ShieldAttached
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::ShieldAttached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ShieldAttached");
		
		AYPlayerController_ShieldAttached_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CB40
	 * 		Name   -> Function DreadGame.YPlayerController.SetViewTargetToSavedViewTargetWithBlend
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EViewTargetBlendFunction                           BlendFunc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockOutgoing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetViewTargetToSavedViewTargetWithBlend(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetViewTargetToSavedViewTargetWithBlend");
		
		AYPlayerController_SetViewTargetToSavedViewTargetWithBlend_Params params {};
		params.BlendTime = BlendTime;
		params.BlendFunc = BlendFunc;
		params.BlendExp = BlendExp;
		params.bLockOutgoing = bLockOutgoing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CAC0
	 * 		Name   -> Function DreadGame.YPlayerController.SetViewTargetToPerformanceCameraAtIndex
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetViewTargetToPerformanceCameraAtIndex(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetViewTargetToPerformanceCameraAtIndex");
		
		AYPlayerController_SetViewTargetToPerformanceCameraAtIndex_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B9A0
	 * 		Name   -> Function DreadGame.YPlayerController.SetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetTeam(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetTeam");
		
		AYPlayerController_SetTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779930
	 * 		Name   -> Function DreadGame.YPlayerController.SetPlayerRestrictions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bRestrictMovements                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYCameraRestrictionType                            restrictCamera                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictAbilities                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictWeapons                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictSwitchWeapons                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictEnergyWheel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictOfficerNotifications                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictChat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictScoringSystem                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSpectate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYHudState                                         hudState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility1                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility2                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility3                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility4                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictShortCommands                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               blockMovementForward                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               blockMovementBackward                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               blockMovementLeft                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               blockMovementRight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               blockMovementUp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               blockMovementDown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetPlayerRestrictions(bool bRestrictMovements, EYCameraRestrictionType restrictCamera, bool bRestrictAbilities, bool bRestrictWeapons, bool bRestrictSwitchWeapons, bool bRestrictEnergyWheel, bool bRestrictOfficerNotifications, bool bRestrictChat, bool bRestrictScoringSystem, bool bSpectate, EYHudState hudState, bool restrictAbility1, bool restrictAbility2, bool restrictAbility3, bool restrictAbility4, bool restrictShortCommands, bool blockMovementForward, bool blockMovementBackward, bool blockMovementLeft, bool blockMovementRight, bool blockMovementUp, bool blockMovementDown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetPlayerRestrictions");
		
		AYPlayerController_SetPlayerRestrictions_Params params {};
		params.bRestrictMovements = bRestrictMovements;
		params.restrictCamera = restrictCamera;
		params.bRestrictAbilities = bRestrictAbilities;
		params.bRestrictWeapons = bRestrictWeapons;
		params.bRestrictSwitchWeapons = bRestrictSwitchWeapons;
		params.bRestrictEnergyWheel = bRestrictEnergyWheel;
		params.bRestrictOfficerNotifications = bRestrictOfficerNotifications;
		params.bRestrictChat = bRestrictChat;
		params.bRestrictScoringSystem = bRestrictScoringSystem;
		params.bSpectate = bSpectate;
		params.hudState = hudState;
		params.restrictAbility1 = restrictAbility1;
		params.restrictAbility2 = restrictAbility2;
		params.restrictAbility3 = restrictAbility3;
		params.restrictAbility4 = restrictAbility4;
		params.restrictShortCommands = restrictShortCommands;
		params.blockMovementForward = blockMovementForward;
		params.blockMovementBackward = blockMovementBackward;
		params.blockMovementLeft = blockMovementLeft;
		params.blockMovementRight = blockMovementRight;
		params.blockMovementUp = blockMovementUp;
		params.blockMovementDown = blockMovementDown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778780
	 * 		Name   -> Function DreadGame.YPlayerController.SetLastTimeMouseWasMoved
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::SetLastTimeMouseWasMoved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetLastTimeMouseWasMoved");
		
		AYPlayerController_SetLastTimeMouseWasMoved_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778700
	 * 		Name   -> Function DreadGame.YPlayerController.SetKillcamTimeUntilDestination
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetKillcamTimeUntilDestination(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetKillcamTimeUntilDestination");
		
		AYPlayerController_SetKillcamTimeUntilDestination_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778680
	 * 		Name   -> Function DreadGame.YPlayerController.SetKillcamPlayerHeightOffset
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              playerHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetKillcamPlayerHeightOffset(float playerHeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetKillcamPlayerHeightOffset");
		
		AYPlayerController_SetKillcamPlayerHeightOffset_Params params {};
		params.playerHeight = playerHeight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007777D0
	 * 		Name   -> Function DreadGame.YPlayerController.SetFogActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetFogActive(bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetFogActive");
		
		AYPlayerController_SetFogActive_Params params {};
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777090
	 * 		Name   -> Function DreadGame.YPlayerController.SetEnableCharacterSelection
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               canSelectNewCharacters                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetEnableCharacterSelection(bool canSelectNewCharacters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetEnableCharacterSelection");
		
		AYPlayerController_SetEnableCharacterSelection_Params params {};
		params.canSelectNewCharacters = canSelectNewCharacters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776F80
	 * 		Name   -> Function DreadGame.YPlayerController.SetDopplerAudioMultipler
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              multipler                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetDopplerAudioMultipler(float multipler)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetDopplerAudioMultipler");
		
		AYPlayerController_SetDopplerAudioMultipler_Params params {};
		params.multipler = multipler;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776EF0
	 * 		Name   -> Function DreadGame.YPlayerController.SetDebugStablisationSystem
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetDebugStablisationSystem(bool Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetDebugStablisationSystem");
		
		AYPlayerController_SetDebugStablisationSystem_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776E60
	 * 		Name   -> Function DreadGame.YPlayerController.SetDebugCrossHairs
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetDebugCrossHairs(bool Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetDebugCrossHairs");
		
		AYPlayerController_SetDebugCrossHairs_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776940
	 * 		Name   -> Function DreadGame.YPlayerController.SetCustomCameraDistance
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              newCustomCameraDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetCustomCameraDistance(float newCustomCameraDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetCustomCameraDistance");
		
		AYPlayerController_SetCustomCameraDistance_Params params {};
		params.newCustomCameraDistance = newCustomCameraDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775E10
	 * 		Name   -> Function DreadGame.YPlayerController.SetCamRotationRestriction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               restrictRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetCamRotationRestriction(bool restrictRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetCamRotationRestriction");
		
		AYPlayerController_SetCamRotationRestriction_Params params {};
		params.restrictRotation = restrictRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775EA0
	 * 		Name   -> Function DreadGame.YPlayerController.SetCameraFade
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnableFading                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      FadeColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   FadeAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFadeAudio                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bHoldFadeWhenFinished                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::SetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio, bool bHoldFadeWhenFinished)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetCameraFade");
		
		AYPlayerController_SetCameraFade_Params params {};
		params.bEnableFading = bEnableFading;
		params.FadeColor = FadeColor;
		params.FadeAlpha = FadeAlpha;
		params.FadeTime = FadeTime;
		params.bFadeAudio = bFadeAudio;
		params.bHoldFadeWhenFinished = bHoldFadeWhenFinished;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775750
	 * 		Name   -> Function DreadGame.YPlayerController.SetActiveLoadoutByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      loadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYShipLoadout* AYPlayerController::SetActiveLoadoutByName(const class FString& loadoutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SetActiveLoadoutByName");
		
		AYPlayerController_SetActiveLoadoutByName_Params params {};
		params.loadoutName = loadoutName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007749A0
	 * 		Name   -> Function DreadGame.YPlayerController.ServerToggleProjectileVisualDebug
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerToggleProjectileVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerToggleProjectileVisualDebug");
		
		AYPlayerController_ServerToggleProjectileVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774670
	 * 		Name   -> Function DreadGame.YPlayerController.ServerTeleportIntoLevel
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		struct FVector                                     teleportingLoc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    teleportingRot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerTeleportIntoLevel(const struct FVector& teleportingLoc, const struct FRotator& teleportingRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerTeleportIntoLevel");
		
		AYPlayerController_ServerTeleportIntoLevel_Params params {};
		params.teleportingLoc = teleportingLoc;
		params.teleportingRot = teleportingRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774530
	 * 		Name   -> Function DreadGame.YPlayerController.ServerStartProjectileReplication
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerStartProjectileReplication()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerStartProjectileReplication");
		
		AYPlayerController_ServerStartProjectileReplication_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774480
	 * 		Name   -> Function DreadGame.YPlayerController.ServerStartProfiling
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerStartProfiling(float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerStartProfiling");
		
		AYPlayerController_ServerStartProfiling_Params params {};
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773F70
	 * 		Name   -> Function DreadGame.YPlayerController.ServerSpawnNearActor
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      targetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRespawningForShipClassChange                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerSpawnNearActor(const class FName& loadoutId, class AActor* targetActor, bool bRespawningForShipClassChange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerSpawnNearActor");
		
		AYPlayerController_ServerSpawnNearActor_Params params {};
		params.loadoutId = loadoutId;
		params.targetActor = targetActor;
		params.bRespawningForShipClassChange = bRespawningForShipClassChange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773460
	 * 		Name   -> Function DreadGame.YPlayerController.ServerSetPawnToSpotted
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class AInfo*                                       replicationInfo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerSetPawnToSpotted(class AInfo* replicationInfo, bool State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerSetPawnToSpotted");
		
		AYPlayerController_ServerSetPawnToSpotted_Params params {};
		params.replicationInfo = replicationInfo;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773000
	 * 		Name   -> Function DreadGame.YPlayerController.ServerSendShortCommand
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		EYUIShortCommands                                  shortCommandId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerSendShortCommand(EYUIShortCommands shortCommandId, class AYPawn* targetPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerSendShortCommand");
		
		AYPlayerController_ServerSendShortCommand_Params params {};
		params.shortCommandId = shortCommandId;
		params.targetPawn = targetPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772B40
	 * 		Name   -> Function DreadGame.YPlayerController.ServerRoundOver
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerRoundOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerRoundOver");
		
		AYPlayerController_ServerRoundOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772920
	 * 		Name   -> Function DreadGame.YPlayerController.ServerRemoveRespawnFilter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               forceHudUpdate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerRemoveRespawnFilter(bool forceHudUpdate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerRemoveRespawnFilter");
		
		AYPlayerController_ServerRemoveRespawnFilter_Params params {};
		params.forceHudUpdate = forceHudUpdate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772590
	 * 		Name   -> Function DreadGame.YPlayerController.ServerReadyForJoining
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bFirstOrbitSpawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerReadyForJoining(bool bFirstOrbitSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerReadyForJoining");
		
		AYPlayerController_ServerReadyForJoining_Params params {};
		params.bFirstOrbitSpawn = bFirstOrbitSpawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YPlayerController.ServerProfile
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerProfile(float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerProfile");
		
		AYPlayerController_ServerProfile_Params params {};
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772380
	 * 		Name   -> Function DreadGame.YPlayerController.ServerPlayerReadyUpForMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               forcedSpawning                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerPlayerReadyUpForMatch(bool forcedSpawning)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerPlayerReadyUpForMatch");
		
		AYPlayerController_ServerPlayerReadyUpForMatch_Params params {};
		params.forcedSpawning = forcedSpawning;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007722C0
	 * 		Name   -> Function DreadGame.YPlayerController.ServerPlayerClickedShipLoadout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerPlayerClickedShipLoadout(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerPlayerClickedShipLoadout");
		
		AYPlayerController_ServerPlayerClickedShipLoadout_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007721B0
	 * 		Name   -> Function DreadGame.YPlayerController.ServerNotifyReturnToOutpostFromMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerNotifyReturnToOutpostFromMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerNotifyReturnToOutpostFromMatch");
		
		AYPlayerController_ServerNotifyReturnToOutpostFromMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772110
	 * 		Name   -> Function DreadGame.YPlayerController.ServerLogPlayersRating
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerLogPlayersRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerLogPlayersRating");
		
		AYPlayerController_ServerLogPlayersRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771DD0
	 * 		Name   -> Function DreadGame.YPlayerController.ServerInitializeMatchSoakTestData
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerInitializeMatchSoakTestData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerInitializeMatchSoakTestData");
		
		AYPlayerController_ServerInitializeMatchSoakTestData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771C30
	 * 		Name   -> Function DreadGame.YPlayerController.ServerFlushAnalyticsEvents
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerFlushAnalyticsEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerFlushAnalyticsEvents");
		
		AYPlayerController_ServerFlushAnalyticsEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771B70
	 * 		Name   -> Function DreadGame.YPlayerController.ServerExecCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerExecCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerExecCommand");
		
		AYPlayerController_ServerExecCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771450
	 * 		Name   -> Function DreadGame.YPlayerController.ServerCommand
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ServerCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerCommand");
		
		AYPlayerController_ServerCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771400
	 * 		Name   -> Function DreadGame.YPlayerController.ServerCancelRespawn
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerCancelRespawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerCancelRespawn");
		
		AYPlayerController_ServerCancelRespawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007712F0
	 * 		Name   -> Function DreadGame.YPlayerController.ServerApplyRespawnFilter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerApplyRespawnFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerApplyRespawnFilter");
		
		AYPlayerController_ServerApplyRespawnFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00771120
	 * 		Name   -> Function DreadGame.YPlayerController.ServerAbortWaveSpawn
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController::ServerAbortWaveSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ServerAbortWaveSpawn");
		
		AYPlayerController_ServerAbortWaveSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770250
	 * 		Name   -> Function DreadGame.YPlayerController.SaveCurrentViewTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::SaveCurrentViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.SaveCurrentViewTarget");
		
		AYPlayerController_SaveCurrentViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770230
	 * 		Name   -> Function DreadGame.YPlayerController.RoundOver
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::RoundOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.RoundOver");
		
		AYPlayerController_RoundOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770210
	 * 		Name   -> Function DreadGame.YPlayerController.ReturnToOutpostFromMatch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::ReturnToOutpostFromMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ReturnToOutpostFromMatch");
		
		AYPlayerController_ReturnToOutpostFromMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FC90
	 * 		Name   -> Function DreadGame.YPlayerController.ResetZoom
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::ResetZoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ResetZoom");
		
		AYPlayerController_ResetZoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FBB0
	 * 		Name   -> Function DreadGame.YPlayerController.ResetCameraRotations
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::ResetCameraRotations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ResetCameraRotations");
		
		AYPlayerController_ResetCameraRotations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F4A0
	 * 		Name   -> Function DreadGame.YPlayerController.ReplaceShipWithActiveLoadoutForNewRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::ReplaceShipWithActiveLoadoutForNewRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ReplaceShipWithActiveLoadoutForNewRound");
		
		AYPlayerController_ReplaceShipWithActiveLoadoutForNewRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F480
	 * 		Name   -> Function DreadGame.YPlayerController.ReplaceShipWithActiveLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::ReplaceShipWithActiveLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ReplaceShipWithActiveLoadout");
		
		AYPlayerController_ReplaceShipWithActiveLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076EFF0
	 * 		Name   -> Function DreadGame.YPlayerController.RemovePlayerRestrictions
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::RemovePlayerRestrictions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.RemovePlayerRestrictions");
		
		AYPlayerController_RemovePlayerRestrictions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E920
	 * 		Name   -> Function DreadGame.YPlayerController.ReloadingStartedDuration
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            weaponGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              reloadingTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ReloadingStartedDuration(int32_t weaponGroup, float reloadingTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ReloadingStartedDuration");
		
		AYPlayerController_ReloadingStartedDuration_Params params {};
		params.weaponGroup = weaponGroup;
		params.reloadingTime = reloadingTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E860
	 * 		Name   -> Function DreadGame.YPlayerController.ReloadingChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            weaponGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsReloading                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ReloadingChanged(int32_t weaponGroup, bool IsReloading)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ReloadingChanged");
		
		AYPlayerController_ReloadingChanged_Params params {};
		params.weaponGroup = weaponGroup;
		params.IsReloading = IsReloading;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.ProfileHUD
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ProfileHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ProfileHUD");
		
		AYPlayerController_ProfileHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YPlayerController.ProfileClient
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ProfileClient(float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ProfileClient");
		
		AYPlayerController_ProfileClient_Params params {};
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B820
	 * 		Name   -> Function DreadGame.YPlayerController.ProfileAll
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ProfileAll(float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ProfileAll");
		
		AYPlayerController_ProfileAll_Params params {};
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DD50
	 * 		Name   -> Function DreadGame.YPlayerController.PlayerToggleRespawnInfoPanel
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::PlayerToggleRespawnInfoPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.PlayerToggleRespawnInfoPanel");
		
		AYPlayerController_PlayerToggleRespawnInfoPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DC00
	 * 		Name   -> Function DreadGame.YPlayerController.PlayerReadyUpForMatch
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::PlayerReadyUpForMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.PlayerReadyUpForMatch");
		
		AYPlayerController_PlayerReadyUpForMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DAE0
	 * 		Name   -> Function DreadGame.YPlayerController.PlayerJoinsMultiplayerMatch
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::PlayerJoinsMultiplayerMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.PlayerJoinsMultiplayerMatch");
		
		AYPlayerController_PlayerJoinsMultiplayerMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B710
	 * 		Name   -> Function DreadGame.YPlayerController.OnTurnRight
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnTurnRight(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnTurnRight");
		
		AYPlayerController_OnTurnRight_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B580
	 * 		Name   -> Function DreadGame.YPlayerController.OnToggleShipSelection
	 * 		Flags  -> (Native, Public)
	 */
	void AYPlayerController::OnToggleShipSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnToggleShipSelection");
		
		AYPlayerController_OnToggleShipSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B560
	 * 		Name   -> Function DreadGame.YPlayerController.OnToggleScoreBoard
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnToggleScoreBoard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnToggleScoreBoard");
		
		AYPlayerController_OnToggleScoreBoard_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B520
	 * 		Name   -> Function DreadGame.YPlayerController.OnToggleMenu
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::OnToggleMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnToggleMenu");
		
		AYPlayerController_OnToggleMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AB80
	 * 		Name   -> Function DreadGame.YPlayerController.OnStopFire
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnStopFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnStopFire");
		
		AYPlayerController_OnStopFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AB20
	 * 		Name   -> Function DreadGame.YPlayerController.OnStartFire
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnStartFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnStartFire");
		
		AYPlayerController_OnStartFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A990
	 * 		Name   -> Function DreadGame.YPlayerController.OnSpectatedLoadoutInitilizedWithPawn
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      InPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnSpectatedLoadoutInitilizedWithPawn(class AYPawn* InPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnSpectatedLoadoutInitilizedWithPawn");
		
		AYPlayerController_OnSpectatedLoadoutInitilizedWithPawn_Params params {};
		params.InPawn = InPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A710
	 * 		Name   -> Function DreadGame.YPlayerController.OnShortCommandsUp
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnShortCommandsUp(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnShortCommandsUp");
		
		AYPlayerController_OnShortCommandsUp_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A690
	 * 		Name   -> Function DreadGame.YPlayerController.OnShortCommandsRight
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnShortCommandsRight(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnShortCommandsRight");
		
		AYPlayerController_OnShortCommandsRight_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007691E0
	 * 		Name   -> Function DreadGame.YPlayerController.OnRep_Team
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnRep_Team()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnRep_Team");
		
		AYPlayerController_OnRep_Team_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768B00
	 * 		Name   -> Function DreadGame.YPlayerController.OnReload
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnReload");
		
		AYPlayerController_OnReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768010
	 * 		Name   -> Function DreadGame.YPlayerController.OnPlayerRepScoringEvent
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class AYPlayerReplicationInfo*                     pri                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYPositiveReinforcement                     posReinf                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnPlayerRepScoringEvent(class AYPlayerReplicationInfo* pri, const struct FYPositiveReinforcement& posReinf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnPlayerRepScoringEvent");
		
		AYPlayerController_OnPlayerRepScoringEvent_Params params {};
		params.pri = pri;
		params.posReinf = posReinf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController.OnPawnDeath
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYPlayerController::OnPawnDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnPawnDeath");
		
		AYPlayerController_OnPawnDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController.OnPawnChangedBP
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnPawnChangedBP(class AYPawn* NewPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnPawnChangedBP");
		
		AYPlayerController_OnPawnChangedBP_Params params {};
		params.NewPawn = NewPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765E80
	 * 		Name   -> Function DreadGame.YPlayerController.OnOpenShortCommands
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnOpenShortCommands()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnOpenShortCommands");
		
		AYPlayerController_OnOpenShortCommands_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765E60
	 * 		Name   -> Function DreadGame.YPlayerController.OnOpenEnergyWheel
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnOpenEnergyWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnOpenEnergyWheel");
		
		AYPlayerController_OnOpenEnergyWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007659A0
	 * 		Name   -> Function DreadGame.YPlayerController.OnNextWeaponGroup
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnNextWeaponGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnNextWeaponGroup");
		
		AYPlayerController_OnNextWeaponGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007653A0
	 * 		Name   -> Function DreadGame.YPlayerController.OnMoveUp
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnMoveUp(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnMoveUp");
		
		AYPlayerController_OnMoveUp_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765320
	 * 		Name   -> Function DreadGame.YPlayerController.OnMoveForward
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnMoveForward(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnMoveForward");
		
		AYPlayerController_OnMoveForward_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764FF0
	 * 		Name   -> Function DreadGame.YPlayerController.OnLookUpPad
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnLookUpPad(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnLookUpPad");
		
		AYPlayerController_OnLookUpPad_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764F70
	 * 		Name   -> Function DreadGame.YPlayerController.OnLookUp
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnLookUp(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnLookUp");
		
		AYPlayerController_OnLookUp_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764EF0
	 * 		Name   -> Function DreadGame.YPlayerController.OnLookRightPad
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnLookRightPad(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnLookRightPad");
		
		AYPlayerController_OnLookRightPad_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764E70
	 * 		Name   -> Function DreadGame.YPlayerController.OnLookRight
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnLookRight(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnLookRight");
		
		AYPlayerController_OnLookRight_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.OnLoadoutInitilized
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnLoadoutInitilized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnLoadoutInitilized");
		
		AYPlayerController_OnLoadoutInitilized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007643C0
	 * 		Name   -> Function DreadGame.YPlayerController.OnInputTouchClick
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnInputTouchClick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnInputTouchClick");
		
		AYPlayerController_OnInputTouchClick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerController.OnHudHelpOverlayToggledSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               isOpened                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnHudHelpOverlayToggledSignature__DelegateSignature(bool isOpened)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerController.OnHudHelpOverlayToggledSignature__DelegateSignature");
		
		AYPlayerController_OnHudHelpOverlayToggledSignature__DelegateSignature_Params params {};
		params.isOpened = isOpened;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764230
	 * 		Name   -> Function DreadGame.YPlayerController.OnHudHelpOpened
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnHudHelpOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnHudHelpOpened");
		
		AYPlayerController_OnHudHelpOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764210
	 * 		Name   -> Function DreadGame.YPlayerController.OnHudHelpClosed
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnHudHelpClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnHudHelpClosed");
		
		AYPlayerController_OnHudHelpClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764170
	 * 		Name   -> Function DreadGame.YPlayerController.OnHandleRespawnInteraction
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnHandleRespawnInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnHandleRespawnInteraction");
		
		AYPlayerController_OnHandleRespawnInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763DD0
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat9
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat9()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat9");
		
		AYPlayerController_OnFeat9_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763DB0
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat8
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat8()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat8");
		
		AYPlayerController_OnFeat8_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763D90
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat7
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat7()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat7");
		
		AYPlayerController_OnFeat7_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763D70
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat6
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat6()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat6");
		
		AYPlayerController_OnFeat6_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763D50
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat5
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat5()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat5");
		
		AYPlayerController_OnFeat5_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763D30
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat4
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat4()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat4");
		
		AYPlayerController_OnFeat4_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763D10
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat3
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat3()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat3");
		
		AYPlayerController_OnFeat3_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763CF0
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat2
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat2");
		
		AYPlayerController_OnFeat2_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763CB0
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat12
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat12()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat12");
		
		AYPlayerController_OnFeat12_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763C90
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat11
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat11()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat11");
		
		AYPlayerController_OnFeat11_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763C70
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat10
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat10()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat10");
		
		AYPlayerController_OnFeat10_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763CD0
	 * 		Name   -> Function DreadGame.YPlayerController.OnFeat1
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnFeat1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnFeat1");
		
		AYPlayerController_OnFeat1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763AD0
	 * 		Name   -> Function DreadGame.YPlayerController.OnEnergyWheelUp
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnEnergyWheelUp(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnEnergyWheelUp");
		
		AYPlayerController_OnEnergyWheelUp_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763A50
	 * 		Name   -> Function DreadGame.YPlayerController.OnEnergyWheelTouch
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector2D                                   touchVector                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnEnergyWheelTouch(const struct FVector2D& touchVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnEnergyWheelTouch");
		
		AYPlayerController_OnEnergyWheelTouch_Params params {};
		params.touchVector = touchVector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007639D0
	 * 		Name   -> Function DreadGame.YPlayerController.OnEnergyWheelRight
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnEnergyWheelRight(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnEnergyWheelRight");
		
		AYPlayerController_OnEnergyWheelRight_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763970
	 * 		Name   -> Function DreadGame.YPlayerController.OnCycleCamera
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerController::OnCycleCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnCycleCamera");
		
		AYPlayerController_OnCycleCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007632E0
	 * 		Name   -> Function DreadGame.YPlayerController.OnCloseShortCommands
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnCloseShortCommands()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnCloseShortCommands");
		
		AYPlayerController_OnCloseShortCommands_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007632C0
	 * 		Name   -> Function DreadGame.YPlayerController.OnCloseEnergyWheel
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnCloseEnergyWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnCloseEnergyWheel");
		
		AYPlayerController_OnCloseEnergyWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762F80
	 * 		Name   -> Function DreadGame.YPlayerController.OnChatWhisper
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnChatWhisper()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnChatWhisper");
		
		AYPlayerController_OnChatWhisper_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762F60
	 * 		Name   -> Function DreadGame.YPlayerController.OnChatTeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnChatTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnChatTeam");
		
		AYPlayerController_OnChatTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762F40
	 * 		Name   -> Function DreadGame.YPlayerController.OnChatSquad
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnChatSquad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnChatSquad");
		
		AYPlayerController_OnChatSquad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762D60
	 * 		Name   -> Function DreadGame.YPlayerController.OnChatAll
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnChatAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnChatAll");
		
		AYPlayerController_OnChatAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController.OnCapturingCapturePoint
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYCapturePoint*                              CP                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               beingCaptured                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::OnCapturingCapturePoint(class AYCapturePoint* CP, bool beingCaptured)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnCapturingCapturePoint");
		
		AYPlayerController_OnCapturingCapturePoint_Params params {};
		params.CP = CP;
		params.beingCaptured = beingCaptured;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007629C0
	 * 		Name   -> Function DreadGame.YPlayerController.OnCancelShortCommands
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnCancelShortCommands()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnCancelShortCommands");
		
		AYPlayerController_OnCancelShortCommands_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007629A0
	 * 		Name   -> Function DreadGame.YPlayerController.OnCancelEnergyWheel
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::OnCancelEnergyWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnCancelEnergyWheel");
		
		AYPlayerController_OnCancelEnergyWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762210
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityTwoReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityTwoReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityTwoReleased");
		
		AYPlayerController_OnAbilityTwoReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007621F0
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityTwoPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityTwoPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityTwoPressed");
		
		AYPlayerController_OnAbilityTwoPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007621D0
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityThreeReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityThreeReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityThreeReleased");
		
		AYPlayerController_OnAbilityThreeReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007621B0
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityThreePressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityThreePressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityThreePressed");
		
		AYPlayerController_OnAbilityThreePressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762110
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityOneReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityOneReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityOneReleased");
		
		AYPlayerController_OnAbilityOneReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007620F0
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityOnePressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityOnePressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityOnePressed");
		
		AYPlayerController_OnAbilityOnePressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007620D0
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityFourReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityFourReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityFourReleased");
		
		AYPlayerController_OnAbilityFourReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007620B0
	 * 		Name   -> Function DreadGame.YPlayerController.OnAbilityFourPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::OnAbilityFourPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.OnAbilityFourPressed");
		
		AYPlayerController_OnAbilityFourPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007609B0
	 * 		Name   -> Function DreadGame.YPlayerController.LogPlayersRating
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::LogPlayersRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.LogPlayersRating");
		
		AYPlayerController_LogPlayersRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760970
	 * 		Name   -> Function DreadGame.YPlayerController.LogAllPlayersScore
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::LogAllPlayersScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.LogAllPlayersScore");
		
		AYPlayerController_LogAllPlayersScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E3C0
	 * 		Name   -> Function DreadGame.YPlayerController.IsClientSpectating
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYPlayerController::IsClientSpectating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.IsClientSpectating");
		
		AYPlayerController_IsClientSpectating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C940
	 * 		Name   -> Function DreadGame.YPlayerController.HideSearchManagerRecalculateWarning
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::HideSearchManagerRecalculateWarning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.HideSearchManagerRecalculateWarning");
		
		AYPlayerController_HideSearchManagerRecalculateWarning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C850
	 * 		Name   -> Function DreadGame.YPlayerController.HideCharacterSelectionHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::HideCharacterSelectionHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.HideCharacterSelectionHUD");
		
		AYPlayerController_HideCharacterSelectionHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C7B0
	 * 		Name   -> Function DreadGame.YPlayerController.HealthChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::HealthChanged(float newHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.HealthChanged");
		
		AYPlayerController_HealthChanged_Params params {};
		params.newHealth = newHealth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B220
	 * 		Name   -> Function DreadGame.YPlayerController.GetYTeam
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerController::GetYTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetYTeam");
		
		AYPlayerController_GetYTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B000
	 * 		Name   -> Function DreadGame.YPlayerController.GetYPlayerController
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPlayerController* AYPlayerController::GetYPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetYPlayerController");
		
		AYPlayerController_GetYPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ABE0
	 * 		Name   -> Function DreadGame.YPlayerController.GetYPawn
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPawn* AYPlayerController::GetYPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetYPawn");
		
		AYPlayerController_GetYPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075AB80
	 * 		Name   -> Function DreadGame.YPlayerController.GetYHUD
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYHUD* AYPlayerController::GetYHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetYHUD");
		
		AYPlayerController_GetYHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759880
	 * 		Name   -> Function DreadGame.YPlayerController.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYTeam AYPlayerController::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetTeam");
		
		AYPlayerController_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758970
	 * 		Name   -> Function DreadGame.YPlayerController.GetShipTier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerController::GetShipTier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetShipTier");
		
		AYPlayerController_GetShipTier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758450
	 * 		Name   -> Function DreadGame.YPlayerController.GetShipClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYShipClass AYPlayerController::GetShipClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetShipClass");
		
		AYPlayerController_GetShipClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756F20
	 * 		Name   -> Function DreadGame.YPlayerController.GetPlayerViewPoint
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     out_Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    out_Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::GetPlayerViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetPlayerViewPoint");
		
		AYPlayerController_GetPlayerViewPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_Location != nullptr)
			*out_Location = params.out_Location;
		if (out_Rotation != nullptr)
			*out_Rotation = params.out_Rotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756E70
	 * 		Name   -> Function DreadGame.YPlayerController.GetPlayerSpectatorComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYPlayerSpectatorComponent* AYPlayerController::GetPlayerSpectatorComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetPlayerSpectatorComponent");
		
		AYPlayerController_GetPlayerSpectatorComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756A70
	 * 		Name   -> Function DreadGame.YPlayerController.GetPlayerCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPlayerCamera* AYPlayerController::GetPlayerCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetPlayerCamera");
		
		AYPlayerController_GetPlayerCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754E80
	 * 		Name   -> Function DreadGame.YPlayerController.GetMusicManager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UYMusicManager* AYPlayerController::GetMusicManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetMusicManager");
		
		AYPlayerController_GetMusicManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007540D0
	 * 		Name   -> Function DreadGame.YPlayerController.GetMaximalRespawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerController::GetMaximalRespawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetMaximalRespawns");
		
		AYPlayerController_GetMaximalRespawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753700
	 * 		Name   -> Function DreadGame.YPlayerController.GetLastTimeMouseWasMove
	 * 		Flags  -> (Final, Native, Public)
	 */
	float AYPlayerController::GetLastTimeMouseWasMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetLastTimeMouseWasMove");
		
		AYPlayerController_GetLastTimeMouseWasMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751D80
	 * 		Name   -> Function DreadGame.YPlayerController.GetForcedRespawnTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerController::GetForcedRespawnTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetForcedRespawnTimer");
		
		AYPlayerController_GetForcedRespawnTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751610
	 * 		Name   -> Function DreadGame.YPlayerController.GetDebugStablisationSystem
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool AYPlayerController::GetDebugStablisationSystem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetDebugStablisationSystem");
		
		AYPlayerController_GetDebugStablisationSystem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750BB0
	 * 		Name   -> Function DreadGame.YPlayerController.GetCurrentRespawnWaveTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerController::GetCurrentRespawnWaveTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetCurrentRespawnWaveTimer");
		
		AYPlayerController_GetCurrentRespawnWaveTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750BE0
	 * 		Name   -> Function DreadGame.YPlayerController.GetCurrentRespawningTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float AYPlayerController::GetCurrentRespawningTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetCurrentRespawningTimer");
		
		AYPlayerController_GetCurrentRespawningTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007502E0
	 * 		Name   -> Function DreadGame.YPlayerController.GetControllerConfigIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AYPlayerController::GetControllerConfigIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetControllerConfigIndex");
		
		AYPlayerController_GetControllerConfigIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074CCE0
	 * 		Name   -> Function DreadGame.YPlayerController.GetActiveLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UYShipLoadout* AYPlayerController::GetActiveLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.GetActiveLoadout");
		
		AYPlayerController_GetActiveLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.ForceReturnToOutpost
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::ForceReturnToOutpost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ForceReturnToOutpost");
		
		AYPlayerController_ForceReturnToOutpost_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C5E0
	 * 		Name   -> Function DreadGame.YPlayerController.FlushAnalyticsEvents
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::FlushAnalyticsEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.FlushAnalyticsEvents");
		
		AYPlayerController_FlushAnalyticsEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C560
	 * 		Name   -> Function DreadGame.YPlayerController.FireScoringEventForPlayer
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYScoringEventID                                   eventID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::FireScoringEventForPlayer(EYScoringEventID eventID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.FireScoringEventForPlayer");
		
		AYPlayerController_FireScoringEventForPlayer_Params params {};
		params.eventID = eventID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B950
	 * 		Name   -> Function DreadGame.YPlayerController.EnergyChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Energy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::EnergyChanged(float Energy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.EnergyChanged");
		
		AYPlayerController_EnergyChanged_Params params {};
		params.Energy = Energy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B830
	 * 		Name   -> Function DreadGame.YPlayerController.EndClientSpectating
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AYPlayerController::EndClientSpectating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.EndClientSpectating");
		
		AYPlayerController_EndClientSpectating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B6F0
	 * 		Name   -> Function DreadGame.YPlayerController.EnableShipVelocityLogOutput
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               enableOutput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::EnableShipVelocityLogOutput(bool enableOutput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.EnableShipVelocityLogOutput");
		
		AYPlayerController_EnableShipVelocityLogOutput_Params params {};
		params.enableOutput = enableOutput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B4D0
	 * 		Name   -> Function DreadGame.YPlayerController.EnableDopplerAudioLogOutput
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               outputDopplerLog                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::EnableDopplerAudioLogOutput(bool outputDopplerLog)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.EnableDopplerAudioLogOutput");
		
		AYPlayerController_EnableDopplerAudioLogOutput_Params params {};
		params.outputDopplerLog = outputDopplerLog;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B3F0
	 * 		Name   -> Function DreadGame.YPlayerController.EnableActiveSpringDamping
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::EnableActiveSpringDamping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.EnableActiveSpringDamping");
		
		AYPlayerController_EnableActiveSpringDamping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B3D0
	 * 		Name   -> Function DreadGame.YPlayerController.DumpRegObjectives
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::DumpRegObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DumpRegObjectives");
		
		AYPlayerController_DumpRegObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A9A0
	 * 		Name   -> Function DreadGame.YPlayerController.DisableActiveSpringDamping
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::DisableActiveSpringDamping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DisableActiveSpringDamping");
		
		AYPlayerController_DisableActiveSpringDamping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.DebugPreWeaponMode
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerController::DebugPreWeaponMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DebugPreWeaponMode");
		
		AYPlayerController_DebugPreWeaponMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.DebugPreWeapon
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerController::DebugPreWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DebugPreWeapon");
		
		AYPlayerController_DebugPreWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.DebugNextWeaponMode
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerController::DebugNextWeaponMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DebugNextWeaponMode");
		
		AYPlayerController_DebugNextWeaponMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController.DebugNextWeapon
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerController::DebugNextWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DebugNextWeapon");
		
		AYPlayerController_DebugNextWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749CA0
	 * 		Name   -> Function DreadGame.YPlayerController.DebugLoadSettingPreset
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            preset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::DebugLoadSettingPreset(int32_t preset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DebugLoadSettingPreset");
		
		AYPlayerController_DebugLoadSettingPreset_Params params {};
		params.preset = preset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749C80
	 * 		Name   -> Function DreadGame.YPlayerController.DebugFadeToNormalScreen
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController::DebugFadeToNormalScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.DebugFadeToNormalScreen");
		
		AYPlayerController_DebugFadeToNormalScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747E40
	 * 		Name   -> Function DreadGame.YPlayerController.ClientWaitForRoundToEnd
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		float                                              respawnTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientWaitForRoundToEnd(float respawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientWaitForRoundToEnd");
		
		AYPlayerController_ClientWaitForRoundToEnd_Params params {};
		params.respawnTime = respawnTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007476E0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientTeleportIntoLevel
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     teleportingLoc                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    teleportingRot                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientTeleportIntoLevel(const struct FVector& teleportingLoc, const struct FRotator& teleportingRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientTeleportIntoLevel");
		
		AYPlayerController_ClientTeleportIntoLevel_Params params {};
		params.teleportingLoc = teleportingLoc;
		params.teleportingRot = teleportingRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747580
	 * 		Name   -> Function DreadGame.YPlayerController.ClientStartMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AYPlayerController::ClientStartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientStartMatch");
		
		AYPlayerController_ClientStartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007473D0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientSpawnNearActorResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               isPawnSpawned                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientSpawnNearActorResult(bool isPawnSpawned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientSpawnNearActorResult");
		
		AYPlayerController_ClientSpawnNearActorResult_Params params {};
		params.isPawnSpawned = isPawnSpawned;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747460
	 * 		Name   -> Function DreadGame.YPlayerController.ClientSpawningInGame
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYShipClass                                        shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientSpawningInGame(const struct FVector& Location, const struct FRotator& Rotation, EYShipClass shipclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientSpawningInGame");
		
		AYPlayerController_ClientSpawningInGame_Params params {};
		params.Location = Location;
		params.Rotation = Rotation;
		params.shipclass = shipclass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747030
	 * 		Name   -> Function DreadGame.YPlayerController.ClientSetRespawnWavetime
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		float                                              respawnTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxRespawnTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientSetRespawnWavetime(float respawnTime, float maxRespawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientSetRespawnWavetime");
		
		AYPlayerController_ClientSetRespawnWavetime_Params params {};
		params.respawnTime = respawnTime;
		params.maxRespawnTime = maxRespawnTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747100
	 * 		Name   -> Function DreadGame.YPlayerController.ClientSetRespawntime
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		float                                              respawnTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientSetRespawntime(float respawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientSetRespawntime");
		
		AYPlayerController_ClientSetRespawntime_Params params {};
		params.respawnTime = respawnTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746B40
	 * 		Name   -> Function DreadGame.YPlayerController.ClientSetPlayerRestrictions
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bRestrictMovements                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYCameraRestrictionType                            restrictCamera                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictAbilities                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictWeapons                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictSwitchWeapons                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictEnergyWheel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictOfficerNotifications                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictChat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestrictScoringSystem                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSpectate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EYHudState                                         hudState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility1                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility2                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility3                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictAbility4                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               restrictShortCommands                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FYSpecificMovementControlRestrictions       specificMovementRestrictions                               (Parm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientSetPlayerRestrictions(bool bRestrictMovements, EYCameraRestrictionType restrictCamera, bool bRestrictAbilities, bool bRestrictWeapons, bool bRestrictSwitchWeapons, bool bRestrictEnergyWheel, bool bRestrictOfficerNotifications, bool bRestrictChat, bool bRestrictScoringSystem, bool bSpectate, EYHudState hudState, bool restrictAbility1, bool restrictAbility2, bool restrictAbility3, bool restrictAbility4, bool restrictShortCommands, const struct FYSpecificMovementControlRestrictions& specificMovementRestrictions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientSetPlayerRestrictions");
		
		AYPlayerController_ClientSetPlayerRestrictions_Params params {};
		params.bRestrictMovements = bRestrictMovements;
		params.restrictCamera = restrictCamera;
		params.bRestrictAbilities = bRestrictAbilities;
		params.bRestrictWeapons = bRestrictWeapons;
		params.bRestrictSwitchWeapons = bRestrictSwitchWeapons;
		params.bRestrictEnergyWheel = bRestrictEnergyWheel;
		params.bRestrictOfficerNotifications = bRestrictOfficerNotifications;
		params.bRestrictChat = bRestrictChat;
		params.bRestrictScoringSystem = bRestrictScoringSystem;
		params.bSpectate = bSpectate;
		params.hudState = hudState;
		params.restrictAbility1 = restrictAbility1;
		params.restrictAbility2 = restrictAbility2;
		params.restrictAbility3 = restrictAbility3;
		params.restrictAbility4 = restrictAbility4;
		params.restrictShortCommands = restrictShortCommands;
		params.specificMovementRestrictions = specificMovementRestrictions;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746AC0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientSetMatchSoakTestData
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		EYFleetType                                        usedFleetType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientSetMatchSoakTestData(EYFleetType usedFleetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientSetMatchSoakTestData");
		
		AYPlayerController_ClientSetMatchSoakTestData_Params params {};
		params.usedFleetType = usedFleetType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746690
	 * 		Name   -> Function DreadGame.YPlayerController.ClientSendShortCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		EYUIShortCommands                                  shortCommandId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      senderPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      targetedPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientSendShortCommand(EYUIShortCommands shortCommandId, class AYPawn* senderPawn, class AYPawn* targetedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientSendShortCommand");
		
		AYPlayerController_ClientSendShortCommand_Params params {};
		params.shortCommandId = shortCommandId;
		params.senderPawn = senderPawn;
		params.targetedPawn = targetedPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746600
	 * 		Name   -> Function DreadGame.YPlayerController.ClientRunTimerForForcedRespawn
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		int32_t                                            serverTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientRunTimerForForcedRespawn(int32_t serverTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientRunTimerForForcedRespawn");
		
		AYPlayerController_ClientRunTimerForForcedRespawn_Params params {};
		params.serverTime = serverTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007465B0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientReturnToOutpostFromMatchACK
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
	 */
	void AYPlayerController::ClientReturnToOutpostFromMatchACK()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientReturnToOutpostFromMatchACK");
		
		AYPlayerController_ClientReturnToOutpostFromMatchACK_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746530
	 * 		Name   -> Function DreadGame.YPlayerController.ClientRespawnTeamElimination
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		float                                              respawnTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientRespawnTeamElimination(float respawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientRespawnTeamElimination");
		
		AYPlayerController_ClientRespawnTeamElimination_Params params {};
		params.respawnTime = respawnTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007464A0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientRemoveRespawnFilter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		bool                                               forceHudUpdate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientRemoveRespawnFilter(bool forceHudUpdate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientRemoveRespawnFilter");
		
		AYPlayerController_ClientRemoveRespawnFilter_Params params {};
		params.forceHudUpdate = forceHudUpdate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007461C0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientPreRoundStart
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		float                                              preRoundStartDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientPreRoundStart(float preRoundStartDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientPreRoundStart");
		
		AYPlayerController_ClientPreRoundStart_Params params {};
		params.preRoundStartDuration = preRoundStartDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007461A0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientPostRoundEnd
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AYPlayerController::ClientPostRoundEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientPostRoundEnd");
		
		AYPlayerController_ClientPostRoundEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007460A0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientOnScore
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            Points                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientOnScore(int32_t Points, const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientOnScore");
		
		AYPlayerController_ClientOnScore_Params params {};
		params.Points = Points;
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745730
	 * 		Name   -> Function DreadGame.YPlayerController.ClientNewRoundStarts
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		int32_t                                            roundNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYLateJoinState                                    serverLateJoinState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientNewRoundStarts(int32_t roundNumber, EYLateJoinState serverLateJoinState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientNewRoundStarts");
		
		AYPlayerController_ClientNewRoundStarts_Params params {};
		params.roundNumber = roundNumber;
		params.serverLateJoinState = serverLateJoinState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745710
	 * 		Name   -> Function DreadGame.YPlayerController.ClientMatchOver
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AYPlayerController::ClientMatchOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientMatchOver");
		
		AYPlayerController_ClientMatchOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007456F0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientMakeSureOrbitTransitionEnded
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AYPlayerController::ClientMakeSureOrbitTransitionEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientMakeSureOrbitTransitionEnded");
		
		AYPlayerController_ClientMakeSureOrbitTransitionEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007456D0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientLeavingMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AYPlayerController::ClientLeavingMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientLeavingMatch");
		
		AYPlayerController_ClientLeavingMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745640
	 * 		Name   -> Function DreadGame.YPlayerController.ClientLateJoinWaitingForNewRound
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            roundNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientLateJoinWaitingForNewRound(int32_t roundNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientLateJoinWaitingForNewRound");
		
		AYPlayerController_ClientLateJoinWaitingForNewRound_Params params {};
		params.roundNumber = roundNumber;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007455B0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientLateJoinInMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            roundNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientLateJoinInMatch(int32_t roundNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientLateJoinInMatch");
		
		AYPlayerController_ClientLateJoinInMatch_Params params {};
		params.roundNumber = roundNumber;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00745080
	 * 		Name   -> Function DreadGame.YPlayerController.ClientEnableCharacterSelection
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientEnableCharacterSelection(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientEnableCharacterSelection");
		
		AYPlayerController_ClientEnableCharacterSelection_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744DA0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientDisableShipSelection
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AYPlayerController::ClientDisableShipSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientDisableShipSelection");
		
		AYPlayerController_ClientDisableShipSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744CD0
	 * 		Name   -> Function DreadGame.YPlayerController.ClientCapturingCapturePoint
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AYCapturePoint*                              CP                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               beingCaptured                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::ClientCapturingCapturePoint(class AYCapturePoint* CP, bool beingCaptured)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientCapturingCapturePoint");
		
		AYPlayerController_ClientCapturingCapturePoint_Params params {};
		params.CP = CP;
		params.beingCaptured = beingCaptured;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744B90
	 * 		Name   -> Function DreadGame.YPlayerController.ClientApplyRespawnFilter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AYPlayerController::ClientApplyRespawnFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ClientApplyRespawnFilter");
		
		AYPlayerController_ClientApplyRespawnFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743F10
	 * 		Name   -> Function DreadGame.YPlayerController.CapturePointOwnerChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CPIdx                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::CapturePointOwnerChanged(EYTeam Team, int32_t CPIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.CapturePointOwnerChanged");
		
		AYPlayerController_CapturePointOwnerChanged_Params params {};
		params.Team = Team;
		params.CPIdx = CPIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007421B0
	 * 		Name   -> Function DreadGame.YPlayerController.BlockInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               doBlock                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               flushPreviousInput                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::BlockInput(bool doBlock, bool flushPreviousInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.BlockInput");
		
		AYPlayerController_BlockInput_Params params {};
		params.doBlock = doBlock;
		params.flushPreviousInput = flushPreviousInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00740D00
	 * 		Name   -> Function DreadGame.YPlayerController.AmmoChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            weaponGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ammo                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::AmmoChanged(int32_t weaponGroup, int32_t ammo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.AmmoChanged");
		
		AYPlayerController_AmmoChanged_Params params {};
		params.weaponGroup = weaponGroup;
		params.ammo = ammo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E100
	 * 		Name   -> Function DreadGame.YPlayerController.AddAndActiveLoadoutFromBlueprint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      loadoutBP                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController::AddAndActiveLoadoutFromBlueprint(class UClass* loadoutBP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.AddAndActiveLoadoutFromBlueprint");
		
		AYPlayerController_AddAndActiveLoadoutFromBlueprint_Params params {};
		params.loadoutBP = loadoutBP;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073E060
	 * 		Name   -> Function DreadGame.YPlayerController.ActiveRespawnCompleted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPlayerController::ActiveRespawnCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController.ActiveRespawnCompleted");
		
		AYPlayerController_ActiveRespawnCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783960
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.UpdateItemsUnlockedLastMacht
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AYPlayerController_Outpost::UpdateItemsUnlockedLastMacht()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.UpdateItemsUnlockedLastMacht");
		
		AYPlayerController_Outpost_UpdateItemsUnlockedLastMacht_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.UnlockEverythingInCurrentShip
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController_Outpost::UnlockEverythingInCurrentShip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.UnlockEverythingInCurrentShip");
		
		AYPlayerController_Outpost_UnlockEverythingInCurrentShip_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.ToggleMarketPreview
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController_Outpost::ToggleMarketPreview()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.ToggleMarketPreview");
		
		AYPlayerController_Outpost_ToggleMarketPreview_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.ToggleCrateAnimation
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController_Outpost::ToggleCrateAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.ToggleCrateAnimation");
		
		AYPlayerController_Outpost_ToggleCrateAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FB40
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.StartDemoMode
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController_Outpost::StartDemoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.StartDemoMode");
		
		AYPlayerController_Outpost_StartDemoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00BBF7F0
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.ShouldSkipIntroVideo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AYPlayerController_Outpost::ShouldSkipIntroVideo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.ShouldSkipIntroVideo");
		
		AYPlayerController_Outpost_ShouldSkipIntroVideo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.ResetOnboardingFlow
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AYPlayerController_Outpost::ResetOnboardingFlow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.ResetOnboardingFlow");
		
		AYPlayerController_Outpost_ResetOnboardingFlow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F090
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.RenderCustomizedCaptainToFile
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController_Outpost::RenderCustomizedCaptainToFile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.RenderCustomizedCaptainToFile");
		
		AYPlayerController_Outpost_RenderCustomizedCaptainToFile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B6F0
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.OnTriggerInitialCharacterCreationFinished
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController_Outpost::OnTriggerInitialCharacterCreationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.OnTriggerInitialCharacterCreationFinished");
		
		AYPlayerController_Outpost_OnTriggerInitialCharacterCreationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765EA0
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.OnOutpostCameraPreviewStateChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               isPreviewing                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::OnOutpostCameraPreviewStateChanged(bool isPreviewing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.OnOutpostCameraPreviewStateChanged");
		
		AYPlayerController_Outpost_OnOutpostCameraPreviewStateChanged_Params params {};
		params.isPreviewing = isPreviewing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.OnMatchmakingStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYMenuMatchMakingState                             NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::OnMatchmakingStateChanged(EYMenuMatchMakingState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.OnMatchmakingStateChanged");
		
		AYPlayerController_Outpost_OnMatchmakingStateChanged_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerController_Outpost.OnInitialCharacterCreationFinished__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerController_Outpost::OnInitialCharacterCreationFinished__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerController_Outpost.OnInitialCharacterCreationFinished__DelegateSignature");
		
		AYPlayerController_Outpost_OnInitialCharacterCreationFinished__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DD30
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.InterruptCurrentVoiceline
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AYPlayerController_Outpost::InterruptCurrentVoiceline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.InterruptCurrentVoiceline");
		
		AYPlayerController_Outpost_InterruptCurrentVoiceline_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750980
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.GetCurrentLoadoutClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UBlueprintGeneratedClass* AYPlayerController_Outpost::GetCurrentLoadoutClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.GetCurrentLoadoutClass");
		
		AYPlayerController_Outpost_GetCurrentLoadoutClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A3D0
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.DebugToggle3DCam
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AYPlayerController_Outpost::DebugToggle3DCam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.DebugToggle3DCam");
		
		AYPlayerController_Outpost_DebugToggle3DCam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775530
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableSlot
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		EYUILoadoutItemType                                loadoutType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutButtonEnableSlot(EYUILoadoutItemType loadoutType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableSlot");
		
		AYPlayerController_Outpost_CalloutButtonEnableSlot_Params params {};
		params.loadoutType = loadoutType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableByNameAlways
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      buttonID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutButtonEnableByNameAlways(const class FString& buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableByNameAlways");
		
		AYPlayerController_Outpost_CalloutButtonEnableByNameAlways_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableByName
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      buttonID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutButtonEnableByName(const class FString& buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableByName");
		
		AYPlayerController_Outpost_CalloutButtonEnableByName_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableByID
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            buttonID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutButtonEnableByID(int32_t buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutButtonEnableByID");
		
		AYPlayerController_Outpost_CalloutButtonEnableByID_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C680
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutButtonDisableByName
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      buttonID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutButtonDisableByName(const class FString& buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutButtonDisableByName");
		
		AYPlayerController_Outpost_CalloutButtonDisableByName_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutButtonDisableByID
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            buttonID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutButtonDisableByID(int32_t buttonID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutButtonDisableByID");
		
		AYPlayerController_Outpost_CalloutButtonDisableByID_Params params {};
		params.buttonID = buttonID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741F20
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutAlwaysUnlockButtonDisableByName
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutAlwaysUnlockButtonDisableByName(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutAlwaysUnlockButtonDisableByName");
		
		AYPlayerController_Outpost_CalloutAlwaysUnlockButtonDisableByName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742E90
	 * 		Name   -> Function DreadGame.YPlayerController_Outpost.CalloutAlwaysUnlockButtonDisableByID
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Outpost::CalloutAlwaysUnlockButtonDisableByID(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Outpost.CalloutAlwaysUnlockButtonDisableByID");
		
		AYPlayerController_Outpost_CalloutAlwaysUnlockButtonDisableByID_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerController_Outpost.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerController_Outpost::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerController_Outpost");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E50000
	 * 		Name   -> Function DreadGame.YOutpostCameraModule.RegisterForHudNotifications
	 * 		Flags  -> (Native, Public)
	 */
	void UYOutpostCameraModule::RegisterForHudNotifications()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCameraModule.RegisterForHudNotifications");
		
		UYOutpostCameraModule_RegisterForHudNotifications_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768510
	 * 		Name   -> Function DreadGame.YOutpostCameraModule.OnPreviewComponentTypeChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYCameraPreviewComponentType                       previousType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYCameraPreviewComponentType                       NewType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYOutpostCameraModule::OnPreviewComponentTypeChanged(EYCameraPreviewComponentType previousType, EYCameraPreviewComponentType NewType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCameraModule.OnPreviewComponentTypeChanged");
		
		UYOutpostCameraModule_OnPreviewComponentTypeChanged_Params params {};
		params.previousType = previousType;
		params.NewType = NewType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765F50
	 * 		Name   -> Function DreadGame.YOutpostCameraModule.OnOutpostSectionChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYOutpostSection                                   prevSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYOutpostSection                                   newSection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOutpostCameraModule::OnOutpostSectionChanged(EYOutpostSection prevSection, EYOutpostSection newSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCameraModule.OnOutpostSectionChanged");
		
		UYOutpostCameraModule_OnOutpostSectionChanged_Params params {};
		params.prevSection = prevSection;
		params.newSection = newSection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763380
	 * 		Name   -> Function DreadGame.YOutpostCameraModule.OnComponentInPreviewChanged
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FCachedItemIDDataEntry                      cachedItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EYUILoadoutItemType                                itemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeleportToComponent                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYOutpostCameraModule::OnComponentInPreviewChanged(const struct FCachedItemIDDataEntry& cachedItemData, EYUILoadoutItemType itemType, bool bTeleportToComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCameraModule.OnComponentInPreviewChanged");
		
		UYOutpostCameraModule_OnComponentInPreviewChanged_Params params {};
		params.cachedItemData = cachedItemData;
		params.itemType = itemType;
		params.bTeleportToComponent = bTeleportToComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762910
	 * 		Name   -> Function DreadGame.YOutpostCameraModule.OnCameraPlayingInterpolation
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		bool                                               bInterpolationStarts                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYOutpostCameraModule::OnCameraPlayingInterpolation(bool bInterpolationStarts)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCameraModule.OnCameraPlayingInterpolation");
		
		UYOutpostCameraModule_OnCameraPlayingInterpolation_Params params {};
		params.bInterpolationStarts = bInterpolationStarts;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007623B0
	 * 		Name   -> Function DreadGame.YOutpostCameraModule.OnActorInPreviewChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class AActor*                                      previewActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOutpostCameraModule::OnActorInPreviewChanged(class AActor* previewActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostCameraModule.OnActorInPreviewChanged");
		
		UYOutpostCameraModule_OnActorInPreviewChanged_Params params {};
		params.previewActor = previewActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOutpostCameraModule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOutpostCameraModule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOutpostCameraModule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOutpostCameraModule_CharacterPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOutpostCameraModule_CharacterPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOutpostCameraModule_CharacterPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOutpostCameraModule_DefaultPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOutpostCameraModule_DefaultPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOutpostCameraModule_DefaultPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOutpostCameraModule_ShipPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOutpostCameraModule_ShipPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOutpostCameraModule_ShipPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOutpostCameraModule_PurchasePreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOutpostCameraModule_PurchasePreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOutpostCameraModule_PurchasePreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781780
	 * 		Name   -> Function DreadGame.YOutpostTransitionManager.TransitionStepCompleted
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYOutpostTransitionManager::TransitionStepCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostTransitionManager.TransitionStepCompleted");
		
		UYOutpostTransitionManager_TransitionStepCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YOutpostTransitionManager.OnCameraBlend_MoveToHangar
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class ACameraActor*                                startingCam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                hangarCam                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPlayerController_Outpost*                  Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYOutpostTransitionManager::OnCameraBlend_MoveToHangar(class ACameraActor* startingCam, class ACameraActor* hangarCam, class AYPlayerController_Outpost* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YOutpostTransitionManager.OnCameraBlend_MoveToHangar");
		
		UYOutpostTransitionManager_OnCameraBlend_MoveToHangar_Params params {};
		params.startingCam = startingCam;
		params.hangarCam = hangarCam;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYOutpostTransitionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYOutpostTransitionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YOutpostTransitionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYParticleModuleClampVelocity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYParticleModuleClampVelocity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YParticleModuleClampVelocity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYParticleModuleLightMaxCount.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYParticleModuleLightMaxCount::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YParticleModuleLightMaxCount");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYParticleModuleLocationSequence.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYParticleModuleLocationSequence::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YParticleModuleLocationSequence");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYParticleModuleVelInheritParentShip.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYParticleModuleVelInheritParentShip::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YParticleModuleVelInheritParentShip");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCreepPawn.ReceiveOnRepTeamChange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYCreepPawn::ReceiveOnRepTeamChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.ReceiveOnRepTeamChange");
		
		AYCreepPawn_ReceiveOnRepTeamChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCreepPawn.ReceiveOnJumpOut
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYCreepPawn::ReceiveOnJumpOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.ReceiveOnJumpOut");
		
		AYCreepPawn_ReceiveOnJumpOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769060
	 * 		Name   -> Function DreadGame.YCreepPawn.OnRep_ServerNextNavigation
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYCreepPawn::OnRep_ServerNextNavigation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.OnRep_ServerNextNavigation");
		
		AYCreepPawn_OnRep_ServerNextNavigation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769040
	 * 		Name   -> Function DreadGame.YCreepPawn.OnRep_ServerNavigationOffset
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYCreepPawn::OnRep_ServerNavigationOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.OnRep_ServerNavigationOffset");
		
		AYCreepPawn_OnRep_ServerNavigationOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769380
	 * 		Name   -> Function DreadGame.YCreepPawn.OnRep_evaIndex
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYCreepPawn::OnRep_evaIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.OnRep_evaIndex");
		
		AYCreepPawn_OnRep_evaIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YCreepPawn.OnLaunchedFromCapitalShip
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYCreepPawn::OnLaunchedFromCapitalShip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.OnLaunchedFromCapitalShip");
		
		AYCreepPawn_OnLaunchedFromCapitalShip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760020
	 * 		Name   -> Function DreadGame.YCreepPawn.JumpOutMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		float                                              jumpOutTimer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCreepPawn::JumpOutMulticast(float jumpOutTimer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.JumpOutMulticast");
		
		AYCreepPawn_JumpOutMulticast_Params params {};
		params.jumpOutTimer = jumpOutTimer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F2D0
	 * 		Name   -> Function DreadGame.YCreepPawn.IsMyTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AYCreepPawn::IsMyTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.IsMyTeam");
		
		AYCreepPawn_IsMyTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744170
	 * 		Name   -> Function DreadGame.YCreepPawn.ChangeTargetMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class AActor*                                      newTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYCreepPawn::ChangeTargetMulticast(class AActor* newTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.ChangeTargetMulticast");
		
		AYCreepPawn_ChangeTargetMulticast_Params params {};
		params.newTarget = newTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743FE0
	 * 		Name   -> Function DreadGame.YCreepPawn.ChangeFlightplanMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		TArray<struct FVector>                             flightPlan                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYCreepPawn::ChangeFlightplanMulticast(TArray<struct FVector> flightPlan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YCreepPawn.ChangeFlightplanMulticast");
		
		AYCreepPawn_ChangeFlightplanMulticast_Params params {};
		params.flightPlan = flightPlan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYCreepPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYCreepPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YCreepPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPawn_RespawnJet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPawn_RespawnJet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPawn_RespawnJet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYFighterDroneAIController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYFighterDroneAIController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YFighterDroneAIController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074FFD0
	 * 		Name   -> Function DreadGame.YNPCAIClientController.GetBotPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPawn* AYNPCAIClientController::GetBotPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIClientController.GetBotPawn");
		
		AYNPCAIClientController_GetBotPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YNPCAIClientController.AutoSetupSecondaryWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYNPCAIClientController::AutoSetupSecondaryWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YNPCAIClientController.AutoSetupSecondaryWeapon");
		
		AYNPCAIClientController_AutoSetupSecondaryWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYNPCAIClientController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYNPCAIClientController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YNPCAIClientController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767D30
	 * 		Name   -> Function DreadGame.YPlayerAIController.OnPlayerPawnHit
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      SelfActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AYPlayerAIController::OnPlayerPawnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerAIController.OnPlayerPawnHit");
		
		AYPlayerAIController_OnPlayerPawnHit_Params params {};
		params.SelfActor = SelfActor;
		params.OtherActor = OtherActor;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerAIController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerAIController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerAIController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPawnOrbitComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPawnOrbitComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPawnOrbitComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPeripheralEventMgr.YPlayerControllerBaseAndYPawnDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPlayerControllerBase*                      source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      pPawn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPeripheralEventMgr::YPlayerControllerBaseAndYPawnDelegate__DelegateSignature(class AYPlayerControllerBase* source, class AYPawn* pPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPeripheralEventMgr.YPlayerControllerBaseAndYPawnDelegate__DelegateSignature");
		
		UYPeripheralEventMgr_YPlayerControllerBaseAndYPawnDelegate__DelegateSignature_Params params {};
		params.source = source;
		params.pPawn = pPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPeripheralEventMgr.YMatchOutcomeDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYMatchOutcome                                     outcome                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPeripheralEventMgr::YMatchOutcomeDelegate__DelegateSignature(EYMatchOutcome outcome)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPeripheralEventMgr.YMatchOutcomeDelegate__DelegateSignature");
		
		UYPeripheralEventMgr_YMatchOutcomeDelegate__DelegateSignature_Params params {};
		params.outcome = outcome;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPeripheralEventMgr.YGameEngineDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYPeripheralEventMgr::YGameEngineDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPeripheralEventMgr.YGameEngineDelegate__DelegateSignature");
		
		UYPeripheralEventMgr_YGameEngineDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPeripheralEventMgr.OnMenuSectionSelected__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EYOutpostSection                                   outpostSection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPeripheralEventMgr::OnMenuSectionSelected__DelegateSignature(EYOutpostSection outpostSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPeripheralEventMgr.OnMenuSectionSelected__DelegateSignature");
		
		UYPeripheralEventMgr_OnMenuSectionSelected__DelegateSignature_Params params {};
		params.outpostSection = outpostSection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F010
	 * 		Name   -> Function DreadGame.YPeripheralEventMgr.IsInitialized
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYPeripheralEventMgr::IsInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPeripheralEventMgr.IsInitialized");
		
		UYPeripheralEventMgr_IsInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C1E0
	 * 		Name   -> Function DreadGame.YPeripheralEventMgr.HandlePlayerPawnChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      pPawn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPeripheralEventMgr::HandlePlayerPawnChanged(class AYPawn* pPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPeripheralEventMgr.HandlePlayerPawnChanged");
		
		UYPeripheralEventMgr_HandlePlayerPawnChanged_Params params {};
		params.pPawn = pPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BDF0
	 * 		Name   -> Function DreadGame.YPeripheralEventMgr.HandleOnPlayerControllerSet
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPlayerControllerBase*                      PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPeripheralEventMgr::HandleOnPlayerControllerSet(class AYPlayerControllerBase* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPeripheralEventMgr.HandleOnPlayerControllerSet");
		
		UYPeripheralEventMgr_HandleOnPlayerControllerSet_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BAB0
	 * 		Name   -> Function DreadGame.YPeripheralEventMgr.HandleOnLoadingScreenOpenInternal
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPeripheralEventMgr::HandleOnLoadingScreenOpenInternal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPeripheralEventMgr.HandleOnLoadingScreenOpenInternal");
		
		UYPeripheralEventMgr_HandleOnLoadingScreenOpenInternal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075BED0
	 * 		Name   -> Function DreadGame.YPeripheralEventMgr.HandleOnLoadingScreenClosedInternal
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPeripheralEventMgr::HandleOnLoadingScreenClosedInternal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPeripheralEventMgr.HandleOnLoadingScreenClosedInternal");
		
		UYPeripheralEventMgr_HandleOnLoadingScreenClosedInternal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075B3B0
	 * 		Name   -> Function DreadGame.YPeripheralEventMgr.HandleMenuSectionSelected
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYOutpostSection                                   newSection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPeripheralEventMgr::HandleMenuSectionSelected(EYOutpostSection newSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPeripheralEventMgr.HandleMenuSectionSelected");
		
		UYPeripheralEventMgr_HandleMenuSectionSelected_Params params {};
		params.newSection = newSection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPeripheralEventMgr.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPeripheralEventMgr::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPeripheralEventMgr");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770100
	 * 		Name   -> Function DreadGame.YPerkManager.RetrievePerkRankDescriber
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            rank                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYPerkManager::STATIC_RetrievePerkRankDescriber(int32_t rank)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPerkManager.RetrievePerkRankDescriber");
		
		UYPerkManager_RetrievePerkRankDescriber_Params params {};
		params.rank = rank;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770040
	 * 		Name   -> Function DreadGame.YPerkManager.RetrievePerkByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            rank                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYPerk* UYPerkManager::RetrievePerkByName(const class FName& Name, int32_t rank)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPerkManager.RetrievePerkByName");
		
		UYPerkManager_RetrievePerkByName_Params params {};
		params.Name = Name;
		params.rank = rank;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPerkManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPerkManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPerkManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FB30
	 * 		Name   -> Function DreadGame.YPlayerCamera.ResetCameraRotations
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerCamera::ResetCameraRotations(class AYPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerCamera.ResetCameraRotations");
		
		AYPlayerCamera_ResetCameraRotations_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755B40
	 * 		Name   -> Function DreadGame.YPlayerCamera.GetPOVRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator AYPlayerCamera::GetPOVRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerCamera.GetPOVRotation");
		
		AYPlayerCamera_GetPOVRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755B10
	 * 		Name   -> Function DreadGame.YPlayerCamera.GetPOVLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AYPlayerCamera::GetPOVLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerCamera.GetPOVLocation");
		
		AYPlayerCamera_GetPOVLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerCamera.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerCamera::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerCamera");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782DC0
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.UnReadyPlayerForNextWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController_Havoc::UnReadyPlayerForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.UnReadyPlayerForNextWave");
		
		AYPlayerController_Havoc_UnReadyPlayerForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.TimeToNextWaveChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            secondsRemaining                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::TimeToNextWaveChanged(int32_t secondsRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.TimeToNextWaveChanged");
		
		AYPlayerController_Havoc_TimeToNextWaveChanged_Params params {};
		params.secondsRemaining = secondsRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780620
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.StoreSelectedLoadoutID
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        loadoutId                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::StoreSelectedLoadoutID(const class FName& loadoutId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.StoreSelectedLoadoutID");
		
		AYPlayerController_Havoc_StoreSelectedLoadoutID_Params params {};
		params.loadoutId = loadoutId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774B40
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.ServerUnReadyPlayerForNextWave
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController_Havoc::ServerUnReadyPlayerForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.ServerUnReadyPlayerForNextWave");
		
		AYPlayerController_Havoc_ServerUnReadyPlayerForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007727A0
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.ServerReceiveSelectedUpgradeIndex
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::ServerReceiveSelectedUpgradeIndex(int32_t SlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.ServerReceiveSelectedUpgradeIndex");
		
		AYPlayerController_Havoc_ServerReceiveSelectedUpgradeIndex_Params params {};
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00772650
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.ServerReadyUpPlayerForNextWave
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AYPlayerController_Havoc::ServerReadyUpPlayerForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.ServerReadyUpPlayerForNextWave");
		
		AYPlayerController_Havoc_ServerReadyUpPlayerForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770BF0
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.SendSelectedUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        userSelectedUpgradeID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::SendSelectedUpgrade(const class FName& userSelectedUpgradeID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.SendSelectedUpgrade");
		
		AYPlayerController_Havoc_SendSelectedUpgrade_Params params {};
		params.userSelectedUpgradeID = userSelectedUpgradeID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E6A0
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.ReadyUpPlayerForNextWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController_Havoc::ReadyUpPlayerForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.ReadyUpPlayerForNextWave");
		
		AYPlayerController_Havoc_ReadyUpPlayerForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F710
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.IsReadyForNextWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYPlayerController_Havoc::IsReadyForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.IsReadyForNextWave");
		
		AYPlayerController_Havoc_IsReadyForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075AB20
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.GetXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AYPlayerController_Havoc::GetXP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.GetXP");
		
		AYPlayerController_Havoc_GetXP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757F10
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.GetSelectedLoadoutID
	 * 		Flags  -> (Final, Native, Public)
	 */
	class FName AYPlayerController_Havoc::GetSelectedLoadoutID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.GetSelectedLoadoutID");
		
		AYPlayerController_Havoc_GetSelectedLoadoutID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A4B0
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.DeductXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		int32_t                                            xp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::DeductXP(int32_t xp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.DeductXP");
		
		AYPlayerController_Havoc_DeductXP_Params params {};
		params.xp = xp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007463E0
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.ClientReceiveRandSelectedUpgrades
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
	 * Parameters:
	 * 		TArray<class FName>                                randSelectedUpgrades                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::ClientReceiveRandSelectedUpgrades(TArray<class FName> randSelectedUpgrades)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.ClientReceiveRandSelectedUpgrades");
		
		AYPlayerController_Havoc_ClientReceiveRandSelectedUpgrades_Params params {};
		params.randSelectedUpgrades = randSelectedUpgrades;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00746240
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.ClientReceiveBoostPurchaseResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
	 * Parameters:
	 * 		class FName                                        purchasedBoostID                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isSuccessful                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::ClientReceiveBoostPurchaseResult(const class FName& purchasedBoostID, bool isSuccessful)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.ClientReceiveBoostPurchaseResult");
		
		AYPlayerController_Havoc_ClientReceiveBoostPurchaseResult_Params params {};
		params.purchasedBoostID = purchasedBoostID;
		params.isSuccessful = isSuccessful;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744080
	 * 		Name   -> Function DreadGame.YPlayerController_Havoc.ChangeShipNative
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      shipName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Havoc::ChangeShipNative(const class FString& shipName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Havoc.ChangeShipNative");
		
		AYPlayerController_Havoc_ChangeShipNative_Params params {};
		params.shipName = shipName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerController_Havoc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerController_Havoc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerController_Havoc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D3D0
	 * 		Name   -> Function DreadGame.YTerritoryVolume.GetAdjustedBoxExtent
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     adjExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYTerritoryVolume::GetAdjustedBoxExtent(struct FVector* Origin, struct FVector* adjExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YTerritoryVolume.GetAdjustedBoxExtent");
		
		AYTerritoryVolume_GetAdjustedBoxExtent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Origin != nullptr)
			*Origin = params.Origin;
		if (adjExtent != nullptr)
			*adjExtent = params.adjExtent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYTerritoryVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYTerritoryVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YTerritoryVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController_TER.OnTerritoryUITextureUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  currentTexture                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_TER::OnTerritoryUITextureUpdated(class UTexture2D* currentTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_TER.OnTerritoryUITextureUpdated");
		
		AYPlayerController_TER_OnTerritoryUITextureUpdated_Params params {};
		params.currentTexture = currentTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController_TER.OnTerritoryUITextureInitialized
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            minimapWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            minmapHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_TER::OnTerritoryUITextureInitialized(int32_t minimapWidth, int32_t minmapHeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_TER.OnTerritoryUITextureInitialized");
		
		AYPlayerController_TER_OnTerritoryUITextureInitialized_Params params {};
		params.minimapWidth = minimapWidth;
		params.minmapHeight = minmapHeight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A410
	 * 		Name   -> Function DreadGame.YPlayerController_TER.OnSetEnemySpotted
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      targetedPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_TER::OnSetEnemySpotted(class AYPawn* targetedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_TER.OnSetEnemySpotted");
		
		AYPlayerController_TER_OnSetEnemySpotted_Params params {};
		params.targetedPawn = targetedPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DA20
	 * 		Name   -> Function DreadGame.YPlayerController_TER.InitializeUITexture
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void AYPlayerController_TER::InitializeUITexture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_TER.InitializeUITexture");
		
		AYPlayerController_TER_InitializeUITexture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743F10
	 * 		Name   -> Function DreadGame.YPlayerController_TER.CapturePointOwnerChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CPIdx                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_TER::CapturePointOwnerChanged(EYTeam Team, int32_t CPIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_TER.CapturePointOwnerChanged");
		
		AYPlayerController_TER_CapturePointOwnerChanged_Params params {};
		params.Team = Team;
		params.CPIdx = CPIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerController_TER.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerController_TER::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerController_TER");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FCD0
	 * 		Name   -> Function DreadGame.YPlayerController_Tutorial.StartMatch
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AYPlayerController_Tutorial::StartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Tutorial.StartMatch");
		
		AYPlayerController_Tutorial_StartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007701F0
	 * 		Name   -> Function DreadGame.YPlayerController_Tutorial.ReturnToOutpost
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController_Tutorial::ReturnToOutpost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Tutorial.ReturnToOutpost");
		
		AYPlayerController_Tutorial_ReturnToOutpost_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FE30
	 * 		Name   -> Function DreadGame.YPlayerController_Tutorial.RestartAtLevelStart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController_Tutorial::RestartAtLevelStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Tutorial.RestartAtLevelStart");
		
		AYPlayerController_Tutorial_RestartAtLevelStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FE10
	 * 		Name   -> Function DreadGame.YPlayerController_Tutorial.RestartAtCheckpoint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerController_Tutorial::RestartAtCheckpoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Tutorial.RestartAtCheckpoint");
		
		AYPlayerController_Tutorial_RestartAtCheckpoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPlayerController_Tutorial.OnPrepareLevelChange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        levelToOpen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerController_Tutorial::OnPrepareLevelChange(const class FName& levelToOpen, float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerController_Tutorial.OnPrepareLevelChange");
		
		AYPlayerController_Tutorial_OnPrepareLevelChange_Params params {};
		params.levelToOpen = levelToOpen;
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerController_Tutorial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerController_Tutorial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerController_Tutorial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerInputSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerInputSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerInputSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerInput.ToggleGamepadInfo
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UYPlayerInput::ToggleGamepadInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.ToggleGamepadInfo");
		
		UYPlayerInput_ToggleGamepadInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777DE0
	 * 		Name   -> Function DreadGame.YPlayerInput.SetGamepadSensitivityToDefault
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UYPlayerInput::SetGamepadSensitivityToDefault()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.SetGamepadSensitivityToDefault");
		
		UYPlayerInput_SetGamepadSensitivityToDefault_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777D20
	 * 		Name   -> Function DreadGame.YPlayerInput.SetGamepadSensitivity
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              sensitivityX                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              sensitivityY                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerInput::SetGamepadSensitivity(float sensitivityX, float sensitivityY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.SetGamepadSensitivity");
		
		UYPlayerInput_SetGamepadSensitivity_Params params {};
		params.sensitivityX = sensitivityX;
		params.sensitivityY = sensitivityY;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777CA0
	 * 		Name   -> Function DreadGame.YPlayerInput.SetGamepadLayout
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerInput::SetGamepadLayout(int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.SetGamepadLayout");
		
		UYPlayerInput_SetGamepadLayout_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FC30
	 * 		Name   -> Function DreadGame.YPlayerInput.ResetLastPlayerInputTime
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerInput::ResetLastPlayerInputTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.ResetLastPlayerInputTime");
		
		UYPlayerInput_ResetLastPlayerInputTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FC10
	 * 		Name   -> Function DreadGame.YPlayerInput.ResetGamepadLayout
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerInput::ResetGamepadLayout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.ResetGamepadLayout");
		
		UYPlayerInput_ResetGamepadLayout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YPlayerInput.ReloadInputConfig
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UYPlayerInput::ReloadInputConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.ReloadInputConfig");
		
		UYPlayerInput_ReloadInputConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerInput.OnKeyMappingResetToDefault__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FInputAxisKeyMapping>                axesCofigs                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FInputActionKeyMapping>              actionConfigs                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYPlayerInput::OnKeyMappingResetToDefault__DelegateSignature(TArray<struct FInputAxisKeyMapping> axesCofigs, TArray<struct FInputActionKeyMapping> actionConfigs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerInput.OnKeyMappingResetToDefault__DelegateSignature");
		
		UYPlayerInput_OnKeyMappingResetToDefault__DelegateSignature_Params params {};
		params.axesCofigs = axesCofigs;
		params.actionConfigs = actionConfigs;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerInput.OnKeyMappingChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isKeyboardKey                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               isMouseButton                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               isGamepadKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYPlayerInput::OnKeyMappingChanged__DelegateSignature(const class FName& EventName, bool isKeyboardKey, bool isMouseButton, bool isGamepadKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerInput.OnKeyMappingChanged__DelegateSignature");
		
		UYPlayerInput_OnKeyMappingChanged__DelegateSignature_Params params {};
		params.EventName = EventName;
		params.isKeyboardKey = isKeyboardKey;
		params.isMouseButton = isMouseButton;
		params.isGamepadKey = isGamepadKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763530
	 * 		Name   -> Function DreadGame.YPlayerInput.OnControllerConnectionChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               connected                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            userId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            userIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerInput::OnControllerConnectionChanged(bool connected, int32_t userId, int32_t userIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.OnControllerConnectionChanged");
		
		UYPlayerInput_OnControllerConnectionChanged_Params params {};
		params.connected = connected;
		params.userId = userId;
		params.userIndex = userIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750820
	 * 		Name   -> Function DreadGame.YPlayerInput.GetCurrentKeyForInputEvent
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYInputDevice                                      InputDevice                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYPlayerInput::GetCurrentKeyForInputEvent(struct FKey* Key, const class FName& EventName, EYInputDevice InputDevice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.GetCurrentKeyForInputEvent");
		
		UYPlayerInput_GetCurrentKeyForInputEvent_Params params {};
		params.EventName = EventName;
		params.InputDevice = InputDevice;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Key != nullptr)
			*Key = params.Key;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007506B0
	 * 		Name   -> Function DreadGame.YPlayerInput.GetCurrentGamepadSensitivity
	 * 		Flags  -> (Final, Exec, Native, Public, HasOutParms)
	 * Parameters:
	 * 		float                                              sensitivityX                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              sensitivityY                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerInput::GetCurrentGamepadSensitivity(float* sensitivityX, float* sensitivityY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.GetCurrentGamepadSensitivity");
		
		UYPlayerInput_GetCurrentGamepadSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (sensitivityX != nullptr)
			*sensitivityX = params.sensitivityX;
		if (sensitivityY != nullptr)
			*sensitivityY = params.sensitivityY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750310
	 * 		Name   -> Function DreadGame.YPlayerInput.GetControllerConfigIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYPlayerInput::GetControllerConfigIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.GetControllerConfigIndex");
		
		UYPlayerInput_GetControllerConfigIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B350
	 * 		Name   -> Function DreadGame.YPlayerInput.DumpInputEventMappings
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UYPlayerInput::DumpInputEventMappings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerInput.DumpInputEventMappings");
		
		UYPlayerInput_DumpInputEventMappings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerInput.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerInput::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerInput");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerMatchStatisticsManager_TEST.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerMatchStatisticsManager_TEST::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerMatchStatisticsManager_TEST");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781810
	 * 		Name   -> Function DreadGame.YPlayerOrbitComponent.TravelBackToOutpost
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerOrbitComponent::TravelBackToOutpost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerOrbitComponent.TravelBackToOutpost");
		
		UYPlayerOrbitComponent_TravelBackToOutpost_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00773710
	 * 		Name   -> Function DreadGame.YPlayerOrbitComponent.ServerSetRunningSoaktest
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void UYPlayerOrbitComponent::ServerSetRunningSoaktest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerOrbitComponent.ServerSetRunningSoaktest");
		
		UYPlayerOrbitComponent_ServerSetRunningSoaktest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C980
	 * 		Name   -> Function DreadGame.YPlayerOrbitComponent.OrbitTransitionCameraPan
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYPlayerOrbitComponent::OrbitTransitionCameraPan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerOrbitComponent.OrbitTransitionCameraPan");
		
		UYPlayerOrbitComponent_OrbitTransitionCameraPan_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C960
	 * 		Name   -> Function DreadGame.YPlayerOrbitComponent.OrbitTeleportingSequenceEnds
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYPlayerOrbitComponent::OrbitTeleportingSequenceEnds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerOrbitComponent.OrbitTeleportingSequenceEnds");
		
		UYPlayerOrbitComponent_OrbitTeleportingSequenceEnds_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769140
	 * 		Name   -> Function DreadGame.YPlayerOrbitComponent.OnRep_StartingSpot
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYPlayerOrbitComponent::OnRep_StartingSpot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerOrbitComponent.OnRep_StartingSpot");
		
		UYPlayerOrbitComponent_OnRep_StartingSpot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C960
	 * 		Name   -> Function DreadGame.YPlayerOrbitComponent.ClientStartEndOfMatchTransition
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void UYPlayerOrbitComponent::ClientStartEndOfMatchTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerOrbitComponent.ClientStartEndOfMatchTransition");
		
		UYPlayerOrbitComponent_ClientStartEndOfMatchTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00743CB0
	 * 		Name   -> Function DreadGame.YPlayerOrbitComponent.CameraPanAnimationFinished
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYPlayerOrbitComponent::CameraPanAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerOrbitComponent.CameraPanAnimationFinished");
		
		UYPlayerOrbitComponent_CameraPanAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerOrbitComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerOrbitComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerOrbitComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventManager_Horde.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventManager_Horde::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventManager_Horde");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768F20
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_PvE.OnRep_PveRewardsData
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo_PvE::OnRep_PveRewardsData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_PvE.OnRep_PveRewardsData");
		
		AYPlayerReplicationInfo_PvE_OnRep_PveRewardsData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerReplicationInfo_PvE.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerReplicationInfo_PvE::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerReplicationInfo_PvE");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782DA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.UnReadyForNextWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerReplicationInfo_Havoc::UnReadyForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.UnReadyForNextWave");
		
		AYPlayerReplicationInfo_Havoc_UnReadyForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E660
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.ReadyUpForNextWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYPlayerReplicationInfo_Havoc::ReadyUpForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.ReadyUpForNextWave");
		
		AYPlayerReplicationInfo_Havoc_ReadyUpForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769340
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.OnRep_XPChanged
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo_Havoc::OnRep_XPChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.OnRep_XPChanged");
		
		AYPlayerReplicationInfo_Havoc_OnRep_XPChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768F40
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.OnRep_ReadyForNextWaveChanged
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AYPlayerReplicationInfo_Havoc::OnRep_ReadyForNextWaveChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.OnRep_ReadyForNextWaveChanged");
		
		AYPlayerReplicationInfo_Havoc_OnRep_ReadyForNextWaveChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YPlayerReplicationInfo_Havoc.OnClientHighscoreAvailable__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AYPlayerReplicationInfo_Havoc::OnClientHighscoreAvailable__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YPlayerReplicationInfo_Havoc.OnClientHighscoreAvailable__DelegateSignature");
		
		AYPlayerReplicationInfo_Havoc_OnClientHighscoreAvailable__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F740
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.IsReadyForNextWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AYPlayerReplicationInfo_Havoc::IsReadyForNextWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.IsReadyForNextWave");
		
		AYPlayerReplicationInfo_Havoc_IsReadyForNextWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757040
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.GetPlayerXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYPlayerReplicationInfo_Havoc::GetPlayerXP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.GetPlayerXP");
		
		AYPlayerReplicationInfo_Havoc_GetPlayerXP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752F40
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.GetKillsLastWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYPlayerReplicationInfo_Havoc::GetKillsLastWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.GetKillsLastWave");
		
		AYPlayerReplicationInfo_Havoc_GetKillsLastWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751440
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.GetDeathsLastWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYPlayerReplicationInfo_Havoc::GetDeathsLastWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.GetDeathsLastWave");
		
		AYPlayerReplicationInfo_Havoc_GetDeathsLastWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007502B0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.GetContributedXPLastWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYPlayerReplicationInfo_Havoc::GetContributedXPLastWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.GetContributedXPLastWave");
		
		AYPlayerReplicationInfo_Havoc_GetContributedXPLastWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750290
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.GetContributedXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYPlayerReplicationInfo_Havoc::GetContributedXP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.GetContributedXP");
		
		AYPlayerReplicationInfo_Havoc_GetContributedXP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074D8C0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.GetAssitsLastWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AYPlayerReplicationInfo_Havoc::GetAssitsLastWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.GetAssitsLastWave");
		
		AYPlayerReplicationInfo_Havoc_GetAssitsLastWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A530
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.DeductXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            xp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo_Havoc::DeductXP(int32_t xp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.DeductXP");
		
		AYPlayerReplicationInfo_Havoc_DeductXP_Params params {};
		params.xp = xp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747D80
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.ClientUpdateWeeklyScoreResetTime
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient, NetValidate)
	 * Parameters:
	 * 		int64_t                                            weeklyScoreResetTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo_Havoc::ClientUpdateWeeklyScoreResetTime(int64_t weeklyScoreResetTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.ClientUpdateWeeklyScoreResetTime");
		
		AYPlayerReplicationInfo_Havoc_ClientUpdateWeeklyScoreResetTime_Params params {};
		params.weeklyScoreResetTime = weeklyScoreResetTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00747AA0
	 * 		Name   -> Function DreadGame.YPlayerReplicationInfo_Havoc.ClientUpdateHighscore
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		int32_t                                            matchScore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            weeklyPlayerScore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            lifetimePlayerScore                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPlayerReplicationInfo_Havoc::ClientUpdateHighscore(int32_t matchScore, int32_t weeklyPlayerScore, int32_t lifetimePlayerScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerReplicationInfo_Havoc.ClientUpdateHighscore");
		
		AYPlayerReplicationInfo_Havoc_ClientUpdateHighscore_Params params {};
		params.matchScore = matchScore;
		params.weeklyPlayerScore = weeklyPlayerScore;
		params.lifetimePlayerScore = lifetimePlayerScore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerReplicationInfo_Havoc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerReplicationInfo_Havoc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerReplicationInfo_Havoc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780A90
	 * 		Name   -> Function DreadGame.YPlayerSpectatorComponent.SwitchToSpectatorCamera
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYPlayerSpectatorComponent::SwitchToSpectatorCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerSpectatorComponent.SwitchToSpectatorCamera");
		
		UYPlayerSpectatorComponent_SwitchToSpectatorCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007804E0
	 * 		Name   -> Function DreadGame.YPlayerSpectatorComponent.StopSpectatingSpecificPawn
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      DestroyedActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYPlayerSpectatorComponent::StopSpectatingSpecificPawn(class AActor* DestroyedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerSpectatorComponent.StopSpectatingSpecificPawn");
		
		UYPlayerSpectatorComponent_StopSpectatingSpecificPawn_Params params {};
		params.DestroyedActor = DestroyedActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076ABA0
	 * 		Name   -> Function DreadGame.YPlayerSpectatorComponent.OnStopSpectateSpecificPawn
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYPlayerSpectatorComponent::OnStopSpectateSpecificPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerSpectatorComponent.OnStopSpectateSpecificPawn");
		
		UYPlayerSpectatorComponent_OnStopSpectateSpecificPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DAC0
	 * 		Name   -> Function DreadGame.YPlayerSpectatorComponent.InitiatePlayerSpectatorCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYPlayerSpectatorComponent::InitiatePlayerSpectatorCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerSpectatorComponent.InitiatePlayerSpectatorCamera");
		
		UYPlayerSpectatorComponent_InitiatePlayerSpectatorCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C960
	 * 		Name   -> Function DreadGame.YPlayerSpectatorComponent.EndClientSpectating
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UYPlayerSpectatorComponent::EndClientSpectating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerSpectatorComponent.EndClientSpectating");
		
		UYPlayerSpectatorComponent_EndClientSpectating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayerSpectatorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayerSpectatorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerSpectatorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYPlayersRatingManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYPlayersRatingManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayersRatingManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756ED0
	 * 		Name   -> Function DreadGame.YPlayerStartHomeBase.GetPlayerStartTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	EYTeam AYPlayerStartHomeBase::GetPlayerStartTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPlayerStartHomeBase.GetPlayerStartTeam");
		
		AYPlayerStartHomeBase_GetPlayerStartTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPlayerStartHomeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPlayerStartHomeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPlayerStartHomeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProgressionManagerBattleServer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProgressionManagerBattleServer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProgressionManagerBattleServer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProgressionUnlockContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProgressionUnlockContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProgressionUnlockContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProgressionUnlockContainerBlank.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProgressionUnlockContainerBlank::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProgressionUnlockContainerBlank");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProgressionUnlockContainerCurrency.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProgressionUnlockContainerCurrency::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProgressionUnlockContainerCurrency");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProgressionUnlockContainerFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProgressionUnlockContainerFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProgressionUnlockContainerFunction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007572B0
	 * 		Name   -> Function DreadGame.YProjectileBallistic.GetProjectileOfflineData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYProjectileBallisticOfflineDataTableRow AYProjectileBallistic::GetProjectileOfflineData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileBallistic.GetProjectileOfflineData");
		
		AYProjectileBallistic_GetProjectileOfflineData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYProjectileBallistic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYProjectileBallistic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectileBallistic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780580
	 * 		Name   -> Function DreadGame.YProjectileMissile.StopThrusters
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYProjectileMissile::StopThrusters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.StopThrusters");
		
		AYProjectileMissile_StopThrusters_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780560
	 * 		Name   -> Function DreadGame.YProjectileMissile.StopSteering
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYProjectileMissile::StopSteering()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.StopSteering");
		
		AYProjectileMissile_StopSteering_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B5C0
	 * 		Name   -> Function DreadGame.YProjectileMissile.SetTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYPawn*                                      newTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYProjectileMissile::SetTarget(class AYPawn* newTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.SetTarget");
		
		AYProjectileMissile_SetTarget_Params params {};
		params.newTarget = newTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileMissile.OnThrustersStopped
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectileMissile::OnThrustersStopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.OnThrustersStopped");
		
		AYProjectileMissile_OnThrustersStopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileMissile.OnThrustersStarted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectileMissile::OnThrustersStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.OnThrustersStarted");
		
		AYProjectileMissile_OnThrustersStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileMissile.OnSteeringStopped
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectileMissile::OnSteeringStopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.OnSteeringStopped");
		
		AYProjectileMissile_OnSteeringStopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileMissile.OnSteeringActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectileMissile::OnSteeringActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.OnSteeringActivated");
		
		AYProjectileMissile_OnSteeringActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileMissile.OnInitialRotationActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectileMissile::OnInitialRotationActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.OnInitialRotationActivated");
		
		AYProjectileMissile_OnInitialRotationActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileMissile.OnDragActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYProjectileMissile::OnDragActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.OnDragActivated");
		
		AYProjectileMissile_OnDragActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759600
	 * 		Name   -> Function DreadGame.YProjectileMissile.GetTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AYPawn* AYProjectileMissile::GetTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.GetTarget");
		
		AYProjectileMissile_GetTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007572F0
	 * 		Name   -> Function DreadGame.YProjectileMissile.GetProjectileOfflineData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FYProjectileMissileOfflineDataTableRow AYProjectileMissile::GetProjectileOfflineData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.GetProjectileOfflineData");
		
		AYProjectileMissile_GetProjectileOfflineData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C300
	 * 		Name   -> Function DreadGame.YProjectileMissile.FindTargetTransform
	 * 		Flags  -> (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform AYProjectileMissile::FindTargetTransform(class AYPawn* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.FindTargetTransform");
		
		AYProjectileMissile_FindTargetTransform_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C210
	 * 		Name   -> Function DreadGame.YProjectileMissile.FindTargetLocation
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AYPawn*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     actorLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FVector AYProjectileMissile::FindTargetLocation(class AYPawn* Target, const struct FVector& actorLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.FindTargetLocation");
		
		AYProjectileMissile_FindTargetLocation_Params params {};
		params.Target = Target;
		params.actorLocation = actorLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BF40
	 * 		Name   -> Function DreadGame.YProjectileMissile.FindCloseInScalingValue
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     locationTowardsExtent                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float AYProjectileMissile::FindCloseInScalingValue(const struct FVector& locationTowardsExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileMissile.FindCloseInScalingValue");
		
		AYProjectileMissile_FindCloseInScalingValue_Params params {};
		params.locationTowardsExtent = locationTowardsExtent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYProjectileMissile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYProjectileMissile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectileMissile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProjectileContentReferenceTracker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProjectileContentReferenceTracker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectileContentReferenceTracker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProjectileInstanceInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProjectileInstanceInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectileInstanceInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007614E0
	 * 		Name   -> Function DreadGame.YProjectileReplicator.MulticastProjectileExplosionDataProximityDistanceReached
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FYProjectileExplosionDataMinimal>    newExplosionData                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYProjectileReplicator::MulticastProjectileExplosionDataProximityDistanceReached(TArray<struct FYProjectileExplosionDataMinimal> newExplosionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileReplicator.MulticastProjectileExplosionDataProximityDistanceReached");
		
		UYProjectileReplicator_MulticastProjectileExplosionDataProximityDistanceReached_Params params {};
		params.newExplosionData = newExplosionData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761440
	 * 		Name   -> Function DreadGame.YProjectileReplicator.MulticastProjectileExplosionDataMaxDistanceReached
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FYProjectileExplosionDataMinimal>    newExplosionData                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYProjectileReplicator::MulticastProjectileExplosionDataMaxDistanceReached(TArray<struct FYProjectileExplosionDataMinimal> newExplosionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileReplicator.MulticastProjectileExplosionDataMaxDistanceReached");
		
		UYProjectileReplicator_MulticastProjectileExplosionDataMaxDistanceReached_Params params {};
		params.newExplosionData = newExplosionData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007613A0
	 * 		Name   -> Function DreadGame.YProjectileReplicator.MulticastProjectileDestroyedOnServer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FYProjectileDestroyedOnServerData>   newImpactData                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYProjectileReplicator::MulticastProjectileDestroyedOnServer(TArray<struct FYProjectileDestroyedOnServerData> newImpactData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileReplicator.MulticastProjectileDestroyedOnServer");
		
		UYProjectileReplicator_MulticastProjectileDestroyedOnServer_Params params {};
		params.newImpactData = newImpactData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00761270
	 * 		Name   -> Function DreadGame.YProjectileReplicator.MulticastMissileSteeringData
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FYMissileSteeringData>               newSteeringData                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYProjectileReplicator::MulticastMissileSteeringData(TArray<struct FYMissileSteeringData> newSteeringData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileReplicator.MulticastMissileSteeringData");
		
		UYProjectileReplicator_MulticastMissileSteeringData_Params params {};
		params.newSteeringData = newSteeringData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProjectileReplicator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProjectileReplicator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectileReplicator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYProjectileTracking.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYProjectileTracking::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectileTracking");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPVEEventManager.OnPVEModeStarted
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 */
	void AYPVEEventManager::OnPVEModeStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPVEEventManager.OnPVEModeStarted");
		
		AYPVEEventManager_OnPVEModeStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPVEEventManager.OnPlayerSpawnedInArena
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      playerPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPVEEventManager::OnPlayerSpawnedInArena(class AYPawn* playerPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPVEEventManager.OnPlayerSpawnedInArena");
		
		AYPVEEventManager_OnPlayerSpawnedInArena_Params params {};
		params.playerPawn = playerPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YPVEEventManager.OnEnemyNPCKilled
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AYPawn*                                      KilledYPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            KilledNPCID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYPVEEventManager::OnEnemyNPCKilled(class AYPawn* KilledYPawn, int32_t KilledNPCID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPVEEventManager.OnEnemyNPCKilled");
		
		AYPVEEventManager_OnEnemyNPCKilled_Params params {};
		params.KilledYPawn = KilledYPawn;
		params.KilledNPCID = KilledNPCID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D7A0
	 * 		Name   -> Function DreadGame.YPVEEventManager.InitializePVEDifficulty
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AYPVEEventManager::InitializePVEDifficulty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YPVEEventManager.InitializePVEDifficulty");
		
		AYPVEEventManager_InitializePVEDifficulty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYPVEEventManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYPVEEventManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YPVEEventManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYDestroyEventManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYDestroyEventManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YDestroyEventManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHordeEventManager.OnWaveStateChanged
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYHordeWaveState                                   waveState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            waveIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYHordeEventManager::OnWaveStateChanged(EYHordeWaveState waveState, int32_t waveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHordeEventManager.OnWaveStateChanged");
		
		AYHordeEventManager_OnWaveStateChanged_Params params {};
		params.waveState = waveState;
		params.waveIndex = waveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755300
	 * 		Name   -> Function DreadGame.YHordeEventManager.GetNumberOfWaveEnemies
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	int32_t AYHordeEventManager::GetNumberOfWaveEnemies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHordeEventManager.GetNumberOfWaveEnemies");
		
		AYHordeEventManager_GetNumberOfWaveEnemies_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754070
	 * 		Name   -> Function DreadGame.YHordeEventManager.GetMaxNumberOfWaves
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	int32_t AYHordeEventManager::GetMaxNumberOfWaves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHordeEventManager.GetMaxNumberOfWaves");
		
		AYHordeEventManager_GetMaxNumberOfWaves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYHordeEventManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYHordeEventManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHordeEventManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F320
	 * 		Name   -> Function DreadGame.YReplacementTemplateActor.SpawnReplacementStaticMeshActor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UStaticMesh*                                 usedMesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStaticMeshComponent*                        SourceComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      worldContextActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AStaticMeshActor* AYReplacementTemplateActor::SpawnReplacementStaticMeshActor(const struct FTransform& Transform, class UStaticMesh* usedMesh, class UStaticMeshComponent* SourceComponent, class AActor* worldContextActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YReplacementTemplateActor.SpawnReplacementStaticMeshActor");
		
		AYReplacementTemplateActor_SpawnReplacementStaticMeshActor_Params params {};
		params.Transform = Transform;
		params.usedMesh = usedMesh;
		params.SourceComponent = SourceComponent;
		params.worldContextActor = worldContextActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYReplacementTemplateActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYReplacementTemplateActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YReplacementTemplateActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768FA0
	 * 		Name   -> Function DreadGame.YReputationManager.OnRep_Reputation
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYReputationManager::OnRep_Reputation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YReputationManager.OnRep_Reputation");
		
		UYReputationManager_OnRep_Reputation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YReputationManager.OnPlayerReputationChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPlayerReplicationInfo*                     owningPRI                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            newReputation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYReputationManager::OnPlayerReputationChanged__DelegateSignature(class AYPlayerReplicationInfo* owningPRI, int32_t newReputation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YReputationManager.OnPlayerReputationChanged__DelegateSignature");
		
		UYReputationManager_OnPlayerReputationChanged__DelegateSignature_Params params {};
		params.owningPRI = owningPRI;
		params.newReputation = newReputation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D2D0
	 * 		Name   -> Function DreadGame.YReputationManager.Initialize
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYReputationManager::Initialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YReputationManager.Initialize");
		
		UYReputationManager_Initialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYReputationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYReputationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YReputationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C040
	 * 		Name   -> Function DreadGame.YRichTextBlock.SetText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InText                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	void UYRichTextBlock::SetText(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YRichTextBlock.SetText");
		
		UYRichTextBlock_SetText_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYRichTextBlock.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYRichTextBlock::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YRichTextBlock");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSaveGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSaveGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSaveGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00744AF0
	 * 		Name   -> Function DreadGame.YScoringEventComponent.ClientAddAchievement
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FYScoringAchievement                        achievement                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYScoringEventComponent::ClientAddAchievement(const struct FYScoringAchievement& achievement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YScoringEventComponent.ClientAddAchievement");
		
		UYScoringEventComponent_ClientAddAchievement_Params params {};
		params.achievement = achievement;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventManager_Escort.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventManager_Escort::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventManager_Escort");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventManager_Havoc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventManager_Havoc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventManager_Havoc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventManager_MP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventManager_MP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventManager_MP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventManager_Invasion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventManager_Invasion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventManager_Invasion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYScoringEventManager_Territory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYScoringEventManager_Territory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YScoringEventManager_Territory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSeasonsDataManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSeasonsDataManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSeasonsDataManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSeasonsPlayerDataManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSeasonsPlayerDataManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSeasonsPlayerDataManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSeasonsDataManager_TEST.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSeasonsDataManager_TEST::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSeasonsDataManager_TEST");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007842F0
	 * 		Name   -> Function DreadGame.YShipCustomizationPreview.UpdateWeaponPreview
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AYWeapon*                                    weaponObj                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYShipCustomizationPreview::UpdateWeaponPreview(class AYWeapon* weaponObj)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationPreview.UpdateWeaponPreview");
		
		AYShipCustomizationPreview_UpdateWeaponPreview_Params params {};
		params.weaponObj = weaponObj;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783440
	 * 		Name   -> Function DreadGame.YShipCustomizationPreview.UpdateFromLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYShipLoadout*                               loadout                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               renderThumbnail                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYShipCustomizationPreview::UpdateFromLoadout(class UYShipLoadout* loadout, bool renderThumbnail)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationPreview.UpdateFromLoadout");
		
		AYShipCustomizationPreview_UpdateFromLoadout_Params params {};
		params.loadout = loadout;
		params.renderThumbnail = renderThumbnail;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783200
	 * 		Name   -> Function DreadGame.YShipCustomizationPreview.UpdateDisplayInfoString
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UObject*                                     changedObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYShipCustomizationPreview::UpdateDisplayInfoString(class UObject* changedObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationPreview.UpdateDisplayInfoString");
		
		AYShipCustomizationPreview_UpdateDisplayInfoString_Params params {};
		params.changedObject = changedObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782EE0
	 * 		Name   -> Function DreadGame.YShipCustomizationPreview.UpdateAbilityPreview
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UYAbility*                                   abilityObj                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYShipCustomizationPreview::UpdateAbilityPreview(class UYAbility* abilityObj)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationPreview.UpdateAbilityPreview");
		
		AYShipCustomizationPreview_UpdateAbilityPreview_Params params {};
		params.abilityObj = abilityObj;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YShipCustomizationPreview.OnShipCustomizationPreviewUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UObject*                                     changedObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYShipCustomizationPreview::OnShipCustomizationPreviewUpdated__DelegateSignature(class UObject* changedObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YShipCustomizationPreview.OnShipCustomizationPreviewUpdated__DelegateSignature");
		
		AYShipCustomizationPreview_OnShipCustomizationPreviewUpdated__DelegateSignature_Params params {};
		params.changedObject = changedObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075CEE0
	 * 		Name   -> Function DreadGame.YShipCustomizationPreview.InitForRendering
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      creatingActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYShipCustomizationPreview::InitForRendering(class AActor* creatingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationPreview.InitForRendering");
		
		AYShipCustomizationPreview_InitForRendering_Params params {};
		params.creatingActor = creatingActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750F50
	 * 		Name   -> Function DreadGame.YShipCustomizationPreview.GetCustomizationComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UYShipCustomizationComponent* AYShipCustomizationPreview::GetCustomizationComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationPreview.GetCustomizationComponent");
		
		AYShipCustomizationPreview_GetCustomizationComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074E0A0
	 * 		Name   -> Function DreadGame.YShipCustomizationPreview.GetCameraComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UCameraComponent* AYShipCustomizationPreview::GetCameraComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipCustomizationPreview.GetCameraComponent");
		
		AYShipCustomizationPreview_GetCameraComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYShipCustomizationPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYShipCustomizationPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipCustomizationPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYNPCPawnEditor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYNPCPawnEditor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YNPCPawnEditor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077F9B0
	 * 		Name   -> Function DreadGame.YShipDebrisActor.StartDebrisMovement
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    targetRotationRate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYShipDebrisActor::StartDebrisMovement(const struct FVector& Velocity, const struct FRotator& targetRotationRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipDebrisActor.StartDebrisMovement");
		
		AYShipDebrisActor_StartDebrisMovement_Params params {};
		params.Velocity = Velocity;
		params.targetRotationRate = targetRotationRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D350
	 * 		Name   -> Function DreadGame.YShipDebrisActor.InitializeDebris
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYShipDebrisInitializationData              shipDebrisInitializationData                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AYShipDebrisActor::InitializeDebris(const struct FYShipDebrisInitializationData& shipDebrisInitializationData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipDebrisActor.InitializeDebris");
		
		AYShipDebrisActor_InitializeDebris_Params params {};
		params.shipDebrisInitializationData = shipDebrisInitializationData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYShipDebrisActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYShipDebrisActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipDebrisActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityEmblem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityEmblem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityEmblem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYShipEmblemPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYShipEmblemPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipEmblemPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipLoadoutMmogbrain.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipLoadoutMmogbrain::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipLoadoutMmogbrain");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipLoadoutHero.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipLoadoutHero::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipLoadoutHero");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipLoadoutPrecast.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipLoadoutPrecast::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipLoadoutPrecast");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityColorSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityColorSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityColorSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityDecal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityDecal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityDecal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityDirtSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityDirtSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityDirtSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityPaint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityPaint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityPaint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityPattern.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityPattern::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityPattern");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760DD0
	 * 		Name   -> Function DreadGame.YShipVanityLibrary.MergeShipMeshParts
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      shipMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UYShipVanityMeshPart*>                meshParts                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               enqueue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipVanityLibrary::STATIC_MergeShipMeshParts(class USkeletalMeshComponent* shipMeshComponent, TArray<class UYShipVanityMeshPart*> meshParts, bool enqueue, class UObject* context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipVanityLibrary.MergeShipMeshParts");
		
		UYShipVanityLibrary_MergeShipMeshParts_Params params {};
		params.shipMeshComponent = shipMeshComponent;
		params.meshParts = meshParts;
		params.enqueue = enqueue;
		params.context = context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741DB0
	 * 		Name   -> Function DreadGame.YShipVanityLibrary.AttachEmblemMesh
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      targetMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStaticMeshComponent*                        emblemMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYShipVanityEmblem*                          emblem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipVanityLibrary::STATIC_AttachEmblemMesh(class USkeletalMeshComponent* targetMeshComponent, class UStaticMeshComponent* emblemMeshComponent, class UYShipVanityEmblem* emblem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipVanityLibrary.AttachEmblemMesh");
		
		UYShipVanityLibrary_AttachEmblemMesh_Params params {};
		params.targetMeshComponent = targetMeshComponent;
		params.emblemMeshComponent = emblemMeshComponent;
		params.emblem = emblem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741400
	 * 		Name   -> Function DreadGame.YShipVanityLibrary.ApplyPattern
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      shipMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYShipVanityPattern*                         Pattern                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipVanityLibrary::STATIC_ApplyPattern(class USkeletalMeshComponent* shipMeshComponent, class UYShipVanityPattern* Pattern)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipVanityLibrary.ApplyPattern");
		
		UYShipVanityLibrary_ApplyPattern_Params params {};
		params.shipMeshComponent = shipMeshComponent;
		params.Pattern = Pattern;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741350
	 * 		Name   -> Function DreadGame.YShipVanityLibrary.ApplyPaint
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      shipMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYShipVanityPaint*                           paint                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipVanityLibrary::STATIC_ApplyPaint(class USkeletalMeshComponent* shipMeshComponent, class UYShipVanityPaint* paint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipVanityLibrary.ApplyPaint");
		
		UYShipVanityLibrary_ApplyPaint_Params params {};
		params.shipMeshComponent = shipMeshComponent;
		params.paint = paint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741100
	 * 		Name   -> Function DreadGame.YShipVanityLibrary.ApplyDecal
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      shipMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYShipVanityDecal*                           decal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShipVanityLibrary::STATIC_ApplyDecal(class USkeletalMeshComponent* shipMeshComponent, class UYShipVanityDecal* decal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShipVanityLibrary.ApplyDecal");
		
		UYShipVanityLibrary_ApplyDecal_Params params {};
		params.shipMeshComponent = shipMeshComponent;
		params.decal = decal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShipVanityLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShipVanityLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShipVanityLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D140
	 * 		Name   -> Function DreadGame.YShop.ShopCatalogUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYShop::ShopCatalogUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShop.ShopCatalogUpdated");
		
		UYShop_ShopCatalogUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767C90
	 * 		Name   -> Function DreadGame.YShop.OnPlayerInventoryUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYShop::OnPlayerInventoryUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShop.OnPlayerInventoryUpdated");
		
		UYShop_OnPlayerInventoryUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00765C60
	 * 		Name   -> Function DreadGame.YShop.OnOfferPurchaseResult
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      offerId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            quantity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYShop::OnOfferPurchaseResult(int32_t Result, const class FString& offerId, int32_t quantity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YShop.OnOfferPurchaseResult");
		
		UYShop_OnOfferPurchaseResult_Params params {};
		params.Result = Result;
		params.offerId = offerId;
		params.quantity = quantity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYShop.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYShop::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YShop");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSoakTestFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSoakTestFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSoakTestFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSoundCueManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSoundCueManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSoundCueManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYSpawnManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYSpawnManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSpawnManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYSpectatorCamActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYSpectatorCamActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSpectatorCamActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYStackDumper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYStackDumper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YStackDumper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYStagedTrainingObjectiveBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYStagedTrainingObjectiveBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YStagedTrainingObjectiveBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E6FF90
	 * 		Name   -> Function DreadGame.YSTObjectiveOpenHelpScreen.PlayerOpenedHelpScreen
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYSTObjectiveOpenHelpScreen::PlayerOpenedHelpScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSTObjectiveOpenHelpScreen.PlayerOpenedHelpScreen");
		
		UYSTObjectiveOpenHelpScreen_PlayerOpenedHelpScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSTObjectiveOpenHelpScreen.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSTObjectiveOpenHelpScreen::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSTObjectiveOpenHelpScreen");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E6FF90
	 * 		Name   -> Function DreadGame.YSTObjectiveMoveToBattleZone.PlayerEnteredBattleZone
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYSTObjectiveMoveToBattleZone::PlayerEnteredBattleZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSTObjectiveMoveToBattleZone.PlayerEnteredBattleZone");
		
		UYSTObjectiveMoveToBattleZone_PlayerEnteredBattleZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSTObjectiveMoveToBattleZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSTObjectiveMoveToBattleZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSTObjectiveMoveToBattleZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007496D0
	 * 		Name   -> Function DreadGame.YSTObjectiveTargetHit.DamageTaken
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYWeapon*                                    Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYSTObjectiveTargetHit::DamageTaken(class AYPawn* targetPawn, class AYPawn* Instigator, class AYWeapon* Weapon, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSTObjectiveTargetHit.DamageTaken");
		
		UYSTObjectiveTargetHit_DamageTaken_Params params {};
		params.targetPawn = targetPawn;
		params.Instigator = Instigator;
		params.Weapon = Weapon;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSTObjectiveTargetHit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSTObjectiveTargetHit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSTObjectiveTargetHit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073C8E0
	 * 		Name   -> Function DreadGame.YSTObjectiveAbilityActivated.AbilityActivated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      firingPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYSTObjectiveAbilityActivated::AbilityActivated(class AYPawn* firingPawn, class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSTObjectiveAbilityActivated.AbilityActivated");
		
		UYSTObjectiveAbilityActivated_AbilityActivated_Params params {};
		params.firingPawn = firingPawn;
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSTObjectiveAbilityActivated.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSTObjectiveAbilityActivated::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSTObjectiveAbilityActivated");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749580
	 * 		Name   -> Function DreadGame.YSTObjectiveEnergyOnWeapons.DamageTaken
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYWeapon*                                    Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYSTObjectiveEnergyOnWeapons::DamageTaken(class AYPawn* targetPawn, class AYPawn* Instigator, class AYWeapon* Weapon, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSTObjectiveEnergyOnWeapons.DamageTaken");
		
		UYSTObjectiveEnergyOnWeapons_DamageTaken_Params params {};
		params.targetPawn = targetPawn;
		params.Instigator = Instigator;
		params.Weapon = Weapon;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSTObjectiveEnergyOnWeapons.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSTObjectiveEnergyOnWeapons::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSTObjectiveEnergyOnWeapons");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749430
	 * 		Name   -> Function DreadGame.YSTObjectiveEnergyOnShields.DamageTaken
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYWeapon*                                    Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYSTObjectiveEnergyOnShields::DamageTaken(class AYPawn* targetPawn, class AYPawn* Instigator, class AYWeapon* Weapon, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YSTObjectiveEnergyOnShields.DamageTaken");
		
		UYSTObjectiveEnergyOnShields_DamageTaken_Params params {};
		params.targetPawn = targetPawn;
		params.Instigator = Instigator;
		params.Weapon = Weapon;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSTObjectiveEnergyOnShields.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSTObjectiveEnergyOnShields::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSTObjectiveEnergyOnShields");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYSTObjectiveFinishMatch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYSTObjectiveFinishMatch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YSTObjectiveFinishMatch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784600
	 * 		Name   -> Function DreadGame.YStagedTrainingObjectiveManager.WeaponSpawned
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYStagedTrainingObjectiveManager::WeaponSpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YStagedTrainingObjectiveManager.WeaponSpawned");
		
		UYStagedTrainingObjectiveManager_WeaponSpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007845E0
	 * 		Name   -> Function DreadGame.YStagedTrainingObjectiveManager.WeaponFired
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYStagedTrainingObjectiveManager::WeaponFired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YStagedTrainingObjectiveManager.WeaponFired");
		
		UYStagedTrainingObjectiveManager_WeaponFired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnPlayerEnteredBattleZoneSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYStagedTrainingObjectiveManager::OnPlayerEnteredBattleZoneSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnPlayerEnteredBattleZoneSignature__DelegateSignature");
		
		UYStagedTrainingObjectiveManager_OnPlayerEnteredBattleZoneSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnObjectiveUpdatedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYStagedTrainingObjectiveManager::OnObjectiveUpdatedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnObjectiveUpdatedSignature__DelegateSignature");
		
		UYStagedTrainingObjectiveManager_OnObjectiveUpdatedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnMatchEndedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYStagedTrainingObjectiveManager::OnMatchEndedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnMatchEndedSignature__DelegateSignature");
		
		UYStagedTrainingObjectiveManager_OnMatchEndedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnHudHelpOverlayOpenedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYStagedTrainingObjectiveManager::OnHudHelpOverlayOpenedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnHudHelpOverlayOpenedSignature__DelegateSignature");
		
		UYStagedTrainingObjectiveManager_OnHudHelpOverlayOpenedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnDamageTakenByWeaponSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYPawn*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AYWeapon*                                    Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYStagedTrainingObjectiveManager::OnDamageTakenByWeaponSignature__DelegateSignature(class AYPawn* targetPawn, class AYPawn* Instigator, class AYWeapon* Weapon, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnDamageTakenByWeaponSignature__DelegateSignature");
		
		UYStagedTrainingObjectiveManager_OnDamageTakenByWeaponSignature__DelegateSignature_Params params {};
		params.targetPawn = targetPawn;
		params.Instigator = Instigator;
		params.Weapon = Weapon;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnAbilityActivatedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AYPawn*                                      firingPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYStagedTrainingObjectiveManager::OnAbilityActivatedSignature__DelegateSignature(class AYPawn* firingPawn, class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YStagedTrainingObjectiveManager.OnAbilityActivatedSignature__DelegateSignature");
		
		UYStagedTrainingObjectiveManager_OnAbilityActivatedSignature__DelegateSignature_Params params {};
		params.firingPawn = firingPawn;
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C980
	 * 		Name   -> Function DreadGame.YStagedTrainingObjectiveManager.HudHelpOverlayToggled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               isOpened                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYStagedTrainingObjectiveManager::HudHelpOverlayToggled(bool isOpened)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YStagedTrainingObjectiveManager.HudHelpOverlayToggled");
		
		UYStagedTrainingObjectiveManager_HudHelpOverlayToggled_Params params {};
		params.isOpened = isOpened;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B9D0
	 * 		Name   -> Function DreadGame.YStagedTrainingObjectiveManager.EnergyConsumed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYStagedTrainingObjectiveManager::EnergyConsumed(float amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YStagedTrainingObjectiveManager.EnergyConsumed");
		
		UYStagedTrainingObjectiveManager_EnergyConsumed_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073C9A0
	 * 		Name   -> Function DreadGame.YStagedTrainingObjectiveManager.AbilityActivated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      firingPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UYAbility*                                   ability                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYStagedTrainingObjectiveManager::AbilityActivated(class AYPawn* firingPawn, class UYAbility* ability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YStagedTrainingObjectiveManager.AbilityActivated");
		
		UYStagedTrainingObjectiveManager_AbilityActivated_Params params {};
		params.firingPawn = firingPawn;
		params.ability = ability;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYStagedTrainingObjectiveManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYStagedTrainingObjectiveManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YStagedTrainingObjectiveManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYStatistics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYStatistics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YStatistics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E090
	 * 		Name   -> Function DreadGame.YTeamsBoosterComponent.OnPlayerLeftMatch
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class APlayerState*                                playerLeaving                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYTeamsBoosterComponent::OnPlayerLeftMatch(class APlayerState* playerLeaving)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YTeamsBoosterComponent.OnPlayerLeftMatch");
		
		UYTeamsBoosterComponent_OnPlayerLeftMatch_Params params {};
		params.playerLeaving = playerLeaving;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYTeamsBoosterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYTeamsBoosterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YTeamsBoosterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YTechTreeManager.OnTechTreeInitialized__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYTechTreeManager::OnTechTreeInitialized__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YTechTreeManager.OnTechTreeInitialized__DelegateSignature");
		
		UYTechTreeManager_OnTechTreeInitialized__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YTechTreeManager.InitializeTechTreeServerController
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYTechTreeManager::InitializeTechTreeServerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YTechTreeManager.InitializeTechTreeServerController");
		
		UYTechTreeManager_InitializeTechTreeServerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D960
	 * 		Name   -> Function DreadGame.YTechTreeManager.InitializeTechTreeMmogClient
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYTechTreeManager::InitializeTechTreeMmogClient()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YTechTreeManager.InitializeTechTreeMmogClient");
		
		UYTechTreeManager_InitializeTechTreeMmogClient_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYTechTreeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYTechTreeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YTechTreeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007841D0
	 * 		Name   -> Function DreadGame.YThrusterComponent.UpdateThrusterTop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              inputValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::UpdateThrusterTop(float inputValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.UpdateThrusterTop");
		
		UYThrusterComponent_UpdateThrusterTop_Params params {};
		params.inputValue = inputValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784080
	 * 		Name   -> Function DreadGame.YThrusterComponent.UpdateThrusterRight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              inputValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::UpdateThrusterRight(float inputValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.UpdateThrusterRight");
		
		UYThrusterComponent_UpdateThrusterRight_Params params {};
		params.inputValue = inputValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784000
	 * 		Name   -> Function DreadGame.YThrusterComponent.UpdateThrusterLeft
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              inputValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::UpdateThrusterLeft(float inputValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.UpdateThrusterLeft");
		
		UYThrusterComponent_UpdateThrusterLeft_Params params {};
		params.inputValue = inputValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783F80
	 * 		Name   -> Function DreadGame.YThrusterComponent.UpdateThrusterFront
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              inputValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::UpdateThrusterFront(float inputValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.UpdateThrusterFront");
		
		UYThrusterComponent_UpdateThrusterFront_Params params {};
		params.inputValue = inputValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783F00
	 * 		Name   -> Function DreadGame.YThrusterComponent.UpdateThrusterBottom
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              inputValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::UpdateThrusterBottom(float inputValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.UpdateThrusterBottom");
		
		UYThrusterComponent_UpdateThrusterBottom_Params params {};
		params.inputValue = inputValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783E80
	 * 		Name   -> Function DreadGame.YThrusterComponent.UpdateThrusterBack
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              inputValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::UpdateThrusterBack(float inputValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.UpdateThrusterBack");
		
		UYThrusterComponent_UpdateThrusterBack_Params params {};
		params.inputValue = inputValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783380
	 * 		Name   -> Function DreadGame.YThrusterComponent.UpdateEnergyWheelSelection
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             energyWheelFunction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::UpdateEnergyWheelSelection(EYEnergyWheelSelection energyWheelFunction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.UpdateEnergyWheelSelection");
		
		UYThrusterComponent_UpdateEnergyWheelSelection_Params params {};
		params.energyWheelFunction = energyWheelFunction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767320
	 * 		Name   -> Function DreadGame.YThrusterComponent.OnOwningPawnDied
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		float                                              ActualDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         FHitComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Momentum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYThrusterComponent::OnOwningPawnDied(float ActualDamage, class AController* Killer, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, const class FName& BoneName, const struct FVector& Momentum, class UDamageType* DamageType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.OnOwningPawnDied");
		
		UYThrusterComponent_OnOwningPawnDied_Params params {};
		params.ActualDamage = ActualDamage;
		params.Killer = Killer;
		params.HitLocation = HitLocation;
		params.FHitComponent = FHitComponent;
		params.BoneName = BoneName;
		params.Momentum = Momentum;
		params.DamageType = DamageType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C960
	 * 		Name   -> Function DreadGame.YThrusterComponent.HideThruster
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UYThrusterComponent::HideThruster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YThrusterComponent.HideThruster");
		
		UYThrusterComponent_HideThruster_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYThrusterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYThrusterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YThrusterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYThumbnailRenderer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYThumbnailRenderer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YThumbnailRenderer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYTutorial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYTutorial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YTutorial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYUIAudioManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYUIAudioManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YUIAudioManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchAudioManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchAudioManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchAudioManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYGenericAudioManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYGenericAudioManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YGenericAudioManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHudAudioManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHudAudioManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHudAudioManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYMenuAudioManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYMenuAudioManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMenuAudioManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYUIFilterNavigationElement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYUIFilterNavigationElement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YUIFilterNavigationElement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YUIRenderBaseActor.OnUpdateMeshes
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AYUIRenderBaseActor::OnUpdateMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YUIRenderBaseActor.OnUpdateMeshes");
		
		AYUIRenderBaseActor_OnUpdateMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYUIRenderBaseActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYUIRenderBaseActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YUIRenderBaseActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007801F0
	 * 		Name   -> Function DreadGame.YVehicleMovementComp.StopMovements
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		bool                                               bDeactivateConstantForces                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYVehicleMovementComp::StopMovements(bool bDeactivateConstantForces)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVehicleMovementComp.StopMovements");
		
		UYVehicleMovementComp_StopMovements_Params params {};
		params.bDeactivateConstantForces = bDeactivateConstantForces;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774E50
	 * 		Name   -> Function DreadGame.YVehicleMovementComp.ServerUpdateVerticalValuesState
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              inAscendValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              inDescendValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVehicleMovementComp::ServerUpdateVerticalValuesState(float inAscendValue, float inDescendValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVehicleMovementComp.ServerUpdateVerticalValuesState");
		
		UYVehicleMovementComp_ServerUpdateVerticalValuesState_Params params {};
		params.inAscendValue = inAscendValue;
		params.inDescendValue = inDescendValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774DA0
	 * 		Name   -> Function DreadGame.YVehicleMovementComp.ServerUpdateVerticalInputState
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              inVerticalInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVehicleMovementComp::ServerUpdateVerticalInputState(float inVerticalInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVehicleMovementComp.ServerUpdateVerticalInputState");
		
		UYVehicleMovementComp_ServerUpdateVerticalInputState_Params params {};
		params.inVerticalInput = inVerticalInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774CF0
	 * 		Name   -> Function DreadGame.YVehicleMovementComp.ServerUpdateThrottleState
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              inThrottleInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVehicleMovementComp::ServerUpdateThrottleState(float inThrottleInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVehicleMovementComp.ServerUpdateThrottleState");
		
		UYVehicleMovementComp_ServerUpdateThrottleState_Params params {};
		params.inThrottleInput = inThrottleInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774C40
	 * 		Name   -> Function DreadGame.YVehicleMovementComp.ServerUpdateSteeringValuesState
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              inTurnRightValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVehicleMovementComp::ServerUpdateSteeringValuesState(float inTurnRightValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVehicleMovementComp.ServerUpdateSteeringValuesState");
		
		UYVehicleMovementComp_ServerUpdateSteeringValuesState_Params params {};
		params.inTurnRightValue = inTurnRightValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00774B90
	 * 		Name   -> Function DreadGame.YVehicleMovementComp.ServerUpdateSteeringInputState
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              inSteeringInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVehicleMovementComp::ServerUpdateSteeringInputState(float inSteeringInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVehicleMovementComp.ServerUpdateSteeringInputState");
		
		UYVehicleMovementComp_ServerUpdateSteeringInputState_Params params {};
		params.inSteeringInput = inSteeringInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E760
	 * 		Name   -> Function DreadGame.YVehicleMovementComp.ReenableMovements
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void UYVehicleMovementComp::ReenableMovements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVehicleMovementComp.ReenableMovements");
		
		UYVehicleMovementComp_ReenableMovements_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVehicleMovementComp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVehicleMovementComp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVehicleMovementComp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YVimInstance.OnPlayPreviewAnimation
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYVimInstance::OnPlayPreviewAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstance.OnPlayPreviewAnimation");
		
		UYVimInstance_OnPlayPreviewAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075EF60
	 * 		Name   -> Function DreadGame.YVimInstance.IsInCustomizationPreview
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstance::IsInCustomizationPreview()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstance.IsInCustomizationPreview");
		
		UYVimInstance_IsInCustomizationPreview_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007821A0
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.TriggerDeactivation
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceAbility::TriggerDeactivation(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.TriggerDeactivation");
		
		UYVimInstanceAbility_TriggerDeactivation_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782020
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.TriggerCooldownStarted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		float                                              cooldownTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceAbility::TriggerCooldownStarted(float cooldownTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.TriggerCooldownStarted");
		
		UYVimInstanceAbility_TriggerCooldownStarted_Params params {};
		params.cooldownTime = cooldownTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781F20
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.TriggerCooldownExpired
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceAbility::TriggerCooldownExpired(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.TriggerCooldownExpired");
		
		UYVimInstanceAbility_TriggerCooldownExpired_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781A70
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.TriggerActivation
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               abilitySucceeded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceAbility::TriggerActivation(bool abilitySucceeded, int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.TriggerActivation");
		
		UYVimInstanceAbility_TriggerActivation_Params params {};
		params.abilitySucceeded = abilitySucceeded;
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E690
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.IsDelayIsActivated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceAbility::IsDelayIsActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.IsDelayIsActivated");
		
		UYVimInstanceAbility_IsDelayIsActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E630
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.IsDelayBeforeCooldownExpired
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceAbility::IsDelayBeforeCooldownExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.IsDelayBeforeCooldownExpired");
		
		UYVimInstanceAbility_IsDelayBeforeCooldownExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DEE0
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.IsAbilityOnCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceAbility::IsAbilityOnCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.IsAbilityOnCooldown");
		
		UYVimInstanceAbility_IsAbilityOnCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DDD0
	 * 		Name   -> Function DreadGame.YVimInstanceAbility.IsAbilityActivated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceAbility::IsAbilityActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceAbility.IsAbilityActivated");
		
		UYVimInstanceAbility_IsAbilityActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVimInstanceAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVimInstanceAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVimInstanceAbility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00784100
	 * 		Name   -> Function DreadGame.YVimInstanceShip.UpdateThrusterState
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYThrusterPosition                                 Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::UpdateThrusterState(EYThrusterPosition Type, float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.UpdateThrusterState");
		
		UYVimInstanceShip_UpdateThrusterState_Params params {};
		params.Type = Type;
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007819F0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.TriggerAbilityLostTarget
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::TriggerAbilityLostTarget(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.TriggerAbilityLostTarget");
		
		UYVimInstanceShip_TriggerAbilityLostTarget_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781930
	 * 		Name   -> Function DreadGame.YVimInstanceShip.TriggerAbilityLockTarget
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::TriggerAbilityLockTarget(class AYPawn* targetPawn, int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.TriggerAbilityLockTarget");
		
		UYVimInstanceShip_TriggerAbilityLockTarget_Params params {};
		params.targetPawn = targetPawn;
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007818B0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.TriggerAbilityCooldownStarted
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              cooldownTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::TriggerAbilityCooldownStarted(float cooldownTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.TriggerAbilityCooldownStarted");
		
		UYVimInstanceShip_TriggerAbilityCooldownStarted_Params params {};
		params.cooldownTime = cooldownTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781830
	 * 		Name   -> Function DreadGame.YVimInstanceShip.TriggerAbilityCooldownExpired
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::TriggerAbilityCooldownExpired(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.TriggerAbilityCooldownExpired");
		
		UYVimInstanceShip_TriggerAbilityCooldownExpired_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007803F0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.StopReloadWeapon
	 * 		Flags  -> (Native, Public)
	 */
	void UYVimInstanceShip::StopReloadWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.StopReloadWeapon");
		
		UYVimInstanceShip_StopReloadWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E65A70
	 * 		Name   -> Function DreadGame.YVimInstanceShip.StartReloadWeapon
	 * 		Flags  -> (Native, Public)
	 */
	void UYVimInstanceShip::StartReloadWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.StartReloadWeapon");
		
		UYVimInstanceShip_StartReloadWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FBD0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsThrusterAccellerating
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EYThrusterPosition                                 Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYVimInstanceShip::IsThrusterAccellerating(EYThrusterPosition Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsThrusterAccellerating");
		
		UYVimInstanceShip_IsThrusterAccellerating_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FAA0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsShipReloading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsShipReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsShipReloading");
		
		UYVimInstanceShip_IsShipReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FA70
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsShipReady
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsShipReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsShipReady");
		
		UYVimInstanceShip_IsShipReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FA40
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsShipFiring
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsShipFiring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsShipFiring");
		
		UYVimInstanceShip_IsShipFiring_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FA10
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsShipCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsShipCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsShipCooldown");
		
		UYVimInstanceShip_IsShipCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F9E0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsShipCharge
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsShipCharge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsShipCharge");
		
		UYVimInstanceShip_IsShipCharge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F9B0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsShipActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsShipActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsShipActive");
		
		UYVimInstanceShip_IsShipActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DF10
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsAbilityOnCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsAbilityOnCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsAbilityOnCooldown");
		
		UYVimInstanceShip_IsAbilityOnCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DE60
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsAbilityLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsAbilityLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsAbilityLocked");
		
		UYVimInstanceShip_IsAbilityLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DE00
	 * 		Name   -> Function DreadGame.YVimInstanceShip.IsAbilityActivated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceShip::IsAbilityActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.IsAbilityActivated");
		
		UYVimInstanceShip_IsAbilityActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DA00
	 * 		Name   -> Function DreadGame.YVimInstanceShip.InitializeTriggerWeaponDelegates
	 * 		Flags  -> (Native, Public)
	 */
	void UYVimInstanceShip::InitializeTriggerWeaponDelegates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.InitializeTriggerWeaponDelegates");
		
		UYVimInstanceShip_InitializeTriggerWeaponDelegates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DD80
	 * 		Name   -> Function DreadGame.YVimInstanceShip.InitializeTriggerAbilityDelegates
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYVimInstanceShip::InitializeTriggerAbilityDelegates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.InitializeTriggerAbilityDelegates");
		
		UYVimInstanceShip_InitializeTriggerAbilityDelegates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007499D0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.DeactivateWeapon
	 * 		Flags  -> (Native, Public)
	 */
	void UYVimInstanceShip::DeactivateWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.DeactivateWeapon");
		
		UYVimInstanceShip_DeactivateWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DFB0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerReady
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::ActivateWeaponTriggerReady(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerReady");
		
		UYVimInstanceShip_ActivateWeaponTriggerReady_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DF00
	 * 		Name   -> Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerFiring
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::ActivateWeaponTriggerFiring(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerFiring");
		
		UYVimInstanceShip_ActivateWeaponTriggerFiring_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DE50
	 * 		Name   -> Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerCooldown
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::ActivateWeaponTriggerCooldown(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerCooldown");
		
		UYVimInstanceShip_ActivateWeaponTriggerCooldown_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DDA0
	 * 		Name   -> Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerCharging
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::ActivateWeaponTriggerCharging(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.ActivateWeaponTriggerCharging");
		
		UYVimInstanceShip_ActivateWeaponTriggerCharging_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780410
	 * 		Name   -> Function DreadGame.YVimInstanceShip.ActivateWeapon
	 * 		Flags  -> (Native, Public)
	 */
	void UYVimInstanceShip::ActivateWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.ActivateWeapon");
		
		UYVimInstanceShip_ActivateWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CC60
	 * 		Name   -> Function DreadGame.YVimInstanceShip.ActivateAbilityGetsActivated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               abilitySucceeded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceShip::ActivateAbilityGetsActivated(bool abilitySucceeded, int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceShip.ActivateAbilityGetsActivated");
		
		UYVimInstanceShip_ActivateAbilityGetsActivated_Params params {};
		params.abilitySucceeded = abilitySucceeded;
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVimInstanceShip.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVimInstanceShip::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVimInstanceShip");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780410
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.StopReloadWeapon
	 * 		Flags  -> (Native, Protected)
	 */
	void UYVimInstanceWeapon::StopReloadWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.StopReloadWeapon");
		
		UYVimInstanceWeapon_StopReloadWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01EBFC30
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.StartReloadWeapon
	 * 		Flags  -> (Native, Protected)
	 */
	void UYVimInstanceWeapon::StartReloadWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.StartReloadWeapon");
		
		UYVimInstanceWeapon_StartReloadWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F9B0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.IsWeaponReloading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeapon::IsWeaponReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.IsWeaponReloading");
		
		UYVimInstanceWeapon_IsWeaponReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FDD0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.IsWeaponReady
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeapon::IsWeaponReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.IsWeaponReady");
		
		UYVimInstanceWeapon_IsWeaponReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FDA0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.IsWeaponFiring
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeapon::IsWeaponFiring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.IsWeaponFiring");
		
		UYVimInstanceWeapon_IsWeaponFiring_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FD70
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.IsWeaponCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeapon::IsWeaponCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.IsWeaponCooldown");
		
		UYVimInstanceWeapon_IsWeaponCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FD40
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.IsWeaponCharge
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeapon::IsWeaponCharge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.IsWeaponCharge");
		
		UYVimInstanceWeapon_IsWeaponCharge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FD10
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.IsWeaponActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeapon::IsWeaponActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.IsWeaponActive");
		
		UYVimInstanceWeapon_IsWeaponActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750F00
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.GetCurrentYaw
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYVimInstanceWeapon::GetCurrentYaw()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.GetCurrentYaw");
		
		UYVimInstanceWeapon_GetCurrentYaw_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750AF0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.GetCurrentPitch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UYVimInstanceWeapon::GetCurrentPitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.GetCurrentPitch");
		
		UYVimInstanceWeapon_GetCurrentPitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007499F0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.DeactivateWeapon
	 * 		Flags  -> (Native, Protected)
	 */
	void UYVimInstanceWeapon::DeactivateWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.DeactivateWeapon");
		
		UYVimInstanceWeapon_DeactivateWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DD80
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.ActivateWeapon
	 * 		Flags  -> (Native, Protected)
	 */
	void UYVimInstanceWeapon::ActivateWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.ActivateWeapon");
		
		UYVimInstanceWeapon_ActivateWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DCD0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.ActivateTriggerReady
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeapon::ActivateTriggerReady(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.ActivateTriggerReady");
		
		UYVimInstanceWeapon_ActivateTriggerReady_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DB60
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.ActivateTriggerFiring
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeapon::ActivateTriggerFiring(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.ActivateTriggerFiring");
		
		UYVimInstanceWeapon_ActivateTriggerFiring_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DFB0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.ActivateTriggerCooldown
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeapon::ActivateTriggerCooldown(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.ActivateTriggerCooldown");
		
		UYVimInstanceWeapon_ActivateTriggerCooldown_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DAB0
	 * 		Name   -> Function DreadGame.YVimInstanceWeapon.ActivateTriggerCharging
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeapon::ActivateTriggerCharging(const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeapon.ActivateTriggerCharging");
		
		UYVimInstanceWeapon_ActivateTriggerCharging_Params params {};
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVimInstanceWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVimInstanceWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVimInstanceWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVimInstanceWeaponBeam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVimInstanceWeaponBeam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVimInstanceWeaponBeam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E230
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelReady
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYVimInstanceWeaponProjectile::IsBarrelReady(const class FName& barrelSocket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelReady");
		
		UYVimInstanceWeaponProjectile_IsBarrelReady_Params params {};
		params.barrelSocket = barrelSocket;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E190
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelFiring
	 * 		Flags  -> (Native, Protected, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYVimInstanceWeaponProjectile::IsBarrelFiring(const class FName& barrelSocket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelFiring");
		
		UYVimInstanceWeaponProjectile_IsBarrelFiring_Params params {};
		params.barrelSocket = barrelSocket;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E100
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelCooldown
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYVimInstanceWeaponProjectile::IsBarrelCooldown(const class FName& barrelSocket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelCooldown");
		
		UYVimInstanceWeaponProjectile_IsBarrelCooldown_Params params {};
		params.barrelSocket = barrelSocket;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E070
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelCharge
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYVimInstanceWeaponProjectile::IsBarrelCharge(const class FName& barrelSocket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.IsBarrelCharge");
		
		UYVimInstanceWeaponProjectile_IsBarrelCharge_Params params {};
		params.barrelSocket = barrelSocket;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D9C0
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelReady
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectile::ActivateTriggerBarrelReady(const class FName& barrelSocket, const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelReady");
		
		UYVimInstanceWeaponProjectile_ActivateTriggerBarrelReady_Params params {};
		params.barrelSocket = barrelSocket;
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D8D0
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelFiring
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectile::ActivateTriggerBarrelFiring(const class FName& barrelSocket, const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelFiring");
		
		UYVimInstanceWeaponProjectile_ActivateTriggerBarrelFiring_Params params {};
		params.barrelSocket = barrelSocket;
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D7E0
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelCoolingdown
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectile::ActivateTriggerBarrelCoolingdown(const class FName& barrelSocket, const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelCoolingdown");
		
		UYVimInstanceWeaponProjectile_ActivateTriggerBarrelCoolingdown_Params params {};
		params.barrelSocket = barrelSocket;
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D6F0
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelCharging
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FName                                        barrelSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYWeaponStateInfo                           weaponState                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectile::ActivateTriggerBarrelCharging(const class FName& barrelSocket, const struct FYWeaponStateInfo& weaponState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectile.ActivateTriggerBarrelCharging");
		
		UYVimInstanceWeaponProjectile_ActivateTriggerBarrelCharging_Params params {};
		params.barrelSocket = barrelSocket;
		params.weaponState = weaponState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVimInstanceWeaponProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVimInstanceWeaponProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVimInstanceWeaponProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782540
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerLostTarget
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectileAbility::TriggerLostTarget(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerLostTarget");
		
		UYVimInstanceWeaponProjectileAbility_TriggerLostTarget_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782480
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerLockTarget
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AYPawn*                                      targetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectileAbility::TriggerLockTarget(class AYPawn* targetPawn, int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerLockTarget");
		
		UYVimInstanceWeaponProjectileAbility_TriggerLockTarget_Params params {};
		params.targetPawn = targetPawn;
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007820A0
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerCooldownStarted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		float                                              cooldownTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectileAbility::TriggerCooldownStarted(float cooldownTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerCooldownStarted");
		
		UYVimInstanceWeaponProjectileAbility_TriggerCooldownStarted_Params params {};
		params.cooldownTime = cooldownTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781FA0
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerCooldownExpired
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectileAbility::TriggerCooldownExpired(int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.TriggerCooldownExpired");
		
		UYVimInstanceWeaponProjectileAbility_TriggerCooldownExpired_Params params {};
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E6C0
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.IsDelayIsActivated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeaponProjectileAbility::IsDelayIsActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.IsDelayIsActivated");
		
		UYVimInstanceWeaponProjectileAbility_IsDelayIsActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E660
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.IsDelayBeforeCooldownExpired
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeaponProjectileAbility::IsDelayBeforeCooldownExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.IsDelayBeforeCooldownExpired");
		
		UYVimInstanceWeaponProjectileAbility_IsDelayBeforeCooldownExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DF40
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.IsAbilityOnCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeaponProjectileAbility::IsAbilityOnCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.IsAbilityOnCooldown");
		
		UYVimInstanceWeaponProjectileAbility_IsAbilityOnCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DE90
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.IsAbilityLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeaponProjectileAbility::IsAbilityLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.IsAbilityLocked");
		
		UYVimInstanceWeaponProjectileAbility_IsAbilityLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DE30
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.IsAbilityActivated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UYVimInstanceWeaponProjectileAbility::IsAbilityActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.IsAbilityActivated");
		
		UYVimInstanceWeaponProjectileAbility_IsAbilityActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073DC10
	 * 		Name   -> Function DreadGame.YVimInstanceWeaponProjectileAbility.ActivateTriggerGetsActivated
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               abilitySucceeded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVimInstanceWeaponProjectileAbility::ActivateTriggerGetsActivated(bool abilitySucceeded, int32_t abilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVimInstanceWeaponProjectileAbility.ActivateTriggerGetsActivated");
		
		UYVimInstanceWeaponProjectileAbility_ActivateTriggerGetsActivated_Params params {};
		params.abilitySucceeded = abilitySucceeded;
		params.abilityIndex = abilityIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVimInstanceWeaponProjectileAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVimInstanceWeaponProjectileAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVimInstanceWeaponProjectileAbility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007798B0
	 * 		Name   -> Function DreadGame.YVoiceChatComponentWidget.SetPlayerName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        UniqueId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYVoiceChatComponentWidget::SetPlayerName(const class FName& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YVoiceChatComponentWidget.SetPlayerName");
		
		UYVoiceChatComponentWidget_SetPlayerName_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVoiceChatComponentWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVoiceChatComponentWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVoiceChatComponentWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVoiceLine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVoiceLine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVoiceLine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVoiceLineUnique.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVoiceLineUnique::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVoiceLineUnique");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVoiceLineContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVoiceLineContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVoiceLineContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVOTriggerSystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVOTriggerSystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVOTriggerSystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVOTriggerSystemDebug.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVOTriggerSystemDebug::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVOTriggerSystemDebug");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYVOTriggerSystemPlayByPlay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYVOTriggerSystemPlayByPlay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YVOTriggerSystemPlayByPlay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782B90
	 * 		Name   -> Function DreadGame.YWarpingComponent.TriggerWarpJumpWarmUp
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     TargetLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              warmUpTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWarpingComponent::TriggerWarpJumpWarmUp(const struct FVector& TargetLocation, float warmUpTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.TriggerWarpJumpWarmUp");
		
		UYWarpingComponent_TriggerWarpJumpWarmUp_Params params {};
		params.TargetLocation = TargetLocation;
		params.warmUpTime = warmUpTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01663160
	 * 		Name   -> Function DreadGame.YWarpingComponent.TriggerWarpJumpEnd
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void UYWarpingComponent::TriggerWarpJumpEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.TriggerWarpJumpEnd");
		
		UYWarpingComponent_TriggerWarpJumpEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782B30
	 * 		Name   -> Function DreadGame.YWarpingComponent.TriggerWarpJumpBegin
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void UYWarpingComponent::TriggerWarpJumpBegin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.TriggerWarpJumpBegin");
		
		UYWarpingComponent_TriggerWarpJumpBegin_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FED0
	 * 		Name   -> Function DreadGame.YWarpingComponent.StartWarpInAnimationMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		bool                                               IsInOrbit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWarpingComponent::StartWarpInAnimationMulticast(bool IsInOrbit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.StartWarpInAnimationMulticast");
		
		UYWarpingComponent_StartWarpInAnimationMulticast_Params params {};
		params.IsInOrbit = IsInOrbit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D840
	 * 		Name   -> Function DreadGame.YWarpingComponent.PlayWarpJumpOut
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsInOrbit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               supressGenericAudio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWarpingComponent::PlayWarpJumpOut(bool IsInOrbit, bool supressGenericAudio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.PlayWarpJumpOut");
		
		UYWarpingComponent_PlayWarpJumpOut_Params params {};
		params.IsInOrbit = IsInOrbit;
		params.supressGenericAudio = supressGenericAudio;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076D6A0
	 * 		Name   -> Function DreadGame.YWarpingComponent.PlayWarpJumpIn
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsInOrbit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               supressGenericAudio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWarpingComponent::PlayWarpJumpIn(bool IsInOrbit, bool supressGenericAudio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.PlayWarpJumpIn");
		
		UYWarpingComponent_PlayWarpJumpIn_Params params {};
		params.IsInOrbit = IsInOrbit;
		params.supressGenericAudio = supressGenericAudio;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A5F0
	 * 		Name   -> Function DreadGame.YWarpingComponent.GetWarpOutParticles
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UParticleSystem* UYWarpingComponent::GetWarpOutParticles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.GetWarpOutParticles");
		
		UYWarpingComponent_GetWarpOutParticles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A5C0
	 * 		Name   -> Function DreadGame.YWarpingComponent.GetWarpOutAudio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UAkAudioEvent* UYWarpingComponent::GetWarpOutAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.GetWarpOutAudio");
		
		UYWarpingComponent_GetWarpOutAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A590
	 * 		Name   -> Function DreadGame.YWarpingComponent.GetWarpInParticles
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UParticleSystem* UYWarpingComponent::GetWarpInParticles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.GetWarpInParticles");
		
		UYWarpingComponent_GetWarpInParticles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075A560
	 * 		Name   -> Function DreadGame.YWarpingComponent.GetWarpInAudio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UAkAudioEvent* UYWarpingComponent::GetWarpInAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWarpingComponent.GetWarpInAudio");
		
		UYWarpingComponent_GetWarpInAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWarpingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWarpingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWarpingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YBeamWeapon.TickHitMisc
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     impactLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBeamWeapon::TickHitMisc(class AActor* Target, const struct FVector& impactLocation, float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.TickHitMisc");
		
		AYBeamWeapon_TickHitMisc_Params params {};
		params.Target = Target;
		params.impactLocation = impactLocation;
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YBeamWeapon.TickHitFriendlyShield
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     impactLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBeamWeapon::TickHitFriendlyShield(class AActor* Target, const struct FVector& impactLocation, float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.TickHitFriendlyShield");
		
		AYBeamWeapon_TickHitFriendlyShield_Params params {};
		params.Target = Target;
		params.impactLocation = impactLocation;
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YBeamWeapon.TickHitFriendly
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     impactLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBeamWeapon::TickHitFriendly(class AActor* Target, const struct FVector& impactLocation, float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.TickHitFriendly");
		
		AYBeamWeapon_TickHitFriendly_Params params {};
		params.Target = Target;
		params.impactLocation = impactLocation;
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YBeamWeapon.TickHitEnemyShield
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     impactLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBeamWeapon::TickHitEnemyShield(class AActor* Target, const struct FVector& impactLocation, float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.TickHitEnemyShield");
		
		AYBeamWeapon_TickHitEnemyShield_Params params {};
		params.Target = Target;
		params.impactLocation = impactLocation;
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YBeamWeapon.TickHitEnemy
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     impactLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBeamWeapon::TickHitEnemy(class AActor* Target, const struct FVector& impactLocation, float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.TickHitEnemy");
		
		AYBeamWeapon_TickHitEnemy_Params params {};
		params.Target = Target;
		params.impactLocation = impactLocation;
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007804C0
	 * 		Name   -> Function DreadGame.YBeamWeapon.StopShooting
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void AYBeamWeapon::StopShooting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.StopShooting");
		
		AYBeamWeapon_StopShooting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YBeamWeapon.OnSwitchTargetType
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYBeamTargetType                                   targetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBeamWeapon::OnSwitchTargetType(EYBeamTargetType targetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.OnSwitchTargetType");
		
		AYBeamWeapon_OnSwitchTargetType_Params params {};
		params.targetType = targetType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FB70
	 * 		Name   -> Function DreadGame.YBeamWeapon.IsTargetLocked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYBeamWeapon::IsTargetLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.IsTargetLocked");
		
		AYBeamWeapon_IsTargetLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FB40
	 * 		Name   -> Function DreadGame.YBeamWeapon.IsTargetFriendly
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AYBeamWeapon::IsTargetFriendly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.IsTargetFriendly");
		
		AYBeamWeapon_IsTargetFriendly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749880
	 * 		Name   -> Function DreadGame.YBeamWeapon.DeactivateAlternateMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AYBeamWeapon::DeactivateAlternateMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.DeactivateAlternateMode");
		
		AYBeamWeapon_DeactivateAlternateMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742C30
	 * 		Name   -> Function DreadGame.YBeamWeapon.CalculateBaseHealingForDistance
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              distanceSquared                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AYBeamWeapon::CalculateBaseHealingForDistance(float distanceSquared)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.CalculateBaseHealingForDistance");
		
		AYBeamWeapon_CalculateBaseHealingForDistance_Params params {};
		params.distanceSquared = distanceSquared;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742BA0
	 * 		Name   -> Function DreadGame.YBeamWeapon.CalculateBaseDamageForDistance
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              distanceSquared                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AYBeamWeapon::CalculateBaseDamageForDistance(float distanceSquared)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.CalculateBaseDamageForDistance");
		
		AYBeamWeapon_CalculateBaseDamageForDistance_Params params {};
		params.distanceSquared = distanceSquared;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CD20
	 * 		Name   -> Function DreadGame.YBeamWeapon.ActivateAlternateMode
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYBeamModifierEffects                       modifierEffects                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EYAlternativeBeamType                              alternativeBeamType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AYBeamWeapon::ActivateAlternateMode(const struct FYBeamModifierEffects& modifierEffects, EYAlternativeBeamType alternativeBeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YBeamWeapon.ActivateAlternateMode");
		
		AYBeamWeapon_ActivateAlternateMode_Params params {};
		params.modifierEffects = modifierEffects;
		params.alternativeBeamType = alternativeBeamType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYBeamWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYBeamWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YBeamWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileWeapon.ReceiveExecuteReady
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  shootingTransform                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYProjectileWeapon::ReceiveExecuteReady(const class FName& socket, const struct FTransform& shootingTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileWeapon.ReceiveExecuteReady");
		
		AYProjectileWeapon_ReceiveExecuteReady_Params params {};
		params.socket = socket;
		params.shootingTransform = shootingTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileWeapon.ReceiveExecuteFiring
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  shootingTransform                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYProjectileWeapon::ReceiveExecuteFiring(const class FName& socket, const struct FTransform& shootingTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileWeapon.ReceiveExecuteFiring");
		
		AYProjectileWeapon_ReceiveExecuteFiring_Params params {};
		params.socket = socket;
		params.shootingTransform = shootingTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileWeapon.ReceiveExecuteCooldown
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  shootingTransform                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYProjectileWeapon::ReceiveExecuteCooldown(const class FName& socket, const struct FTransform& shootingTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileWeapon.ReceiveExecuteCooldown");
		
		AYProjectileWeapon_ReceiveExecuteCooldown_Params params {};
		params.socket = socket;
		params.shootingTransform = shootingTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YProjectileWeapon.ReceiveExecuteCharging
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  shootingTransform                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AYProjectileWeapon::ReceiveExecuteCharging(const class FName& socket, const struct FTransform& shootingTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YProjectileWeapon.ReceiveExecuteCharging");
		
		AYProjectileWeapon_ReceiveExecuteCharging_Params params {};
		params.socket = socket;
		params.shootingTransform = shootingTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYProjectileWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYProjectileWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YProjectileWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYMissileWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYMissileWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YMissileWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYWeaponRocketSwarm.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYWeaponRocketSwarm::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeaponRocketSwarm");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYWeaponBroadSide.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYWeaponBroadSide::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWeaponBroadSide");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AC70
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.SetSelectedShipLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            selectedIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::SetSelectedShipLoadout(int32_t selectedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.SetSelectedShipLoadout");
		
		UYHUDWidget_ShipSelect_SetSelectedShipLoadout_Params params {};
		params.selectedIndex = selectedIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007783C0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.SetHoveredShipLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            hoveredIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::SetHoveredShipLoadout(int32_t hoveredIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.SetHoveredShipLoadout");
		
		UYHUDWidget_ShipSelect_SetHoveredShipLoadout_Params params {};
		params.hoveredIndex = hoveredIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007769C0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.SetCustomLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            selectedIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            customloadoutIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::SetCustomLoadout(int32_t selectedIndex, int32_t customloadoutIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.SetCustomLoadout");
		
		UYHUDWidget_ShipSelect_SetCustomLoadout_Params params {};
		params.selectedIndex = selectedIndex;
		params.customloadoutIndex = customloadoutIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764110
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.OnGamepadLayoutChanged
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYHUDWidget_ShipSelect::OnGamepadLayoutChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.OnGamepadLayoutChanged");
		
		UYHUDWidget_ShipSelect_OnGamepadLayoutChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752710
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.GetHoveredShipLoadoutInfo
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYShipLoadoutInfo                           shipLoadoutInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UYHUDWidget_ShipSelect::GetHoveredShipLoadoutInfo(struct FYShipLoadoutInfo* shipLoadoutInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.GetHoveredShipLoadoutInfo");
		
		UYHUDWidget_ShipSelect_GetHoveredShipLoadoutInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (shipLoadoutInfo != nullptr)
			*shipLoadoutInfo = params.shipLoadoutInfo;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventShowLockedSelection
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isLocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventShowLockedSelection(bool isLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventShowLockedSelection");
		
		UYHUDWidget_ShipSelect_BP_EventShowLockedSelection_Params params {};
		params.isLocked = isLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetSelectedLoadout
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            selectedIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventSetSelectedLoadout(int32_t selectedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetSelectedLoadout");
		
		UYHUDWidget_ShipSelect_BP_EventSetSelectedLoadout_Params params {};
		params.selectedIndex = selectedIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetReadyUpEnabled
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventSetReadyUpEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetReadyUpEnabled");
		
		UYHUDWidget_ShipSelect_BP_EventSetReadyUpEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetHighlightedLoadout
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            highlightedIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventSetHighlightedLoadout(int32_t highlightedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetHighlightedLoadout");
		
		UYHUDWidget_ShipSelect_BP_EventSetHighlightedLoadout_Params params {};
		params.highlightedIndex = highlightedIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetFleetName
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      fleetName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventSetFleetName(const class FString& fleetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetFleetName");
		
		UYHUDWidget_ShipSelect_BP_EventSetFleetName_Params params {};
		params.fleetName = fleetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetCanSelect
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bCanReselectShip                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventSetCanSelect(bool bCanReselectShip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventSetCanSelect");
		
		UYHUDWidget_ShipSelect_BP_EventSetCanSelect_Params params {};
		params.bCanReselectShip = bCanReselectShip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventPopulateLoadoutSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FYShipSelectSlotData                        slotData                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventPopulateLoadoutSlot(int32_t SlotIndex, const struct FYShipSelectSlotData& slotData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventPopulateLoadoutSlot");
		
		UYHUDWidget_ShipSelect_BP_EventPopulateLoadoutSlot_Params params {};
		params.SlotIndex = SlotIndex;
		params.slotData = slotData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipSelect.BP_EventClearLoadoutSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipSelect::BP_EventClearLoadoutSlot(int32_t SlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipSelect.BP_EventClearLoadoutSlot");
		
		UYHUDWidget_ShipSelect_BP_EventClearLoadoutSlot_Params params {};
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ShipSelect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ShipSelect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ShipSelect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FB80
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.StartEndOfMatchFlow
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYEndOfMatchManager::StartEndOfMatchFlow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.StartEndOfMatchFlow");
		
		UYEndOfMatchManager_StartEndOfMatchFlow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00767760
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.OnPendingApplicationComplete
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::OnPendingApplicationComplete(const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.OnPendingApplicationComplete");
		
		UYEndOfMatchManager_OnPendingApplicationComplete_Params params {};
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YEndOfMatchManager.OnInitializationCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYEndOfMatchManager::OnInitializationCompleted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YEndOfMatchManager.OnInitializationCompleted__DelegateSignature");
		
		UYEndOfMatchManager_OnInitializationCompleted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YEndOfMatchManager.OnDataApplicationComplete__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::OnDataApplicationComplete__DelegateSignature(const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YEndOfMatchManager.OnDataApplicationComplete__DelegateSignature");
		
		UYEndOfMatchManager_OnDataApplicationComplete__DelegateSignature_Params params {};
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762870
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.OnBlueprintTabClickedInput
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		EYEOMState                                         NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::OnBlueprintTabClickedInput(EYEOMState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.OnBlueprintTabClickedInput");
		
		UYEndOfMatchManager_OnBlueprintTabClickedInput_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762850
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.OnBlueprintStateChangeComplete
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYEndOfMatchManager::OnBlueprintStateChangeComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.OnBlueprintStateChangeComplete");
		
		UYEndOfMatchManager_OnBlueprintStateChangeComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_InitBlueprintLinks
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYGameModeType                                     gameModeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_InitBlueprintLinks(EYGameModeType gameModeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_InitBlueprintLinks");
		
		UYEndOfMatchManager_BP_InitBlueprintLinks_Params params {};
		params.gameModeType = gameModeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventUpdateBonusEarningsBanner
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FYEOMBonusEarningsBannerData                bonusEarningsData                                          (Parm, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventUpdateBonusEarningsBanner(const struct FYEOMBonusEarningsBannerData& bonusEarningsData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventUpdateBonusEarningsBanner");
		
		UYEndOfMatchManager_BP_EventUpdateBonusEarningsBanner_Params params {};
		params.bonusEarningsData = bonusEarningsData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetVictoryDefeatBanner
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYMatchOutcome                                     matchOutcome                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            allyScore                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            enemyScore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetVictoryDefeatBanner(EYMatchOutcome matchOutcome, int32_t allyScore, int32_t enemyScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetVictoryDefeatBanner");
		
		UYEndOfMatchManager_BP_EventSetVictoryDefeatBanner_Params params {};
		params.matchOutcome = matchOutcome;
		params.allyScore = allyScore;
		params.enemyScore = enemyScore;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetNavigationLabels
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        leftTab                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        rightTab                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetNavigationLabels(const class FText& leftTab, const class FText& rightTab)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetNavigationLabels");
		
		UYEndOfMatchManager_BP_EventSetNavigationLabels_Params params {};
		params.leftTab = leftTab;
		params.rightTab = rightTab;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetFleetEarnings
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<int32_t>                                    shipXpList                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetFleetEarnings(TArray<int32_t> shipXpList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetFleetEarnings");
		
		UYEndOfMatchManager_BP_EventSetFleetEarnings_Params params {};
		params.shipXpList = shipXpList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetEndOfMatchState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYEOMState                                         NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYGameModeType                                     gameModeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetEndOfMatchState(EYEOMState NewState, EYGameModeType gameModeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetEndOfMatchState");
		
		UYEndOfMatchManager_BP_EventSetEndOfMatchState_Params params {};
		params.NewState = NewState;
		params.gameModeType = gameModeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetEarningsValues
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            softCurrencyValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            shipXpValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            freeXpValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               animateTally                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetEarningsValues(int32_t softCurrencyValue, int32_t shipXpValue, int32_t freeXpValue, bool animateTally)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetEarningsValues");
		
		UYEndOfMatchManager_BP_EventSetEarningsValues_Params params {};
		params.softCurrencyValue = softCurrencyValue;
		params.shipXpValue = shipXpValue;
		params.freeXpValue = freeXpValue;
		params.animateTally = animateTally;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetEarningsTitle
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        earningsLabel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetEarningsTitle(const class FText& earningsLabel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetEarningsTitle");
		
		UYEndOfMatchManager_BP_EventSetEarningsTitle_Params params {};
		params.earningsLabel = earningsLabel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetCaptainNames
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FYEOMTeamData                               teamData                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetCaptainNames(const struct FYEOMTeamData& teamData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetCaptainNames");
		
		UYEndOfMatchManager_BP_EventSetCaptainNames_Params params {};
		params.teamData = teamData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.BP_EventSetBonusEarningsTeamShareLabels
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        titleText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        percentBonusText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        notAppliedText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               isApplied                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYEndOfMatchManager::BP_EventSetBonusEarningsTeamShareLabels(const class FText& titleText, const class FText& percentBonusText, const class FText& notAppliedText, bool isApplied)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.BP_EventSetBonusEarningsTeamShareLabels");
		
		UYEndOfMatchManager_BP_EventSetBonusEarningsTeamShareLabels_Params params {};
		params.titleText = titleText;
		params.percentBonusText = percentBonusText;
		params.notAppliedText = notAppliedText;
		params.isApplied = isApplied;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007411B0
	 * 		Name   -> Function DreadGame.YEndOfMatchManager.ApplyHavocProgressionData
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYEndOfMatchManager::ApplyHavocProgressionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YEndOfMatchManager.ApplyHavocProgressionData");
		
		UYEndOfMatchManager_ApplyHavocProgressionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYEndOfMatchManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYEndOfMatchManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YEndOfMatchManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_AbilitySlot.BP_EventTimeUpdate
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      cooldownText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              percentComplete                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_AbilitySlot::BP_EventTimeUpdate(const class FString& cooldownText, float percentComplete)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_AbilitySlot.BP_EventTimeUpdate");
		
		UYHUDWidget_AbilitySlot_BP_EventTimeUpdate_Params params {};
		params.cooldownText = cooldownText;
		params.percentComplete = percentComplete;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_AbilitySlot.BP_EventStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYUIAbilityState                                   NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_AbilitySlot::BP_EventStateChanged(EYUIAbilityState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_AbilitySlot.BP_EventStateChanged");
		
		UYHUDWidget_AbilitySlot_BP_EventStateChanged_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_AbilitySlot.BP_EventSetConsoleLegendIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYPS4ButtonIcon                                    icon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_AbilitySlot::BP_EventSetConsoleLegendIcon(EYPS4ButtonIcon icon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_AbilitySlot.BP_EventSetConsoleLegendIcon");
		
		UYHUDWidget_AbilitySlot_BP_EventSetConsoleLegendIcon_Params params {};
		params.icon = icon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_AbilitySlot.BP_EventInitializeComplete
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_AbilitySlot::BP_EventInitializeComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_AbilitySlot.BP_EventInitializeComplete");
		
		UYHUDWidget_AbilitySlot_BP_EventInitializeComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_AbilitySlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_AbilitySlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_AbilitySlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077D390
	 * 		Name   -> Function DreadGame.YHUDWidget_Announcement.ShowAnnouncement
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      msg                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Announcement::ShowAnnouncement(const class FString& msg, int32_t duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Announcement.ShowAnnouncement");
		
		UYHUDWidget_Announcement_ShowAnnouncement_Params params {};
		params.msg = msg;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775920
	 * 		Name   -> Function DreadGame.YHUDWidget_Announcement.SetAllowedToBeShown
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               allowing                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Announcement::SetAllowedToBeShown(bool allowing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Announcement.SetAllowedToBeShown");
		
		UYHUDWidget_Announcement_SetAllowedToBeShown_Params params {};
		params.allowing = allowing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E050
	 * 		Name   -> Function DreadGame.YHUDWidget_Announcement.IsAnnouncementActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_Announcement::IsAnnouncementActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Announcement.IsAnnouncementActive");
		
		UYHUDWidget_Announcement_IsAnnouncementActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E030
	 * 		Name   -> Function DreadGame.YHUDWidget_Announcement.IsAllowedToBeShown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_Announcement::IsAllowedToBeShown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Announcement.IsAllowedToBeShown");
		
		UYHUDWidget_Announcement_IsAllowedToBeShown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Announcement.CloseAnnouncement
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_Announcement::CloseAnnouncement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Announcement.CloseAnnouncement");
		
		UYHUDWidget_Announcement_CloseAnnouncement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Announcement.BP_ShowAnnouncement
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      msg                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Announcement::BP_ShowAnnouncement(const class FString& msg, int32_t duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Announcement.BP_ShowAnnouncement");
		
		UYHUDWidget_Announcement_BP_ShowAnnouncement_Params params {};
		params.msg = msg;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_Announcement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_Announcement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_Announcement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FE30
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.StartRoundOverAnimations
	 * 		Flags  -> (Native, Public)
	 */
	void UYHUDWidget_BaseRoundOver::StartRoundOverAnimations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.StartRoundOverAnimations");
		
		UYHUDWidget_BaseRoundOver_StartRoundOverAnimations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779FF0
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.SetPlayerTeam
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BaseRoundOver::SetPlayerTeam(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.SetPlayerTeam");
		
		UYHUDWidget_BaseRoundOver_SetPlayerTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760D40
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.SetGameModeRoundResult
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BaseRoundOver::SetGameModeRoundResult(int32_t Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.SetGameModeRoundResult");
		
		UYHUDWidget_BaseRoundOver_SetGameModeRoundResult_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777B10
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.SetGameModeRound
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		int32_t                                            Round                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BaseRoundOver::SetGameModeRound(int32_t Round)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.SetGameModeRound");
		
		UYHUDWidget_BaseRoundOver_SetGameModeRound_Params params {};
		params.Round = Round;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.BP_StartRoundOverAnimations
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_BaseRoundOver::BP_StartRoundOverAnimations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.BP_StartRoundOverAnimations");
		
		UYHUDWidget_BaseRoundOver_BP_StartRoundOverAnimations_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.BP_EventSetPlayerTeam
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYTeam                                             Round                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BaseRoundOver::BP_EventSetPlayerTeam(EYTeam Round)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.BP_EventSetPlayerTeam");
		
		UYHUDWidget_BaseRoundOver_BP_EventSetPlayerTeam_Params params {};
		params.Round = Round;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.BP_EventSetGameModeRoundResult
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BaseRoundOver::BP_EventSetGameModeRoundResult(int32_t Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.BP_EventSetGameModeRoundResult");
		
		UYHUDWidget_BaseRoundOver_BP_EventSetGameModeRoundResult_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BaseRoundOver.BP_EventSetGameModeRound
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Round                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BaseRoundOver::BP_EventSetGameModeRound(int32_t Round)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BaseRoundOver.BP_EventSetGameModeRound");
		
		UYHUDWidget_BaseRoundOver_BP_EventSetGameModeRound_Params params {};
		params.Round = Round;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_BaseRoundOver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_BaseRoundOver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_BaseRoundOver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BB80
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOver_TeamElim.SetTeamEliminationPlayers
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		TArray<struct FTeamElimPlayerData>                 elimData                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOver_TeamElim::SetTeamEliminationPlayers(TArray<struct FTeamElimPlayerData> elimData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOver_TeamElim.SetTeamEliminationPlayers");
		
		UYHUDWidget_RoundOver_TeamElim_SetTeamEliminationPlayers_Params params {};
		params.elimData = elimData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOver_TeamElim.BP_SetIconTexture
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsFriendly                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            iconIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOver_TeamElim::BP_SetIconTexture(bool bIsFriendly, int32_t iconIndex, class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOver_TeamElim.BP_SetIconTexture");
		
		UYHUDWidget_RoundOver_TeamElim_BP_SetIconTexture_Params params {};
		params.bIsFriendly = bIsFriendly;
		params.iconIndex = iconIndex;
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_RoundOver_TeamElim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_RoundOver_TeamElim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_RoundOver_TeamElim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_BaseSetting_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_BaseSetting_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_BaseSetting_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00782F60
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownBox_PC.UpdateActiveItem
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            itemIdx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DropDownBox_PC::UpdateActiveItem(int32_t itemIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownBox_PC.UpdateActiveItem");
		
		UYHUDWidget_DropDownBox_PC_UpdateActiveItem_Params params {};
		params.itemIdx = itemIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DropDownBox_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DropDownBox_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DropDownBox_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783D20
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownItem_PC.UpdateText
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        inDisplayName                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FSlateFontInfo                              inFontInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DropDownItem_PC::UpdateText(const class FText& inDisplayName, const struct FSlateFontInfo& inFontInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownItem_PC.UpdateText");
		
		UYHUDWidget_DropDownItem_PC_UpdateText_Params params {};
		params.inDisplayName = inDisplayName;
		params.inFontInfo = inFontInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AB50
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownItem_PC.SetSelected
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               isSelected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DropDownItem_PC::SetSelected(bool isSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownItem_PC.SetSelected");
		
		UYHUDWidget_DropDownItem_PC_SetSelected_Params params {};
		params.isSelected = isSelected;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007540A0
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownItem_PC.GetMaxSize
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector2D UYHUDWidget_DropDownItem_PC::GetMaxSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownItem_PC.GetMaxSize");
		
		UYHUDWidget_DropDownItem_PC_GetMaxSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751780
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownItem_PC.GetDisplayText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FText UYHUDWidget_DropDownItem_PC::GetDisplayText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownItem_PC.GetDisplayText");
		
		UYHUDWidget_DropDownItem_PC_GetDisplayText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownItem_PC.BP_SetSelected
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isSelected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DropDownItem_PC::BP_SetSelected(bool isSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownItem_PC.BP_SetSelected");
		
		UYHUDWidget_DropDownItem_PC_BP_SetSelected_Params params {};
		params.isSelected = isSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DropDownItem_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DropDownItem_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DropDownItem_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A6E0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingType_PC.UpdateDisplayedData
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_SettingType_PC::UpdateDisplayedData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingType_PC.UpdateDisplayedData");
		
		UYHUDWidget_SettingType_PC_UpdateDisplayedData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779090
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingType_PC.SetNewSettingValue
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_SettingType_PC::SetNewSettingValue(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingType_PC.SetNewSettingValue");
		
		UYHUDWidget_SettingType_PC_SetNewSettingValue_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758060
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingType_PC.GetSettingValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_SettingType_PC::GetSettingValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingType_PC.GetSettingValue");
		
		UYHUDWidget_SettingType_PC_GetSettingValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758000
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingType_PC.GetSettingDisplayName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UYHUDWidget_SettingType_PC::GetSettingDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingType_PC.GetSettingDisplayName");
		
		UYHUDWidget_SettingType_PC_GetSettingDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingType_PC.BP_UpdateDisplayedData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_SettingType_PC::BP_UpdateDisplayedData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingType_PC.BP_UpdateDisplayedData");
		
		UYHUDWidget_SettingType_PC_BP_UpdateDisplayedData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_SettingType_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_SettingType_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_SettingType_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762680
	 * 		Name   -> Function DreadGame.YHUDWidget_Carousel_PC.OnArrowClicked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            optionIdx                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Carousel_PC::OnArrowClicked(int32_t optionIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Carousel_PC.OnArrowClicked");
		
		UYHUDWidget_Carousel_PC_OnArrowClicked_Params params {};
		params.optionIdx = optionIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_Carousel_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_Carousel_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_Carousel_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783600
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownForm_PC.UpdateHeaderItem
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            idx                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DropDownForm_PC::UpdateHeaderItem(int32_t idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownForm_PC.UpdateHeaderItem");
		
		UYHUDWidget_DropDownForm_PC_UpdateHeaderItem_Params params {};
		params.idx = idx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C420
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownForm_PC.OpenDropDownMenu
	 * 		Flags  -> (Final, Native, Protected, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   newViewportPos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DropDownForm_PC::OpenDropDownMenu(const struct FVector2D& newViewportPos)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownForm_PC.OpenDropDownMenu");
		
		UYHUDWidget_DropDownForm_PC_OpenDropDownMenu_Params params {};
		params.newViewportPos = newViewportPos;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748610
	 * 		Name   -> Function DreadGame.YHUDWidget_DropDownForm_PC.CloseDropDownMenu
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYHUDWidget_DropDownForm_PC::CloseDropDownMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DropDownForm_PC.CloseDropDownMenu");
		
		UYHUDWidget_DropDownForm_PC_CloseDropDownMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DropDownForm_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DropDownForm_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DropDownForm_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758E00
	 * 		Name   -> Function DreadGame.YHUDWidget_Slider_PC.GetSnapInterval
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_Slider_PC::GetSnapInterval()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Slider_PC.GetSnapInterval");
		
		UYHUDWidget_Slider_PC_GetSnapInterval_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758CF0
	 * 		Name   -> Function DreadGame.YHUDWidget_Slider_PC.GetSliderRange
	 * 		Flags  -> (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector2D UYHUDWidget_Slider_PC::GetSliderRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Slider_PC.GetSliderRange");
		
		UYHUDWidget_Slider_PC_GetSliderRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748DD0
	 * 		Name   -> Function DreadGame.YHUDWidget_Slider_PC.ConvertValToText
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYHUDWidget_Slider_PC::ConvertValToText(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Slider_PC.ConvertValToText");
		
		UYHUDWidget_Slider_PC_ConvertValToText_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_Slider_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_Slider_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_Slider_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077ABE0
	 * 		Name   -> Function DreadGame.YHUDWidget_TabButton_PC.SetSelected
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               isSelected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TabButton_PC::SetSelected(bool isSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TabButton_PC.SetSelected");
		
		UYHUDWidget_TabButton_PC_SetSelected_Params params {};
		params.isSelected = isSelected;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775D40
	 * 		Name   -> Function DreadGame.YHUDWidget_TabButton_PC.SetButtonText
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Name                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TabButton_PC::SetButtonText(const class FText& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TabButton_PC.SetButtonText");
		
		UYHUDWidget_TabButton_PC_SetButtonText_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752CF0
	 * 		Name   -> Function DreadGame.YHUDWidget_TabButton_PC.GetIsSelected
	 * 		Flags  -> (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_TabButton_PC::GetIsSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TabButton_PC.GetIsSelected");
		
		UYHUDWidget_TabButton_PC_GetIsSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TabButton_PC.BP_OnSelected
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isSelected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TabButton_PC::BP_OnSelected(bool isSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TabButton_PC.BP_OnSelected");
		
		UYHUDWidget_TabButton_PC_BP_OnSelected_Params params {};
		params.isSelected = isSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TabButton_PC.BP_OnInitialize
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              buttonMargin                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TabButton_PC::BP_OnInitialize(float buttonMargin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TabButton_PC.BP_OnInitialize");
		
		UYHUDWidget_TabButton_PC_BP_OnInitialize_Params params {};
		params.buttonMargin = buttonMargin;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TabButton_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TabButton_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TabButton_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_UserSettingOption_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_UserSettingOption_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_UserSettingOption_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_UserSettingCategory_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_UserSettingCategory_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_UserSettingCategory_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_HotkeySetting_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_HotkeySetting_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_HotkeySetting_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E030
	 * 		Name   -> Function DreadGame.YHUDWidget_BuffIndicator.IsDisplayed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYHUDWidget_BuffIndicator::IsDisplayed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BuffIndicator.IsDisplayed");
		
		UYHUDWidget_BuffIndicator_IsDisplayed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E050
	 * 		Name   -> Function DreadGame.YHUDWidget_BuffIndicator.GetBuffID
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EYBuffType UYHUDWidget_BuffIndicator::GetBuffID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BuffIndicator.GetBuffID");
		
		UYHUDWidget_BuffIndicator_GetBuffID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749840
	 * 		Name   -> Function DreadGame.YHUDWidget_BuffIndicator.Deactivate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_BuffIndicator::Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BuffIndicator.Deactivate");
		
		UYHUDWidget_BuffIndicator_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BuffIndicator.BP_DeactivateBlueprint
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_BuffIndicator::BP_DeactivateBlueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BuffIndicator.BP_DeactivateBlueprint");
		
		UYHUDWidget_BuffIndicator_BP_DeactivateBlueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_BuffIndicator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_BuffIndicator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_BuffIndicator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775C50
	 * 		Name   -> Function DreadGame.YHUDWidget_BuffManager.SetBuffIndicators
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UYHUDWidget_BuffIndicator*>           buffIndicators                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BuffManager::SetBuffIndicators(TArray<class UYHUDWidget_BuffIndicator*> buffIndicators)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BuffManager.SetBuffIndicators");
		
		UYHUDWidget_BuffManager_SetBuffIndicators_Params params {};
		params.buffIndicators = buffIndicators;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_BuffManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_BuffManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_BuffManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A580
	 * 		Name   -> Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptVisible
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Visible                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ButtonPrompt::SetPromptVisible(int32_t index, bool Visible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptVisible");
		
		UYHUDWidget_ButtonPrompt_SetPromptVisible_Params params {};
		params.index = index;
		params.Visible = Visible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A460
	 * 		Name   -> Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptFromBindingName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        binding                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ButtonPrompt::SetPromptFromBindingName(int32_t index, const class FName& binding, const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptFromBindingName");
		
		UYHUDWidget_ButtonPrompt_SetPromptFromBindingName_Params params {};
		params.index = index;
		params.binding = binding;
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A3A0
	 * 		Name   -> Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptDisabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Disabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ButtonPrompt::SetPromptDisabled(int32_t index, bool Disabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptDisabled");
		
		UYHUDWidget_ButtonPrompt_SetPromptDisabled_Params params {};
		params.index = index;
		params.Disabled = Disabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A320
	 * 		Name   -> Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ButtonPrompt::SetPromptCount(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ButtonPrompt.SetPromptCount");
		
		UYHUDWidget_ButtonPrompt_SetPromptCount_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A1C0
	 * 		Name   -> Function DreadGame.YHUDWidget_ButtonPrompt.SetPrompt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYPS4ButtonIcon                                    icon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsePadding                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ButtonPrompt::SetPrompt(int32_t index, EYPS4ButtonIcon icon, const class FString& Text, bool bUsePadding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ButtonPrompt.SetPrompt");
		
		UYHUDWidget_ButtonPrompt_SetPrompt_Params params {};
		params.index = index;
		params.icon = icon;
		params.Text = Text;
		params.bUsePadding = bUsePadding;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ButtonPrompt.BP_UsePaddingForIndex
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsePadding                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ButtonPrompt::BP_UsePaddingForIndex(int32_t index, bool bUsePadding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ButtonPrompt.BP_UsePaddingForIndex");
		
		UYHUDWidget_ButtonPrompt_BP_UsePaddingForIndex_Params params {};
		params.index = index;
		params.bUsePadding = bUsePadding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ButtonPrompt.BP_AddPrompt
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class UYHUDWidget_Legend*                          newPrompt                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ButtonPrompt::BP_AddPrompt(class UYHUDWidget_Legend** newPrompt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ButtonPrompt.BP_AddPrompt");
		
		UYHUDWidget_ButtonPrompt_BP_AddPrompt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (newPrompt != nullptr)
			*newPrompt = params.newPrompt;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ButtonPrompt.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ButtonPrompt::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ButtonPrompt");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781150
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.ToggleComWindowTransmission
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::ToggleComWindowTransmission(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.ToggleComWindowTransmission");
		
		UYHUDWidget_ComWindow_ToggleComWindowTransmission_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776500
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.SetComWindowTitle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      title                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::SetComWindowTitle(const class FString& title)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.SetComWindowTitle");
		
		UYHUDWidget_ComWindow_SetComWindowTitle_Params params {};
		params.title = title;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776480
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.SetComWindowTextureResource
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::SetComWindowTextureResource(class UTexture* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.SetComWindowTextureResource");
		
		UYHUDWidget_ComWindow_SetComWindowTextureResource_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007763E0
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.SetComWindowSubtitle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      subtitle                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::SetComWindowSubtitle(const class FString& subtitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.SetComWindowSubtitle");
		
		UYHUDWidget_ComWindow_SetComWindowSubtitle_Params params {};
		params.subtitle = subtitle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.BP_EventShowTransmission
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::BP_EventShowTransmission(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.BP_EventShowTransmission");
		
		UYHUDWidget_ComWindow_BP_EventShowTransmission_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.BP_EventSetWindowImageTexture
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::BP_EventSetWindowImageTexture(class UTexture* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.BP_EventSetWindowImageTexture");
		
		UYHUDWidget_ComWindow_BP_EventSetWindowImageTexture_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.BP_EventSetTitle
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      title                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::BP_EventSetTitle(const class FString& title)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.BP_EventSetTitle");
		
		UYHUDWidget_ComWindow_BP_EventSetTitle_Params params {};
		params.title = title;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ComWindow.BP_EventSetSubtitle
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      subtitle                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ComWindow::BP_EventSetSubtitle(const class FString& subtitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ComWindow.BP_EventSetSubtitle");
		
		UYHUDWidget_ComWindow_BP_EventSetSubtitle_Params params {};
		params.subtitle = subtitle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ComWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ComWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ComWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B1D0
	 * 		Name   -> Function DreadGame.YHUDWidget_OrbitMenu.SetSpectatedPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_OrbitMenu::SetSpectatedPlayer(int32_t PlayerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_OrbitMenu.SetSpectatedPlayer");
		
		UYHUDWidget_OrbitMenu_SetSpectatedPlayer_Params params {};
		params.PlayerIndex = PlayerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A6C0
	 * 		Name   -> Function DreadGame.YHUDWidget_OrbitMenu.SetReadyState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsReady                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_OrbitMenu::SetReadyState(bool bIsReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_OrbitMenu.SetReadyState");
		
		UYHUDWidget_OrbitMenu_SetReadyState_Params params {};
		params.bIsReady = bIsReady;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778020
	 * 		Name   -> Function DreadGame.YHUDWidget_OrbitMenu.SetHandlingInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsHandlingInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UYHUDWidget_OrbitMenu::SetHandlingInput(bool bIsHandlingInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_OrbitMenu.SetHandlingInput");
		
		UYHUDWidget_OrbitMenu_SetHandlingInput_Params params {};
		params.bIsHandlingInput = bIsHandlingInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E710
	 * 		Name   -> Function DreadGame.YHUDWidget_OrbitMenu.IsFighterSpawn
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool UYHUDWidget_OrbitMenu::IsFighterSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_OrbitMenu.IsFighterSpawn");
		
		UYHUDWidget_OrbitMenu_IsFighterSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_OrbitMenu.BP_SetOrbitReadyState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYOrbitReadyState                                  orbitReadyState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_OrbitMenu::BP_SetOrbitReadyState(EYOrbitReadyState orbitReadyState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_OrbitMenu.BP_SetOrbitReadyState");
		
		UYHUDWidget_OrbitMenu_BP_SetOrbitReadyState_Params params {};
		params.orbitReadyState = orbitReadyState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_OrbitMenu.BP_ForceOrbitIntroAnimationFinished
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_OrbitMenu::BP_ForceOrbitIntroAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_OrbitMenu.BP_ForceOrbitIntroAnimationFinished");
		
		UYHUDWidget_OrbitMenu_BP_ForceOrbitIntroAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_OrbitMenu.BP_ActivateOrbitScreen
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_OrbitMenu::BP_ActivateOrbitScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_OrbitMenu.BP_ActivateOrbitScreen");
		
		UYHUDWidget_OrbitMenu_BP_ActivateOrbitScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_OrbitMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_OrbitMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_OrbitMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_CountdownTimer.BP_SetTimeRemaining
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            secondsRemaining                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        secondsAsText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_CountdownTimer::BP_SetTimeRemaining(int32_t secondsRemaining, const class FText& secondsAsText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_CountdownTimer.BP_SetTimeRemaining");
		
		UYHUDWidget_CountdownTimer_BP_SetTimeRemaining_Params params {};
		params.secondsRemaining = secondsRemaining;
		params.secondsAsText = secondsAsText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_CountdownTimer.BP_SetDescription
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        remainingTimeDescription                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_CountdownTimer::BP_SetDescription(const class FText& remainingTimeDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_CountdownTimer.BP_SetDescription");
		
		UYHUDWidget_CountdownTimer_BP_SetDescription_Params params {};
		params.remainingTimeDescription = remainingTimeDescription;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_CountdownTimer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_CountdownTimer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_CountdownTimer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateRangeIndicator
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYCrosshairRangeType                               rangeType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsFriendly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Crosshair::BP_EventUpdateRangeIndicator(EYCrosshairRangeType rangeType, bool IsFriendly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateRangeIndicator");
		
		UYHUDWidget_Crosshair_BP_EventUpdateRangeIndicator_Params params {};
		params.rangeType = rangeType;
		params.IsFriendly = IsFriendly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdatePrecision
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              precisionFraction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Crosshair::BP_EventUpdatePrecision(float precisionFraction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdatePrecision");
		
		UYHUDWidget_Crosshair_BP_EventUpdatePrecision_Params params {};
		params.precisionFraction = precisionFraction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdatePosition
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              posX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              posY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Crosshair::BP_EventUpdatePosition(float posX, float posY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdatePosition");
		
		UYHUDWidget_Crosshair_BP_EventUpdatePosition_Params params {};
		params.posX = posX;
		params.posY = posY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateLineToCenter
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              fromX                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              fromY                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Crosshair::BP_EventUpdateLineToCenter(float fromX, float fromY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateLineToCenter");
		
		UYHUDWidget_Crosshair_BP_EventUpdateLineToCenter_Params params {};
		params.fromX = fromX;
		params.fromY = fromY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateJuice
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_Crosshair::BP_EventUpdateJuice()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateJuice");
		
		UYHUDWidget_Crosshair_BP_EventUpdateJuice_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateHit
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYHitIndicatorType                                 flashType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Crosshair::BP_EventUpdateHit(EYHitIndicatorType flashType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Crosshair.BP_EventUpdateHit");
		
		UYHUDWidget_Crosshair_BP_EventUpdateHit_Params params {};
		params.flashType = flashType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_Crosshair.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_Crosshair::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_Crosshair");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ED00
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedback.IsIdle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYHUDWidget_DamageFeedback::IsIdle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedback.IsIdle");
		
		UYHUDWidget_DamageFeedback_IsIdle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759DA0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedback.GetTimeAlive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYHUDWidget_DamageFeedback::GetTimeAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedback.GetTimeAlive");
		
		UYHUDWidget_DamageFeedback_GetTimeAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007526A0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedback.GetHitActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AActor* UYHUDWidget_DamageFeedback::GetHitActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedback.GetHitActor");
		
		UYHUDWidget_DamageFeedback_GetHitActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00749860
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedback.Deactivate
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYHUDWidget_DamageFeedback::Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedback.Deactivate");
		
		UYHUDWidget_DamageFeedback_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedback.BP_Update
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_DamageFeedback::BP_Update()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedback.BP_Update");
		
		UYHUDWidget_DamageFeedback_BP_Update_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedback.BP_OnHandleDamage
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_DamageFeedback::BP_OnHandleDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedback.BP_OnHandleDamage");
		
		UYHUDWidget_DamageFeedback_BP_OnHandleDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedback.BP_Deactivate
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_DamageFeedback::BP_Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedback.BP_Deactivate");
		
		UYHUDWidget_DamageFeedback_BP_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DamageFeedback.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DamageFeedback::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DamageFeedback");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DamageFeedbackManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DamageFeedbackManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DamageFeedbackManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075ED20
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.IsIdle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_DamageFeedbackNumber::IsIdle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.IsIdle");
		
		UYHUDWidget_DamageFeedbackNumber_IsIdle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DEC0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.IsAbilityNumber
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UYHUDWidget_DamageFeedbackNumber::IsAbilityNumber()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.IsAbilityNumber");
		
		UYHUDWidget_DamageFeedbackNumber_IsAbilityNumber_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759DC0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetTimeAlivePercentage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_DamageFeedbackNumber::GetTimeAlivePercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetTimeAlivePercentage");
		
		UYHUDWidget_DamageFeedbackNumber_GetTimeAlivePercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007542D0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetMinWidgetScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_DamageFeedbackNumber::GetMinWidgetScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetMinWidgetScale");
		
		UYHUDWidget_DamageFeedbackNumber_GetMinWidgetScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00754030
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetMaxMovementDuration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_DamageFeedbackNumber::GetMaxMovementDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetMaxMovementDuration");
		
		UYHUDWidget_DamageFeedbackNumber_GetMaxMovementDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753ED0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetMaxDamageWidgetSize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_DamageFeedbackNumber::GetMaxDamageWidgetSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetMaxDamageWidgetSize");
		
		UYHUDWidget_DamageFeedbackNumber_GetMaxDamageWidgetSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007539E0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetLifeTimeAfterDamage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_DamageFeedbackNumber::GetLifeTimeAfterDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetLifeTimeAfterDamage");
		
		UYHUDWidget_DamageFeedbackNumber_GetLifeTimeAfterDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752C00
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetInitialOffsetLength
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_DamageFeedbackNumber::GetInitialOffsetLength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetInitialOffsetLength");
		
		UYHUDWidget_DamageFeedbackNumber_GetInitialOffsetLength_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DF80
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetBounceForce
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UYHUDWidget_DamageFeedbackNumber::GetBounceForce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.GetBounceForce");
		
		UYHUDWidget_DamageFeedbackNumber_GetBounceForce_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_Update
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_DamageFeedbackNumber::BP_Update()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_Update");
		
		UYHUDWidget_DamageFeedbackNumber_BP_Update_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_SetFont
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_DamageFeedbackNumber::BP_SetFont()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_SetFont");
		
		UYHUDWidget_DamageFeedbackNumber_BP_SetFont_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_OnHandleDamage
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        newDmgNumber                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              relativeSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Color                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DamageFeedbackNumber::BP_OnHandleDamage(const class FText& newDmgNumber, float relativeSize, const struct FLinearColor& Color)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_OnHandleDamage");
		
		UYHUDWidget_DamageFeedbackNumber_BP_OnHandleDamage_Params params {};
		params.newDmgNumber = newDmgNumber;
		params.relativeSize = relativeSize;
		params.Color = Color;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_Activate
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        newDmgNumber                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              relativeSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Color                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DamageFeedbackNumber::BP_Activate(const class FText& newDmgNumber, float relativeSize, const struct FLinearColor& Color)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageFeedbackNumber.BP_Activate");
		
		UYHUDWidget_DamageFeedbackNumber_BP_Activate_Params params {};
		params.newDmgNumber = newDmgNumber;
		params.relativeSize = relativeSize;
		params.Color = Color;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DamageFeedbackNumber.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DamageFeedbackNumber::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DamageFeedbackNumber");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageIndicators.BP_EventUpdateDamageIndicators
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_DamageIndicators::BP_EventUpdateDamageIndicators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageIndicators.BP_EventUpdateDamageIndicators");
		
		UYHUDWidget_DamageIndicators_BP_EventUpdateDamageIndicators_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DamageIndicators.BP_EventApplyDamageOnIndicator
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            SegmentIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DamageIndicators::BP_EventApplyDamageOnIndicator(int32_t SegmentIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DamageIndicators.BP_EventApplyDamageOnIndicator");
		
		UYHUDWidget_DamageIndicators_BP_EventApplyDamageOnIndicator_Params params {};
		params.SegmentIndex = SegmentIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DamageIndicators.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DamageIndicators::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DamageIndicators");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecap.BP_EventShowDeathRecap
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               showDeathRecap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DeathRecap::BP_EventShowDeathRecap(bool showDeathRecap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecap.BP_EventShowDeathRecap");
		
		UYHUDWidget_DeathRecap_BP_EventShowDeathRecap_Params params {};
		params.showDeathRecap = showDeathRecap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecap.BP_EventShowAssistContent
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               showAssistContent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DeathRecap::BP_EventShowAssistContent(bool showAssistContent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecap.BP_EventShowAssistContent");
		
		UYHUDWidget_DeathRecap_BP_EventShowAssistContent_Params params {};
		params.showAssistContent = showAssistContent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DeathRecap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DeathRecap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DeathRecap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetShipData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  shipClassIcon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  shipImage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DeathRecapEntry::BP_EventSetShipData(class UTexture2D* shipClassIcon, class UTexture2D* shipImage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetShipData");
		
		UYHUDWidget_DeathRecapEntry_BP_EventSetShipData_Params params {};
		params.shipClassIcon = shipClassIcon;
		params.shipImage = shipImage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetIsKillingBlowSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isKillingBlowSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DeathRecapEntry::BP_EventSetIsKillingBlowSlot(bool isKillingBlowSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetIsKillingBlowSlot");
		
		UYHUDWidget_DeathRecapEntry_BP_EventSetIsKillingBlowSlot_Params params {};
		params.isKillingBlowSlot = isKillingBlowSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetDamageSourceData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      damageSourceName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  damageSourceIcon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  sourceCategoryIcon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            sourceTier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DeathRecapEntry::BP_EventSetDamageSourceData(const class FString& damageSourceName, class UTexture2D* damageSourceIcon, class UTexture2D* sourceCategoryIcon, int32_t sourceTier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetDamageSourceData");
		
		UYHUDWidget_DeathRecapEntry_BP_EventSetDamageSourceData_Params params {};
		params.damageSourceName = damageSourceName;
		params.damageSourceIcon = damageSourceIcon;
		params.sourceCategoryIcon = sourceCategoryIcon;
		params.sourceTier = sourceTier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetDamageAmount
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DeathRecapEntry::BP_EventSetDamageAmount(int32_t DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetDamageAmount");
		
		UYHUDWidget_DeathRecapEntry_BP_EventSetDamageAmount_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetCaptainData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      captainName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  captainIcon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_DeathRecapEntry::BP_EventSetCaptainData(const class FString& captainName, class UTexture2D* captainIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventSetCaptainData");
		
		UYHUDWidget_DeathRecapEntry_BP_EventSetCaptainData_Params params {};
		params.captainName = captainName;
		params.captainIcon = captainIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventClearEntry
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_DeathRecapEntry::BP_EventClearEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_DeathRecapEntry.BP_EventClearEntry");
		
		UYHUDWidget_DeathRecapEntry_BP_EventClearEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DeathRecapEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DeathRecapEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DeathRecapEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_DmgIndicatorSegment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_DmgIndicatorSegment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_DmgIndicatorSegment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C1A0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.SetToggleEnergyWheel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            currentEnergyWheelSelection                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::SetToggleEnergyWheel(int32_t currentEnergyWheelSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.SetToggleEnergyWheel");
		
		UYHUDWidget_EnergyWheelSelector_SetToggleEnergyWheel_Params params {};
		params.currentEnergyWheelSelection = currentEnergyWheelSelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778200
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.SetHighlighted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               isHighlighted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            EnergyWheelSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               shouldForceVisibilityChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::SetHighlighted(bool isHighlighted, int32_t EnergyWheelSelection, bool shouldForceVisibilityChange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.SetHighlighted");
		
		UYHUDWidget_EnergyWheelSelector_SetHighlighted_Params params {};
		params.isHighlighted = isHighlighted;
		params.EnergyWheelSelection = EnergyWheelSelection;
		params.shouldForceVisibilityChange = shouldForceVisibilityChange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777120
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.SetEnergyWheelSelection
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            EnergyWheelSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               doAnimate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::SetEnergyWheelSelection(int32_t EnergyWheelSelection, bool doAnimate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.SetEnergyWheelSelection");
		
		UYHUDWidget_EnergyWheelSelector_SetEnergyWheelSelection_Params params {};
		params.EnergyWheelSelection = EnergyWheelSelection;
		params.doAnimate = doAnimate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776240
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.SetColoredElementsFor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UImage*>                              elements                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		EYUIColorStyle                                     activeColorStyle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUIColorStyle                                     inactiveColorStyle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::SetColoredElementsFor(EYEnergyWheelSelection Selection, TArray<class UImage*> elements, EYUIColorStyle activeColorStyle, EYUIColorStyle inactiveColorStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.SetColoredElementsFor");
		
		UYHUDWidget_EnergyWheelSelector_SetColoredElementsFor_Params params {};
		params.Selection = Selection;
		params.elements = elements;
		params.activeColorStyle = activeColorStyle;
		params.inactiveColorStyle = inactiveColorStyle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775AA0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.SetAnimationsFor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidgetAnimation*                            activateAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidgetAnimation*                            deactivateAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::SetAnimationsFor(EYEnergyWheelSelection Selection, class UWidgetAnimation* activateAnim, class UWidgetAnimation* deactivateAnim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.SetAnimationsFor");
		
		UYHUDWidget_EnergyWheelSelector_SetAnimationsFor_Params params {};
		params.Selection = Selection;
		params.activateAnim = activateAnim;
		params.deactivateAnim = deactivateAnim;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007759B0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.SetAlphaElementFor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UImage*                                      element                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::SetAlphaElementFor(EYEnergyWheelSelection Selection, class UImage* element)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.SetAlphaElementFor");
		
		UYHUDWidget_EnergyWheelSelector_SetAlphaElementFor_Params params {};
		params.Selection = Selection;
		params.element = element;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FBF0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.ResetEnergyWheelSelection
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_EnergyWheelSelector::ResetEnergyWheelSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.ResetEnergyWheelSelection");
		
		UYHUDWidget_EnergyWheelSelector_ResetEnergyWheelSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C620
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.ForceCloseEnergyWheel
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_EnergyWheelSelector::ForceCloseEnergyWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.ForceCloseEnergyWheel");
		
		UYHUDWidget_EnergyWheelSelector_ForceCloseEnergyWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_SetHighlighted
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isHighlighted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            EnergyWheelSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::BP_SetHighlighted(bool isHighlighted, int32_t EnergyWheelSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_SetHighlighted");
		
		UYHUDWidget_EnergyWheelSelector_BP_SetHighlighted_Params params {};
		params.isHighlighted = isHighlighted;
		params.EnergyWheelSelection = EnergyWheelSelection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_OnWheelSelection
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            EnergyWheelSelection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            numLoops                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::BP_OnWheelSelection(int32_t EnergyWheelSelection, int32_t numLoops)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_OnWheelSelection");
		
		UYHUDWidget_EnergyWheelSelector_BP_OnWheelSelection_Params params {};
		params.EnergyWheelSelection = EnergyWheelSelection;
		params.numLoops = numLoops;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_OnWheelOpened
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UYHUDWidget_EnergyWheelSelector::BP_OnWheelOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_OnWheelOpened");
		
		UYHUDWidget_EnergyWheelSelector_BP_OnWheelOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_OnWheelClosed
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               shouldForceClose                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_EnergyWheelSelector::BP_OnWheelClosed(bool shouldForceClose)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_EnergyWheelSelector.BP_OnWheelClosed");
		
		UYHUDWidget_EnergyWheelSelector_BP_OnWheelClosed_Params params {};
		params.shouldForceClose = shouldForceClose;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_EnergyWheelSelector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_EnergyWheelSelector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_EnergyWheelSelector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_FeedbackAnimation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_FeedbackAnimation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_FeedbackAnimation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_FeedbackAnimationManager.BP_EventStopAllAnimations
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_FeedbackAnimationManager::BP_EventStopAllAnimations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_FeedbackAnimationManager.BP_EventStopAllAnimations");
		
		UYHUDWidget_FeedbackAnimationManager_BP_EventStopAllAnimations_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_FeedbackAnimationManager.BP_EventPlayAnimation
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		EYFeedbackAnimationType                            animationType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<EYBuffType>                                 buffIcons                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      displayText                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              buffFeedbackAnimationDisplayTime                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_FeedbackAnimationManager::BP_EventPlayAnimation(EYFeedbackAnimationType animationType, TArray<EYBuffType> buffIcons, const class FString& displayText, float buffFeedbackAnimationDisplayTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_FeedbackAnimationManager.BP_EventPlayAnimation");
		
		UYHUDWidget_FeedbackAnimationManager_BP_EventPlayAnimation_Params params {};
		params.animationType = animationType;
		params.buffIcons = buffIcons;
		params.displayText = displayText;
		params.buffFeedbackAnimationDisplayTime = buffFeedbackAnimationDisplayTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_FeedbackAnimationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_FeedbackAnimationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_FeedbackAnimationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeDeathmatch.BP_EventSetTeamState
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            allyPercent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            enemyPercent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            allyValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            enemyValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeDeathmatch::BP_EventSetTeamState(int32_t allyPercent, int32_t enemyPercent, int32_t allyValue, int32_t enemyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeDeathmatch.BP_EventSetTeamState");
		
		UYHUDWidget_GameModeDeathmatch_BP_EventSetTeamState_Params params {};
		params.allyPercent = allyPercent;
		params.enemyPercent = enemyPercent;
		params.allyValue = allyValue;
		params.enemyValue = enemyValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModeDeathmatch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModeDeathmatch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModeDeathmatch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeHavoc.BP_SetWaveProgress
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            currentWaveNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            enemiesNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            enemiesKilled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            numberOfRelevantEnemiesSpawnedFromBridgeheads              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeHavoc::BP_SetWaveProgress(int32_t currentWaveNumber, int32_t enemiesNum, int32_t enemiesKilled, int32_t numberOfRelevantEnemiesSpawnedFromBridgeheads)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeHavoc.BP_SetWaveProgress");
		
		UYHUDWidget_GameModeHavoc_BP_SetWaveProgress_Params params {};
		params.currentWaveNumber = currentWaveNumber;
		params.enemiesNum = enemiesNum;
		params.enemiesKilled = enemiesKilled;
		params.numberOfRelevantEnemiesSpawnedFromBridgeheads = numberOfRelevantEnemiesSpawnedFromBridgeheads;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeHavoc.BP_SetTeamState
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<int32_t>                                    playeShipClasses                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<bool>                                       wasPlayerEliminated                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeHavoc::BP_SetTeamState(TArray<int32_t> playeShipClasses, TArray<bool> wasPlayerEliminated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeHavoc.BP_SetTeamState");
		
		UYHUDWidget_GameModeHavoc_BP_SetTeamState_Params params {};
		params.playeShipClasses = playeShipClasses;
		params.wasPlayerEliminated = wasPlayerEliminated;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeHavoc.BP_SetActiveWaveModifiers
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FYUIHavocModifier                           modifier1                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FYUIHavocModifier                           modifier2                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeHavoc::BP_SetActiveWaveModifiers(const struct FYUIHavocModifier& modifier1, const struct FYUIHavocModifier& modifier2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeHavoc.BP_SetActiveWaveModifiers");
		
		UYHUDWidget_GameModeHavoc_BP_SetActiveWaveModifiers_Params params {};
		params.modifier1 = modifier1;
		params.modifier2 = modifier2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModeHavoc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModeHavoc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModeHavoc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764720
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeHavoc_BossHealth.OnLinkedPawnHealthModified
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeHavoc_BossHealth::OnLinkedPawnHealthModified(float newHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeHavoc_BossHealth.OnLinkedPawnHealthModified");
		
		UYHUDWidget_GameModeHavoc_BossHealth_OnLinkedPawnHealthModified_Params params {};
		params.newHealth = newHealth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00764700
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeHavoc_BossHealth.OnLinkedPawnDied
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYHUDWidget_GameModeHavoc_BossHealth::OnLinkedPawnDied()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeHavoc_BossHealth.OnLinkedPawnDied");
		
		UYHUDWidget_GameModeHavoc_BossHealth_OnLinkedPawnDied_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModeHavoc_BossHealth.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModeHavoc_BossHealth::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModeHavoc_BossHealth");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeHeader.BP_OnModeChanged
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        modeName                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeHeader::BP_OnModeChanged(const class FText& modeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeHeader.BP_OnModeChanged");
		
		UYHUDWidget_GameModeHeader_BP_OnModeChanged_Params params {};
		params.modeName = modeName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeHeader.BP_OnMapChanged
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        mapName                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeHeader::BP_OnMapChanged(const class FText& mapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeHeader.BP_OnMapChanged");
		
		UYHUDWidget_GameModeHeader_BP_OnMapChanged_Params params {};
		params.mapName = mapName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModeHeader.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModeHeader::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModeHeader");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModeHorde.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModeHorde::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModeHorde");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeManager.BP_EventSetTimeHeadline
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      headlineText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeManager::BP_EventSetTimeHeadline(const class FString& headlineText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeManager.BP_EventSetTimeHeadline");
		
		UYHUDWidget_GameModeManager_BP_EventSetTimeHeadline_Params params {};
		params.headlineText = headlineText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeManager.BP_EventSetTime
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeManager::BP_EventSetTime(int32_t Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeManager.BP_EventSetTime");
		
		UYHUDWidget_GameModeManager_BP_EventSetTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780AB0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModePanelBase.SetTime
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModePanelBase::SetTime(int32_t Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModePanelBase.SetTime");
		
		UYHUDWidget_GameModePanelBase_SetTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007780B0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModePanelBase.SetHeader
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Header                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModePanelBase::SetHeader(const class FString& Header)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModePanelBase.SetHeader");
		
		UYHUDWidget_GameModePanelBase_SetHeader_Params params {};
		params.Header = Header;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetTime
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModePanelBase::BP_SetTime(int32_t Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetTime");
		
		UYHUDWidget_GameModePanelBase_BP_SetTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetHeaderText
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      Header                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModePanelBase::BP_SetHeaderText(const class FString& Header)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetHeaderText");
		
		UYHUDWidget_GameModePanelBase_BP_SetHeaderText_Params params {};
		params.Header = Header;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetGameModeRoundResult
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModePanelBase::BP_SetGameModeRoundResult(int32_t Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetGameModeRoundResult");
		
		UYHUDWidget_GameModePanelBase_BP_SetGameModeRoundResult_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetGameModeRound
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Round                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModePanelBase::BP_SetGameModeRound(int32_t Round)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModePanelBase.BP_SetGameModeRound");
		
		UYHUDWidget_GameModePanelBase_BP_SetGameModeRound_Params params {};
		params.Round = Round;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModePanelBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModePanelBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModePanelBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeTeamElim.BP_SetScore
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsFriendly                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeTeamElim::BP_SetScore(bool bIsFriendly, int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeTeamElim.BP_SetScore");
		
		UYHUDWidget_GameModeTeamElim_BP_SetScore_Params params {};
		params.bIsFriendly = bIsFriendly;
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_GameModeTeamElim.BP_SetIconTexture
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsFriendly                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            iconIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_GameModeTeamElim::BP_SetIconTexture(bool bIsFriendly, int32_t iconIndex, class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_GameModeTeamElim.BP_SetIconTexture");
		
		UYHUDWidget_GameModeTeamElim_BP_SetIconTexture_Params params {};
		params.bIsFriendly = bIsFriendly;
		params.iconIndex = iconIndex;
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_GameModeTeamElim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_GameModeTeamElim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_GameModeTeamElim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077ACF0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu.SetSelectedUpgrade
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu::SetSelectedUpgrade(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu.SetSelectedUpgrade");
		
		UYHUDWidget_HavocProgressionMenu_SetSelectedUpgrade_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076E680
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu.ReadyUpFromBlueprint
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYHUDWidget_HavocProgressionMenu::ReadyUpFromBlueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu.ReadyUpFromBlueprint");
		
		UYHUDWidget_HavocProgressionMenu_ReadyUpFromBlueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu.BP_EventSetPlayerIsReadyForNextWave
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsReady                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu::BP_EventSetPlayerIsReadyForNextWave(bool IsReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu.BP_EventSetPlayerIsReadyForNextWave");
		
		UYHUDWidget_HavocProgressionMenu_BP_EventSetPlayerIsReadyForNextWave_Params params {};
		params.IsReady = IsReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu.BP_EventSetAvailableXp
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            availableXp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu::BP_EventSetAvailableXp(int32_t availableXp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu.BP_EventSetAvailableXp");
		
		UYHUDWidget_HavocProgressionMenu_BP_EventSetAvailableXp_Params params {};
		params.availableXp = availableXp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu.BP_EventSelectedUpgradeStateChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYHavocUpgradeState                                selectedUpgradeState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu::BP_EventSelectedUpgradeStateChanged(EYHavocUpgradeState selectedUpgradeState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu.BP_EventSelectedUpgradeStateChanged");
		
		UYHUDWidget_HavocProgressionMenu_BP_EventSelectedUpgradeStateChanged_Params params {};
		params.selectedUpgradeState = selectedUpgradeState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D650
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu.ActivateSelectedUpgrade
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu::ActivateSelectedUpgrade(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu.ActivateSelectedUpgrade");
		
		UYHUDWidget_HavocProgressionMenu_ActivateSelectedUpgrade_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HavocProgressionMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HavocProgressionMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HavocProgressionMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_AcquiredBoostItem.OnUpdateIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  iconPath                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu_AcquiredBoostItem::OnUpdateIcon(class UTexture2D* iconPath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_AcquiredBoostItem.OnUpdateIcon");
		
		UYHUDWidget_HavocProgressionMenu_AcquiredBoostItem_OnUpdateIcon_Params params {};
		params.iconPath = iconPath;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_AcquiredBoostItem.OnAmountChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu_AcquiredBoostItem::OnAmountChanged(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_AcquiredBoostItem.OnAmountChanged");
		
		UYHUDWidget_HavocProgressionMenu_AcquiredBoostItem_OnAmountChanged_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HavocProgressionMenu_AcquiredBoostItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HavocProgressionMenu_AcquiredBoostItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HavocProgressionMenu_AcquiredBoostItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HavocProgressionMenu_AcquiredBoostsList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HavocProgressionMenu_AcquiredBoostsList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HavocProgressionMenu_AcquiredBoostsList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_UpgradeItem.BP_EventSetHighlighted
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isHighlighted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu_UpgradeItem::BP_EventSetHighlighted(bool isHighlighted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_UpgradeItem.BP_EventSetHighlighted");
		
		UYHUDWidget_HavocProgressionMenu_UpgradeItem_BP_EventSetHighlighted_Params params {};
		params.isHighlighted = isHighlighted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_UpgradeItem.BP_EventSetData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FYUIHavocUpgrade                            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu_UpgradeItem::BP_EventSetData(const struct FYUIHavocUpgrade& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_UpgradeItem.BP_EventSetData");
		
		UYHUDWidget_HavocProgressionMenu_UpgradeItem_BP_EventSetData_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HavocProgressionMenu_UpgradeItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HavocProgressionMenu_UpgradeItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HavocProgressionMenu_UpgradeItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_UpgradesList.BP_InitButtonEventDelegates
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_HavocProgressionMenu_UpgradesList::BP_InitButtonEventDelegates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_UpgradesList.BP_InitButtonEventDelegates");
		
		UYHUDWidget_HavocProgressionMenu_UpgradesList_BP_InitButtonEventDelegates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HavocProgressionMenu_UpgradesList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HavocProgressionMenu_UpgradesList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HavocProgressionMenu_UpgradesList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_SetWaveNumber
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            waveNumber                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isBossWave                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu_WaveInfo::BP_SetWaveNumber(int32_t waveNumber, bool isBossWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_SetWaveNumber");
		
		UYHUDWidget_HavocProgressionMenu_WaveInfo_BP_SetWaveNumber_Params params {};
		params.waveNumber = waveNumber;
		params.isBossWave = isBossWave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_SetTimeUntilNextWave
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            secondsToNextWave                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu_WaveInfo::BP_SetTimeUntilNextWave(int32_t secondsToNextWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_SetTimeUntilNextWave");
		
		UYHUDWidget_HavocProgressionMenu_WaveInfo_BP_SetTimeUntilNextWave_Params params {};
		params.secondsToNextWave = secondsToNextWave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_SetPermanentEnemyModifiers
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            damageBoostValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            healthBoostValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocProgressionMenu_WaveInfo::BP_SetPermanentEnemyModifiers(int32_t damageBoostValue, int32_t healthBoostValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_SetPermanentEnemyModifiers");
		
		UYHUDWidget_HavocProgressionMenu_WaveInfo_BP_SetPermanentEnemyModifiers_Params params {};
		params.damageBoostValue = damageBoostValue;
		params.healthBoostValue = healthBoostValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742060
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_GetTimeLeftHideTimerValue
	 * 		Flags  -> (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
	 */
	int32_t UYHUDWidget_HavocProgressionMenu_WaveInfo::STATIC_BP_GetTimeLeftHideTimerValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo.BP_GetTimeLeftHideTimerValue");
		
		UYHUDWidget_HavocProgressionMenu_WaveInfo_BP_GetTimeLeftHideTimerValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HavocProgressionMenu_WaveInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HavocProgressionMenu_WaveInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HavocProgressionMenu_WaveInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HavocWaveModifier.BP_SetActiveModifierData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FYUIHavocModifier                           modifierData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HavocWaveModifier::BP_SetActiveModifierData(const struct FYUIHavocModifier& modifierData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HavocWaveModifier.BP_SetActiveModifierData");
		
		UYHUDWidget_HavocWaveModifier_BP_SetActiveModifierData_Params params {};
		params.modifierData = modifierData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HavocWaveModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HavocWaveModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HavocWaveModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateZoom
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isZoomed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventUpdateZoom(bool isZoomed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateZoom");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventUpdateZoom_Params params {};
		params.isZoomed = isZoomed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateReloading
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            weaponIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              percentageRemaining                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventUpdateReloading(int32_t weaponIndex, float percentageRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateReloading");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventUpdateReloading_Params params {};
		params.weaponIndex = weaponIndex;
		params.percentageRemaining = percentageRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateHealth
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Health                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              percent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventUpdateHealth(float Health, float percent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateHealth");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventUpdateHealth_Params params {};
		params.Health = Health;
		params.percent = percent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateEnergy
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Energy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              percent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventUpdateEnergy(float Energy, float percent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateEnergy");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventUpdateEnergy_Params params {};
		params.Energy = Energy;
		params.percent = percent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateAmmo
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            weaponIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ammo                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              percent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventUpdateAmmo(int32_t weaponIndex, float ammo, float percent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventUpdateAmmo");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventUpdateAmmo_Params params {};
		params.weaponIndex = weaponIndex;
		params.ammo = ammo;
		params.percent = percent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetWeaponCount
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            weaponCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventSetWeaponCount(int32_t weaponCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetWeaponCount");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventSetWeaponCount_Params params {};
		params.weaponCount = weaponCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetReloading
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            weaponIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsReloading                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventSetReloading(int32_t weaponIndex, bool IsReloading)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetReloading");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventSetReloading_Params params {};
		params.weaponIndex = weaponIndex;
		params.IsReloading = IsReloading;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetIsFighter
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsFighter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventSetIsFighter(bool bIsFighter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetIsFighter");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventSetIsFighter_Params params {};
		params.bIsFighter = bIsFighter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetInfiniteAmmoState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            weaponIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isInfinite                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventSetInfiniteAmmoState(int32_t weaponIndex, bool isInfinite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetInfiniteAmmoState");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventSetInfiniteAmmoState_Params params {};
		params.weaponIndex = weaponIndex;
		params.isInfinite = isInfinite;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetEnergyWheelSelection
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             energyWheelType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventSetEnergyWheelSelection(EYEnergyWheelSelection energyWheelType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetEnergyWheelSelection");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventSetEnergyWheelSelection_Params params {};
		params.energyWheelType = energyWheelType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetActiveWeapon
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            weaponIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      weaponName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventSetActiveWeapon(int32_t weaponIndex, const class FString& weaponName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventSetActiveWeapon");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventSetActiveWeapon_Params params {};
		params.weaponIndex = weaponIndex;
		params.weaponName = weaponName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventFireWeapon
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_HealthEnergyAmmoBars::BP_EventFireWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HealthEnergyAmmoBars.BP_EventFireWeapon");
		
		UYHUDWidget_HealthEnergyAmmoBars_BP_EventFireWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HealthEnergyAmmoBars.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HealthEnergyAmmoBars::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HealthEnergyAmmoBars");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HordeWaveCompleted.BP_SetData
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            waveNumber                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            waveTimeSeconds                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            timeBonusXp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            waveXp                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            totalXp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HordeWaveCompleted::BP_SetData(int32_t waveNumber, int32_t waveTimeSeconds, int32_t timeBonusXp, int32_t waveXp, int32_t totalXp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HordeWaveCompleted.BP_SetData");
		
		UYHUDWidget_HordeWaveCompleted_BP_SetData_Params params {};
		params.waveNumber = waveNumber;
		params.waveTimeSeconds = waveTimeSeconds;
		params.timeBonusXp = timeBonusXp;
		params.waveXp = waveXp;
		params.totalXp = totalXp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HordeWaveCompleted.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HordeWaveCompleted::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HordeWaveCompleted");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F4C0
	 * 		Name   -> Function DreadGame.YHUDWidget_HudHelperOverlay.RequestActionNameDisplayStrings
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      ActionName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FText> UYHUDWidget_HudHelperOverlay::RequestActionNameDisplayStrings(const class FString& ActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HudHelperOverlay.RequestActionNameDisplayStrings");
		
		UYHUDWidget_HudHelperOverlay_RequestActionNameDisplayStrings_Params params {};
		params.ActionName = ActionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HudHelperOverlay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HudHelperOverlay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HudHelperOverlay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00779110
	 * 		Name   -> Function DreadGame.YHUDWidget_HUDNotificationPopup.SetNotificationColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      inColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HUDNotificationPopup::SetNotificationColor(const struct FColor& inColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HUDNotificationPopup.SetNotificationColor");
		
		UYHUDWidget_HUDNotificationPopup_SetNotificationColor_Params params {};
		params.inColor = inColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748670
	 * 		Name   -> Function DreadGame.YHUDWidget_HUDNotificationPopup.CloseNotification
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_HUDNotificationPopup::CloseNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HUDNotificationPopup.CloseNotification");
		
		UYHUDWidget_HUDNotificationPopup_CloseNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HUDNotificationPopup.BP_CloseNotification
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_HUDNotificationPopup::BP_CloseNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HUDNotificationPopup.BP_CloseNotification");
		
		UYHUDWidget_HUDNotificationPopup_BP_CloseNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_HUDNotificationPopup.BP_ActivateNotification
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        displayText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   screenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HUDNotificationPopup::BP_ActivateNotification(const class FText& displayText, const struct FVector2D& screenPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HUDNotificationPopup.BP_ActivateNotification");
		
		UYHUDWidget_HUDNotificationPopup_BP_ActivateNotification_Params params {};
		params.displayText = displayText;
		params.screenPosition = screenPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D350
	 * 		Name   -> Function DreadGame.YHUDWidget_HUDNotificationPopup.ActivateNotificationAtPosition
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        displayText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   screenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HUDNotificationPopup::ActivateNotificationAtPosition(float duration, const class FText& displayText, const struct FVector2D& screenPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HUDNotificationPopup.ActivateNotificationAtPosition");
		
		UYHUDWidget_HUDNotificationPopup_ActivateNotificationAtPosition_Params params {};
		params.duration = duration;
		params.displayText = displayText;
		params.screenPosition = screenPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D240
	 * 		Name   -> Function DreadGame.YHUDWidget_HUDNotificationPopup.ActivateNotification
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        displayText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_HUDNotificationPopup::ActivateNotification(float duration, const class FText& displayText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_HUDNotificationPopup.ActivateNotification");
		
		UYHUDWidget_HUDNotificationPopup_ActivateNotification_Params params {};
		params.duration = duration;
		params.displayText = displayText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_HUDNotificationPopup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_HUDNotificationPopup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_HUDNotificationPopup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillCard.BP_SetWeaponText
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        weaponText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillCard::BP_SetWeaponText(const class FText& weaponText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillCard.BP_SetWeaponText");
		
		UYHUDWidget_KillCard_BP_SetWeaponText_Params params {};
		params.weaponText = weaponText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillCard.BP_SetWeaponSecondaryIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  weaponSecondaryIcon                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillCard::BP_SetWeaponSecondaryIcon(class UTexture2D* weaponSecondaryIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillCard.BP_SetWeaponSecondaryIcon");
		
		UYHUDWidget_KillCard_BP_SetWeaponSecondaryIcon_Params params {};
		params.weaponSecondaryIcon = weaponSecondaryIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillCard.BP_SetWeaponIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  weaponIcon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillCard::BP_SetWeaponIcon(class UTexture2D* weaponIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillCard.BP_SetWeaponIcon");
		
		UYHUDWidget_KillCard_BP_SetWeaponIcon_Params params {};
		params.weaponIcon = weaponIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillCard.BP_SetShipIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  shipIcon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillCard::BP_SetShipIcon(class UTexture2D* shipIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillCard.BP_SetShipIcon");
		
		UYHUDWidget_KillCard_BP_SetShipIcon_Params params {};
		params.shipIcon = shipIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillCard.BP_SetShipClassIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  shipClassIcon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillCard::BP_SetShipClassIcon(class UTexture2D* shipClassIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillCard.BP_SetShipClassIcon");
		
		UYHUDWidget_KillCard_BP_SetShipClassIcon_Params params {};
		params.shipClassIcon = shipClassIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillCard.BP_SetDamageDealt
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            damageDealt                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillCard::BP_SetDamageDealt(int32_t damageDealt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillCard.BP_SetDamageDealt");
		
		UYHUDWidget_KillCard_BP_SetDamageDealt_Params params {};
		params.damageDealt = damageDealt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillCard.BP_SetCaptainIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  captainIconTexture                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillCard::BP_SetCaptainIcon(class UTexture2D* captainIconTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillCard.BP_SetCaptainIcon");
		
		UYHUDWidget_KillCard_BP_SetCaptainIcon_Params params {};
		params.captainIconTexture = captainIconTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_KillCard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_KillCard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_KillCard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742B80
	 * 		Name   -> Function DreadGame.YHUDWidget_KillTicker.CPP_EventResetKillTicker
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYHUDWidget_KillTicker::CPP_EventResetKillTicker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillTicker.CPP_EventResetKillTicker");
		
		UYHUDWidget_KillTicker_CPP_EventResetKillTicker_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillTicker.BP_EventScrollSlots
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_KillTicker::BP_EventScrollSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillTicker.BP_EventScrollSlots");
		
		UYHUDWidget_KillTicker_BP_EventScrollSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_KillTicker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_KillTicker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_KillTicker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillTickerSlot.BP_EventSetNamesAndTeams
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      killerName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      victimName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isKillerAlly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_KillTickerSlot::BP_EventSetNamesAndTeams(const class FString& killerName, const class FString& victimName, bool isKillerAlly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillTickerSlot.BP_EventSetNamesAndTeams");
		
		UYHUDWidget_KillTickerSlot_BP_EventSetNamesAndTeams_Params params {};
		params.killerName = killerName;
		params.victimName = victimName;
		params.isKillerAlly = isKillerAlly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_KillTickerSlot.BP_EventPlayStartAnimation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_KillTickerSlot::BP_EventPlayStartAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_KillTickerSlot.BP_EventPlayStartAnimation");
		
		UYHUDWidget_KillTickerSlot_BP_EventPlayStartAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_KillTickerSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_KillTickerSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_KillTickerSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007528F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Legend.GetIconForButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		EYPS4ButtonIcon                                    Button                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture* UYHUDWidget_Legend::GetIconForButton(EYPS4ButtonIcon Button)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Legend.GetIconForButton");
		
		UYHUDWidget_Legend_GetIconForButton_Params params {};
		params.Button = Button;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Legend.BP_SetLegend
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		EYPS4ButtonIcon                                    icon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Legend::BP_SetLegend(EYPS4ButtonIcon icon, const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Legend.BP_SetLegend");
		
		UYHUDWidget_Legend_BP_SetLegend_Params params {};
		params.icon = icon;
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Legend.BP_SetDisabledState
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Disabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Legend::BP_SetDisabledState(bool Disabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Legend.BP_SetDisabledState");
		
		UYHUDWidget_Legend_BP_SetDisabledState_Params params {};
		params.Disabled = Disabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_Legend.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_Legend::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_Legend");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnRankIconChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  rankIcon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_LoadoutColumn::BP_OnColumnRankIconChanged(class UTexture2D* rankIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnRankIconChanged");
		
		UYHUDWidget_LoadoutColumn_BP_OnColumnRankIconChanged_Params params {};
		params.rankIcon = rankIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnMainIconChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  mainIcon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_LoadoutColumn::BP_OnColumnMainIconChanged(class UTexture2D* mainIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnMainIconChanged");
		
		UYHUDWidget_LoadoutColumn_BP_OnColumnMainIconChanged_Params params {};
		params.mainIcon = mainIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnIndexIconChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  typeIcon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_LoadoutColumn::BP_OnColumnIndexIconChanged(class UTexture2D* typeIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnIndexIconChanged");
		
		UYHUDWidget_LoadoutColumn_BP_OnColumnIndexIconChanged_Params params {};
		params.typeIcon = typeIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnDescriptionChanged
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        columnDesc                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_LoadoutColumn::BP_OnColumnDescriptionChanged(const class FText& columnDesc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_LoadoutColumn.BP_OnColumnDescriptionChanged");
		
		UYHUDWidget_LoadoutColumn_BP_OnColumnDescriptionChanged_Params params {};
		params.columnDesc = columnDesc;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_LoadoutColumn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_LoadoutColumn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_LoadoutColumn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMap.BP_EventUpdateViewFrustumAngle
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMap::BP_EventUpdateViewFrustumAngle(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMap.BP_EventUpdateViewFrustumAngle");
		
		UYHUDWidget_MiniMap_BP_EventUpdateViewFrustumAngle_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMap.BP_EventUpdatePlayerPosition
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              playerX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              playerY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMap::BP_EventUpdatePlayerPosition(float playerX, float playerY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMap.BP_EventUpdatePlayerPosition");
		
		UYHUDWidget_MiniMap_BP_EventUpdatePlayerPosition_Params params {};
		params.playerX = playerX;
		params.playerY = playerY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMap.BP_EventUpdateMapRotation
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMap::BP_EventUpdateMapRotation(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMap.BP_EventUpdateMapRotation");
		
		UYHUDWidget_MiniMap_BP_EventUpdateMapRotation_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMap.BP_EventShowViewFrustum
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Show                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMap::BP_EventShowViewFrustum(bool Show)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMap.BP_EventShowViewFrustum");
		
		UYHUDWidget_MiniMap_BP_EventShowViewFrustum_Params params {};
		params.Show = Show;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMap.BP_EventSetCaptainCommandActive
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               active                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMap::BP_EventSetCaptainCommandActive(bool active)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMap.BP_EventSetCaptainCommandActive");
		
		UYHUDWidget_MiniMap_BP_EventSetCaptainCommandActive_Params params {};
		params.active = active;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_MiniMap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_MiniMap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_MiniMap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742B60
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.CPP_EventRemoveSelf
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_MiniMapMarker::CPP_EventRemoveSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.CPP_EventRemoveSelf");
		
		UYHUDWidget_MiniMapMarker_CPP_EventRemoveSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetTombstone
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_MiniMapMarker::BP_EventSetTombstone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetTombstone");
		
		UYHUDWidget_MiniMapMarker_BP_EventSetTombstone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetShipClass
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYMarkerShipType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMapMarker::BP_EventSetShipClass(EYMarkerShipType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetShipClass");
		
		UYHUDWidget_MiniMapMarker_BP_EventSetShipClass_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetMarkerState
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               hasInteractivity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IsActive                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMapMarker::BP_EventSetMarkerState(bool hasInteractivity, bool IsActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetMarkerState");
		
		UYHUDWidget_MiniMapMarker_BP_EventSetMarkerState_Params params {};
		params.hasInteractivity = hasInteractivity;
		params.IsActive = IsActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetMarkerPosition
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              posX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              posY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMapMarker::BP_EventSetMarkerPosition(float posX, float posY, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetMarkerPosition");
		
		UYHUDWidget_MiniMapMarker_BP_EventSetMarkerPosition_Params params {};
		params.posX = posX;
		params.posY = posY;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetMarkerFaction
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYTeam                                             faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMapMarker::BP_EventSetMarkerFaction(EYTeam faction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventSetMarkerFaction");
		
		UYHUDWidget_MiniMapMarker_BP_EventSetMarkerFaction_Params params {};
		params.faction = faction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventResetMarker
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_MiniMapMarker::BP_EventResetMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventResetMarker");
		
		UYHUDWidget_MiniMapMarker_BP_EventResetMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventEnemySpotted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MiniMapMarker::BP_EventEnemySpotted(float FadeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MiniMapMarker.BP_EventEnemySpotted");
		
		UYHUDWidget_MiniMapMarker_BP_EventEnemySpotted_Params params {};
		params.FadeTime = FadeTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_MiniMapMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_MiniMapMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_MiniMapMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MissileMarker.BP_EventUpdateOnScreenState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               onScreen                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MissileMarker::BP_EventUpdateOnScreenState(bool onScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MissileMarker.BP_EventUpdateOnScreenState");
		
		UYHUDWidget_MissileMarker_BP_EventUpdateOnScreenState_Params params {};
		params.onScreen = onScreen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_MissileMarker.BP_EventUpdateOffscreenAngle
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              posX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              posY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_MissileMarker::BP_EventUpdateOffscreenAngle(float posX, float posY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_MissileMarker.BP_EventUpdateOffscreenAngle");
		
		UYHUDWidget_MissileMarker_BP_EventUpdateOffscreenAngle_Params params {};
		params.posX = posX;
		params.posY = posY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_MissileMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_MissileMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_MissileMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_MissileWarnings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_MissileWarnings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_MissileWarnings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00760D40
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.MenuButtonEntered
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		int32_t                                            optionIdx                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenu::MenuButtonEntered(int32_t optionIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.MenuButtonEntered");
		
		UYHUDWidget_PauseMenu_MenuButtonEntered_Params params {};
		params.optionIdx = optionIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780AB0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.MenuButtonClicked
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		int32_t                                            optionIdx                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenu::MenuButtonClicked(int32_t optionIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.MenuButtonClicked");
		
		UYHUDWidget_PauseMenu_MenuButtonClicked_Params params {};
		params.optionIdx = optionIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DB60
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.InputDeviceChanged
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		EYInputDevice                                      newInputDevice                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenu::InputDeviceChanged(EYInputDevice newInputDevice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.InputDeviceChanged");
		
		UYHUDWidget_PauseMenu_InputDeviceChanged_Params params {};
		params.newInputDevice = newInputDevice;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007486B0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.CloseSubMenu
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_PauseMenu::CloseSubMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.CloseSubMenu");
		
		UYHUDWidget_PauseMenu_CloseSubMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.BP_EventTogglePauseMenu
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Visible                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenu::BP_EventTogglePauseMenu(bool Visible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.BP_EventTogglePauseMenu");
		
		UYHUDWidget_PauseMenu_BP_EventTogglePauseMenu_Params params {};
		params.Visible = Visible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.BP_EventSetVitaRemotePlayOptionsState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               active                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenu::BP_EventSetVitaRemotePlayOptionsState(bool active)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.BP_EventSetVitaRemotePlayOptionsState");
		
		UYHUDWidget_PauseMenu_BP_EventSetVitaRemotePlayOptionsState_Params params {};
		params.active = active;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.BP_EventSetTabLabel
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        label                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenu::BP_EventSetTabLabel(int32_t index, const class FText& label)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.BP_EventSetTabLabel");
		
		UYHUDWidget_PauseMenu_BP_EventSetTabLabel_Params params {};
		params.index = index;
		params.label = label;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenu.BP_EventSetHighlightedTab
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenu::BP_EventSetHighlightedTab(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenu.BP_EventSetHighlightedTab");
		
		UYHUDWidget_PauseMenu_BP_EventSetHighlightedTab_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PauseMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PauseMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PauseMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenuOption.BP_EventSetLabel
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        label                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenuOption::BP_EventSetLabel(const class FText& label)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenuOption.BP_EventSetLabel");
		
		UYHUDWidget_PauseMenuOption_BP_EventSetLabel_Params params {};
		params.label = label;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseMenuOption.BP_EventHighlightOption
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               highlighted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseMenuOption::BP_EventHighlightOption(bool highlighted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseMenuOption.BP_EventHighlightOption");
		
		UYHUDWidget_PauseMenuOption_BP_EventHighlightOption_Params params {};
		params.highlighted = highlighted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PauseMenuOption.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PauseMenuOption::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PauseMenuOption");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007486D0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseSubMenu.CloseSubMenuFromBP
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 */
	void UYHUDWidget_PauseSubMenu::CloseSubMenuFromBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseSubMenu.CloseSubMenuFromBP");
		
		UYHUDWidget_PauseSubMenu_CloseSubMenuFromBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseSubMenu.BP_ShowSubMenu
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Show                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseSubMenu::BP_ShowSubMenu(bool Show)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseSubMenu.BP_ShowSubMenu");
		
		UYHUDWidget_PauseSubMenu_BP_ShowSubMenu_Params params {};
		params.Show = Show;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseSubMenu.BP_EventOptionModified
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UYHUDWidget_SettingsOption*                  option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseSubMenu::BP_EventOptionModified(class UYHUDWidget_SettingsOption* option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseSubMenu.BP_EventOptionModified");
		
		UYHUDWidget_PauseSubMenu_BP_EventOptionModified_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PauseSubMenu.BP_EventOptionHighlighted
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UYHUDWidget_SettingsOption*                  option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PauseSubMenu::BP_EventOptionHighlighted(class UYHUDWidget_SettingsOption* option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PauseSubMenu.BP_EventOptionHighlighted");
		
		UYHUDWidget_PauseSubMenu_BP_EventOptionHighlighted_Params params {};
		params.option = option;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PauseSubMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PauseSubMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PauseSubMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007706A0
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.SelectSubmitButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYHUDWidget_BugReporter::SelectSubmitButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.SelectSubmitButton");
		
		UYHUDWidget_BugReporter_SelectSubmitButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076C4A0
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.OpenIMEKeyboard
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            stringLength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      currentString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsPassword                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BugReporter::OpenIMEKeyboard(int32_t stringLength, const class FString& currentString, bool IsPassword)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.OpenIMEKeyboard");
		
		UYHUDWidget_BugReporter_OpenIMEKeyboard_Params params {};
		params.stringLength = stringLength;
		params.currentString = currentString;
		params.IsPassword = IsPassword;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074C640
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.CloseIMEKeyboard
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_BugReporter::CloseIMEKeyboard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.CloseIMEKeyboard");
		
		UYHUDWidget_BugReporter_CloseIMEKeyboard_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.BP_EventUpdateMessageContent
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            caretIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               showCaret                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BugReporter::BP_EventUpdateMessageContent(const class FString& message, int32_t caretIndex, bool showCaret)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.BP_EventUpdateMessageContent");
		
		UYHUDWidget_BugReporter_BP_EventUpdateMessageContent_Params params {};
		params.message = message;
		params.caretIndex = caretIndex;
		params.showCaret = showCaret;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.BP_EventSetUserMessageSelected
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isSelected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BugReporter::BP_EventSetUserMessageSelected(bool isSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.BP_EventSetUserMessageSelected");
		
		UYHUDWidget_BugReporter_BP_EventSetUserMessageSelected_Params params {};
		params.isSelected = isSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.BP_EventSetSubmitButtonPressed
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_BugReporter::BP_EventSetSubmitButtonPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.BP_EventSetSubmitButtonPressed");
		
		UYHUDWidget_BugReporter_BP_EventSetSubmitButtonPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.BP_EventSetSelectedComponent
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYBugReporterSelection                             ComponentType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isSelected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BugReporter::BP_EventSetSelectedComponent(EYBugReporterSelection ComponentType, bool isSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.BP_EventSetSelectedComponent");
		
		UYHUDWidget_BugReporter_BP_EventSetSelectedComponent_Params params {};
		params.ComponentType = ComponentType;
		params.isSelected = isSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_BugReporter.BP_EventSetIssueTypeLabel
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        labelText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               tabRight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_BugReporter::BP_EventSetIssueTypeLabel(const class FText& labelText, bool tabRight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_BugReporter.BP_EventSetIssueTypeLabel");
		
		UYHUDWidget_BugReporter_BP_EventSetIssueTypeLabel_Params params {};
		params.labelText = labelText;
		params.tabRight = tabRight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_BugReporter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_BugReporter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_BugReporter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780B40
	 * 		Name   -> Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.TabSwitched
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            tabIdx                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_UserSettingsSubMenu_PC::TabSwitched(int32_t tabIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.TabSwitched");
		
		UYHUDWidget_UserSettingsSubMenu_PC_TabSwitched_Params params {};
		params.tabIdx = tabIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FCB0
	 * 		Name   -> Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.RespondToHotkeyChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isKeyboardKey                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               isMouseButton                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               isGamepadKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_UserSettingsSubMenu_PC::RespondToHotkeyChanged(const class FName& EventName, bool isKeyboardKey, bool isMouseButton, bool isGamepadKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.RespondToHotkeyChanged");
		
		UYHUDWidget_UserSettingsSubMenu_PC_RespondToHotkeyChanged_Params params {};
		params.EventName = EventName;
		params.isKeyboardKey = isKeyboardKey;
		params.isMouseButton = isMouseButton;
		params.isGamepadKey = isGamepadKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076FC70
	 * 		Name   -> Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.ResetToDefaults
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_UserSettingsSubMenu_PC::ResetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.ResetToDefaults");
		
		UYHUDWidget_UserSettingsSubMenu_PC_ResetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B190
	 * 		Name   -> Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.OnTabBodyScrolled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              scrollOffset                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_UserSettingsSubMenu_PC::OnTabBodyScrolled(float scrollOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.OnTabBodyScrolled");
		
		UYHUDWidget_UserSettingsSubMenu_PC_OnTabBodyScrolled_Params params {};
		params.scrollOffset = scrollOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00741BE0
	 * 		Name   -> Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.ApplyUserSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_UserSettingsSubMenu_PC::ApplyUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_UserSettingsSubMenu_PC.ApplyUserSettings");
		
		UYHUDWidget_UserSettingsSubMenu_PC_ApplyUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_UserSettingsSubMenu_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_UserSettingsSubMenu_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_UserSettingsSubMenu_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00756BB0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterManager.GetPlayerData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPrematchTeamListData                       Data                                                       (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UYHUDWidget_PlayerRosterManager::GetPlayerData(int32_t SlotIndex, struct FPrematchTeamListData* Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterManager.GetPlayerData");
		
		UYHUDWidget_PlayerRosterManager_GetPlayerData_Params params {};
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Data != nullptr)
			*Data = params.Data;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074AB90
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterManager.DoesPlayerHaveShipSet
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYHUDWidget_PlayerRosterManager::DoesPlayerHaveShipSet(int32_t SlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterManager.DoesPlayerHaveShipSet");
		
		UYHUDWidget_PlayerRosterManager_DoesPlayerHaveShipSet_Params params {};
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterManager.CreateRosterSlotWidget
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	class UYHUDWidget_PlayerRosterSlot* UYHUDWidget_PlayerRosterManager::CreateRosterSlotWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterManager.CreateRosterSlotWidget");
		
		UYHUDWidget_PlayerRosterManager_CreateRosterSlotWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnUpdatedRosterData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_PlayerRosterManager::BP_OnUpdatedRosterData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnUpdatedRosterData");
		
		UYHUDWidget_PlayerRosterManager_BP_OnUpdatedRosterData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnSetFocusToPlayer
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_PlayerRosterManager::BP_OnSetFocusToPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnSetFocusToPlayer");
		
		UYHUDWidget_PlayerRosterManager_BP_OnSetFocusToPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnInputShoulderRight
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_PlayerRosterManager::BP_OnInputShoulderRight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnInputShoulderRight");
		
		UYHUDWidget_PlayerRosterManager_BP_OnInputShoulderRight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnInputShoulderLeft
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_PlayerRosterManager::BP_OnInputShoulderLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterManager.BP_OnInputShoulderLeft");
		
		UYHUDWidget_PlayerRosterManager_BP_OnInputShoulderLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PlayerRosterManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PlayerRosterManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PlayerRosterManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_SetShipTierIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_SetShipTierIcon(class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_SetShipTierIcon");
		
		UYHUDWidget_PlayerRosterSlot_BP_SetShipTierIcon_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_SetIsLocalPlayer
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsLocalPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_SetIsLocalPlayer(bool IsLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_SetIsLocalPlayer");
		
		UYHUDWidget_PlayerRosterSlot_BP_SetIsLocalPlayer_Params params {};
		params.IsLocalPlayer = IsLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnSpectatedSet
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isSpectatedPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_OnSpectatedSet(bool isSpectatedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnSpectatedSet");
		
		UYHUDWidget_PlayerRosterSlot_BP_OnSpectatedSet_Params params {};
		params.isSpectatedPlayer = isSpectatedPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnShipTextureChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  shipTexture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_OnShipTextureChanged(class UTexture2D* shipTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnShipTextureChanged");
		
		UYHUDWidget_PlayerRosterSlot_BP_OnShipTextureChanged_Params params {};
		params.shipTexture = shipTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnShipClassTextureChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  shipClassTexture                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_OnShipClassTextureChanged(class UTexture2D* shipClassTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnShipClassTextureChanged");
		
		UYHUDWidget_PlayerRosterSlot_BP_OnShipClassTextureChanged_Params params {};
		params.shipClassTexture = shipClassTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnReadySet
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               readyValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_OnReadySet(bool readyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnReadySet");
		
		UYHUDWidget_PlayerRosterSlot_BP_OnReadySet_Params params {};
		params.readyValue = readyValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnRankTextureChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  rankTexture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_OnRankTextureChanged(class UTexture2D* rankTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnRankTextureChanged");
		
		UYHUDWidget_PlayerRosterSlot_BP_OnRankTextureChanged_Params params {};
		params.rankTexture = rankTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnCaptainTextureChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  captainTexture                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PlayerRosterSlot::BP_OnCaptainTextureChanged(class UTexture2D* captainTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PlayerRosterSlot.BP_OnCaptainTextureChanged");
		
		UYHUDWidget_PlayerRosterSlot_BP_OnCaptainTextureChanged_Params params {};
		params.captainTexture = captainTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PlayerRosterSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PlayerRosterSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PlayerRosterSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F5D0
	 * 		Name   -> Function DreadGame.YHUDWidget_PopupSystem.IsPopupOpened
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_PopupSystem::IsPopupOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PopupSystem.IsPopupOpened");
		
		UYHUDWidget_PopupSystem_IsPopupOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075DAE0
	 * 		Name   -> Function DreadGame.YHUDWidget_PopupSystem.InputCallback
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		EYPS4ButtonIcon                                    Button                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PopupSystem::InputCallback(EYPS4ButtonIcon Button)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PopupSystem.InputCallback");
		
		UYHUDWidget_PopupSystem_InputCallback_Params params {};
		params.Button = Button;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00748690
	 * 		Name   -> Function DreadGame.YHUDWidget_PopupSystem.ClosePopup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_PopupSystem::ClosePopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PopupSystem.ClosePopup");
		
		UYHUDWidget_PopupSystem_ClosePopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007448A0
	 * 		Name   -> Function DreadGame.YHUDWidget_PopupSystem.ClearLegend
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UYHUDWidget_PopupSystem::ClearLegend()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PopupSystem.ClearLegend");
		
		UYHUDWidget_PopupSystem_ClearLegend_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PopupSystem.BP_ShowCostText
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYUICurrency                                       currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            currencyValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PopupSystem::BP_ShowCostText(EYUICurrency currencyType, int32_t currencyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PopupSystem.BP_ShowCostText");
		
		UYHUDWidget_PopupSystem_BP_ShowCostText_Params params {};
		params.currencyType = currencyType;
		params.currencyValue = currencyValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PopupSystem.BP_OpenPopup
	 * 		Flags  -> (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      headerText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      headerColor                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      bodyText                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FYUIPopupLegendInfo>                 legend                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               dimBackground                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               useTitleHighlight                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               useControllerDisconnectedPopup                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PopupSystem::BP_OpenPopup(const class FString& headerText, const struct FColor& headerColor, const class FString& bodyText, TArray<struct FYUIPopupLegendInfo> legend, bool dimBackground, bool useTitleHighlight, bool useControllerDisconnectedPopup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PopupSystem.BP_OpenPopup");
		
		UYHUDWidget_PopupSystem_BP_OpenPopup_Params params {};
		params.headerText = headerText;
		params.headerColor = headerColor;
		params.bodyText = bodyText;
		params.legend = legend;
		params.dimBackground = dimBackground;
		params.useTitleHighlight = useTitleHighlight;
		params.useControllerDisconnectedPopup = useControllerDisconnectedPopup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PopupSystem.BP_ClosePopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               useControllerDisconnectedPopup                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PopupSystem::BP_ClosePopup(bool useControllerDisconnectedPopup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PopupSystem.BP_ClosePopup");
		
		UYHUDWidget_PopupSystem_BP_ClosePopup_Params params {};
		params.useControllerDisconnectedPopup = useControllerDisconnectedPopup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PopupSystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PopupSystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PopupSystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00781F00
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptBase.TriggerClosePrompt
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, Const)
	 */
	void UYHUDWidget_PromptBase::TriggerClosePrompt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptBase.TriggerClosePrompt");
		
		UYHUDWidget_PromptBase_TriggerClosePrompt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076F5E0
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptBase.RequestActionNameDisplayStrings
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      ActionName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FText> UYHUDWidget_PromptBase::RequestActionNameDisplayStrings(const class FString& ActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptBase.RequestActionNameDisplayStrings");
		
		UYHUDWidget_PromptBase_RequestActionNameDisplayStrings_Params params {};
		params.ActionName = ActionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YHUDWidget_PromptBase.OnPromptInteractiveCloseTriggered__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYHUDWidget_PromptBase::OnPromptInteractiveCloseTriggered__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YHUDWidget_PromptBase.OnPromptInteractiveCloseTriggered__DelegateSignature");
		
		UYHUDWidget_PromptBase_OnPromptInteractiveCloseTriggered__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PromptBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PromptBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PromptBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptInformationBase.BP_InitializeData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<struct FYActionMappingText>                 promptDescriptionArray                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_PromptInformationBase::BP_InitializeData(TArray<struct FYActionMappingText> promptDescriptionArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptInformationBase.BP_InitializeData");
		
		UYHUDWidget_PromptInformationBase_BP_InitializeData_Params params {};
		params.promptDescriptionArray = promptDescriptionArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PromptInformationBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PromptInformationBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PromptInformationBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PromptOverlayBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PromptOverlayBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PromptOverlayBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770680
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptOverlayPS4.SelectPressed
	 * 		Flags  -> (Native, Protected)
	 */
	void UYHUDWidget_PromptOverlayPS4::SelectPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptOverlayPS4.SelectPressed");
		
		UYHUDWidget_PromptOverlayPS4_SelectPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007686C0
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptOverlayPS4.OnPromptClosed
	 * 		Flags  -> (Native, Protected)
	 */
	void UYHUDWidget_PromptOverlayPS4::OnPromptClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptOverlayPS4.OnPromptClosed");
		
		UYHUDWidget_PromptOverlayPS4_OnPromptClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A6E0
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptOverlayPS4.DeselectPressed
	 * 		Flags  -> (Native, Protected)
	 */
	void UYHUDWidget_PromptOverlayPS4::DeselectPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptOverlayPS4.DeselectPressed");
		
		UYHUDWidget_PromptOverlayPS4_DeselectPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptOverlayPS4.BP_OnSelectPressed
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_PromptOverlayPS4::BP_OnSelectPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptOverlayPS4.BP_OnSelectPressed");
		
		UYHUDWidget_PromptOverlayPS4_BP_OnSelectPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_PromptOverlayPS4.BP_OnDeselectPressed
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_PromptOverlayPS4::BP_OnDeselectPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_PromptOverlayPS4.BP_OnDeselectPressed");
		
		UYHUDWidget_PromptOverlayPS4_BP_OnDeselectPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PromptOverlayPS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PromptOverlayPS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PromptOverlayPS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_PromptManagerPS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_PromptManagerPS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_PromptManagerPS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FE50
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.StartRoundOverAnimations
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_RoundOverDisplay::StartRoundOverAnimations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.StartRoundOverAnimations");
		
		UYHUDWidget_RoundOverDisplay_StartRoundOverAnimations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077BAA0
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.SetTeamEliminationPlayers
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		TArray<struct FTeamElimPlayerData>                 elimData                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOverDisplay::SetTeamEliminationPlayers(TArray<struct FTeamElimPlayerData> elimData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.SetTeamEliminationPlayers");
		
		UYHUDWidget_RoundOverDisplay_SetTeamEliminationPlayers_Params params {};
		params.elimData = elimData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077A070
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.SetPlayerTeam
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOverDisplay::SetPlayerTeam(EYTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.SetPlayerTeam");
		
		UYHUDWidget_RoundOverDisplay_SetPlayerTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777C20
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.SetGameModeRoundResult
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOverDisplay::SetGameModeRoundResult(int32_t Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.SetGameModeRoundResult");
		
		UYHUDWidget_RoundOverDisplay_SetGameModeRoundResult_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777BA0
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.SetGameModeRound
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Round                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOverDisplay::SetGameModeRound(int32_t Round)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.SetGameModeRound");
		
		UYHUDWidget_RoundOverDisplay_SetGameModeRound_Params params {};
		params.Round = Round;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777970
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.SetGameMode
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYGameModeType                                     gameModeHUDType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOverDisplay::SetGameMode(EYGameModeType gameModeHUDType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.SetGameMode");
		
		UYHUDWidget_RoundOverDisplay_SetGameMode_Params params {};
		params.gameModeHUDType = gameModeHUDType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.BP_EventSetGameModeRoundResult
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOverDisplay::BP_EventSetGameModeRoundResult(int32_t Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.BP_EventSetGameModeRoundResult");
		
		UYHUDWidget_RoundOverDisplay_BP_EventSetGameModeRoundResult_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.BP_EventSetGameModeRound
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Round                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_RoundOverDisplay::BP_EventSetGameModeRound(int32_t Round)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.BP_EventSetGameModeRound");
		
		UYHUDWidget_RoundOverDisplay_BP_EventSetGameModeRound_Params params {};
		params.Round = Round;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_RoundOverDisplay.BP_EventOnSetGameMode
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_RoundOverDisplay::BP_EventOnSetGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_RoundOverDisplay.BP_EventOnSetGameMode");
		
		UYHUDWidget_RoundOverDisplay_BP_EventOnSetGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_RoundOverDisplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_RoundOverDisplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_RoundOverDisplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventUpdateScoreBoardHeader
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      mapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      gameModeName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            scoreTeam1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            scoreTeam2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxScore                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventUpdateScoreBoardHeader(const class FString& mapName, const class FString& gameModeName, int32_t scoreTeam1, int32_t scoreTeam2, int32_t maxScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventUpdateScoreBoardHeader");
		
		UYHUDWidget_ScoreBoard_BP_EventUpdateScoreBoardHeader_Params params {};
		params.mapName = mapName;
		params.gameModeName = gameModeName;
		params.scoreTeam1 = scoreTeam1;
		params.scoreTeam2 = scoreTeam2;
		params.maxScore = maxScore;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventUpdateScoreBoardFactions
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      factionA                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      factionB                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventUpdateScoreBoardFactions(const class FString& factionA, const class FString& factionB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventUpdateScoreBoardFactions");
		
		UYHUDWidget_ScoreBoard_BP_EventUpdateScoreBoardFactions_Params params {};
		params.factionA = factionA;
		params.factionB = factionB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventUpdateGameModeRoundResult
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventUpdateGameModeRoundResult(int32_t Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventUpdateGameModeRoundResult");
		
		UYHUDWidget_ScoreBoard_BP_EventUpdateGameModeRoundResult_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventToggleScoreBoard
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Visible                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventToggleScoreBoard(bool Visible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventToggleScoreBoard");
		
		UYHUDWidget_ScoreBoard_BP_EventToggleScoreBoard_Params params {};
		params.Visible = Visible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventSetScoreBoardSlotOptionsWidgetPosition
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsAlly                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventSetScoreBoardSlotOptionsWidgetPosition(bool bIsAlly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventSetScoreBoardSlotOptionsWidgetPosition");
		
		UYHUDWidget_ScoreBoard_BP_EventSetScoreBoardSlotOptionsWidgetPosition_Params params {};
		params.bIsAlly = bIsAlly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventSetGameModeHeader
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYGameModeType                                     mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventSetGameModeHeader(EYGameModeType mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventSetGameModeHeader");
		
		UYHUDWidget_ScoreBoard_BP_EventSetGameModeHeader_Params params {};
		params.mode = mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventSetButtonPromptVisibility
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Visible                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventSetButtonPromptVisibility(bool Visible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventSetButtonPromptVisibility");
		
		UYHUDWidget_ScoreBoard_BP_EventSetButtonPromptVisibility_Params params {};
		params.Visible = Visible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventOptionsVisible
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               Visible                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventOptionsVisible(bool Visible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventOptionsVisible");
		
		UYHUDWidget_ScoreBoard_BP_EventOptionsVisible_Params params {};
		params.Visible = Visible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventAddScoreBoardSlotWidget
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UYHUDWidget_ScoreBoardSlot*                  slotWidget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYTeam                                             Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventAddScoreBoardSlotWidget(class UYHUDWidget_ScoreBoardSlot* slotWidget, EYTeam Team, int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventAddScoreBoardSlotWidget");
		
		UYHUDWidget_ScoreBoard_BP_EventAddScoreBoardSlotWidget_Params params {};
		params.slotWidget = slotWidget;
		params.Team = Team;
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoard.BP_EventAddScoreBoardSlotOptionsWidget
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_ScoreBoard::BP_EventAddScoreBoardSlotOptionsWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoard.BP_EventAddScoreBoardSlotOptionsWidget");
		
		UYHUDWidget_ScoreBoard_BP_EventAddScoreBoardSlotOptionsWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ScoreBoard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ScoreBoard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ScoreBoard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ScoreBoardHavok.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ScoreBoardHavok::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ScoreBoardHavok");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoardSlot.BP_EventSetSlotHighlighted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               highlighted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoardSlot::BP_EventSetSlotHighlighted(bool highlighted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoardSlot.BP_EventSetSlotHighlighted");
		
		UYHUDWidget_ScoreBoardSlot_BP_EventSetSlotHighlighted_Params params {};
		params.highlighted = highlighted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoardSlot.BP_EventPopulateSlot
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYScoreboardClassType                              shipType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      PlayerName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            kills                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            deaths                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            assists                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              killDeathRatio                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isFriend                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  rankIconTexture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      tierPath                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               isMuted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoardSlot::BP_EventPopulateSlot(EYScoreboardClassType shipType, const class FString& PlayerName, int32_t kills, int32_t deaths, int32_t assists, float killDeathRatio, int32_t Score, bool isFriend, class UTexture2D* rankIconTexture, const class FString& tierPath, bool isSelf, bool isMuted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoardSlot.BP_EventPopulateSlot");
		
		UYHUDWidget_ScoreBoardSlot_BP_EventPopulateSlot_Params params {};
		params.shipType = shipType;
		params.PlayerName = PlayerName;
		params.kills = kills;
		params.deaths = deaths;
		params.assists = assists;
		params.killDeathRatio = killDeathRatio;
		params.Score = Score;
		params.isFriend = isFriend;
		params.rankIconTexture = rankIconTexture;
		params.tierPath = tierPath;
		params.isSelf = isSelf;
		params.isMuted = isMuted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoardSlot.BP_EventClearSlot
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_ScoreBoardSlot::BP_EventClearSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoardSlot.BP_EventClearSlot");
		
		UYHUDWidget_ScoreBoardSlot_BP_EventClearSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ScoreBoardSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ScoreBoardSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ScoreBoardSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoardSlot_Options.BP_EventSetSlotHighlighted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoardSlot_Options::BP_EventSetSlotHighlighted(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoardSlot_Options.BP_EventSetSlotHighlighted");
		
		UYHUDWidget_ScoreBoardSlot_Options_BP_EventSetSlotHighlighted_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoardSlot_Options.BP_EventPopulateSlot
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      PlayerName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isAlly                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               isFriend                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  captainIconTexture                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  rankIconTexture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            rank                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      highestFleetUnlocked                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoreBoardSlot_Options::BP_EventPopulateSlot(const class FString& PlayerName, bool isAlly, bool isFriend, class UTexture2D* captainIconTexture, class UTexture2D* rankIconTexture, int32_t rank, const class FString& highestFleetUnlocked, bool isSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoardSlot_Options.BP_EventPopulateSlot");
		
		UYHUDWidget_ScoreBoardSlot_Options_BP_EventPopulateSlot_Params params {};
		params.PlayerName = PlayerName;
		params.isAlly = isAlly;
		params.isFriend = isFriend;
		params.captainIconTexture = captainIconTexture;
		params.rankIconTexture = rankIconTexture;
		params.rank = rank;
		params.highestFleetUnlocked = highestFleetUnlocked;
		params.isSelf = isSelf;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoreBoardSlot_Options.BP_EventCloseOptionsWidget
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_ScoreBoardSlot_Options::BP_EventCloseOptionsWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoreBoardSlot_Options.BP_EventCloseOptionsWidget");
		
		UYHUDWidget_ScoreBoardSlot_Options_BP_EventCloseOptionsWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ScoreBoardSlot_Options.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ScoreBoardSlot_Options::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ScoreBoardSlot_Options");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ScoringEvents.BP_EventAddScoringEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      eventText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYScoringEventLevel                                scoreLevel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isRibbonEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  ribbonTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ScoringEvents::BP_EventAddScoringEvent(const class FString& eventText, EYScoringEventLevel scoreLevel, bool isRibbonEvent, class UTexture2D* ribbonTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ScoringEvents.BP_EventAddScoringEvent");
		
		UYHUDWidget_ScoringEvents_BP_EventAddScoringEvent_Params params {};
		params.eventText = eventText;
		params.scoreLevel = scoreLevel;
		params.isRibbonEvent = isRibbonEvent;
		params.ribbonTexture = ribbonTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ScoringEvents.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ScoringEvents::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ScoringEvents");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755970
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.GetOptionSelectedValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UYHUDWidget_SettingsOption::GetOptionSelectedValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.GetOptionSelectedValue");
		
		UYHUDWidget_SettingsOption_GetOptionSelectedValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00755930
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.GetOptionDisplayName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FText UYHUDWidget_SettingsOption::GetOptionDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.GetOptionDisplayName");
		
		UYHUDWidget_SettingsOption_GetOptionDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetOptionType
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYUISettingType                                    Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_SettingsOption::BP_EventSetOptionType(EYUISettingType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetOptionType");
		
		UYHUDWidget_SettingsOption_BP_EventSetOptionType_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetOptionListLabel
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        label                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_SettingsOption::BP_EventSetOptionListLabel(const class FText& label)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetOptionListLabel");
		
		UYHUDWidget_SettingsOption_BP_EventSetOptionListLabel_Params params {};
		params.label = label;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetOptionBarFillPercent
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              fillPercent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_SettingsOption::BP_EventSetOptionBarFillPercent(float fillPercent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetOptionBarFillPercent");
		
		UYHUDWidget_SettingsOption_BP_EventSetOptionBarFillPercent_Params params {};
		params.fillPercent = fillPercent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetLockStatus
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isLocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_SettingsOption::BP_EventSetLockStatus(bool isLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetLockStatus");
		
		UYHUDWidget_SettingsOption_BP_EventSetLockStatus_Params params {};
		params.isLocked = isLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetLabel
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        label                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_SettingsOption::BP_EventSetLabel(const class FText& label)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetLabel");
		
		UYHUDWidget_SettingsOption_BP_EventSetLabel_Params params {};
		params.label = label;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetHighlighted
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               highlighted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_SettingsOption::BP_EventSetHighlighted(bool highlighted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_SettingsOption.BP_EventSetHighlighted");
		
		UYHUDWidget_SettingsOption_BP_EventSetHighlighted_Params params {};
		params.highlighted = highlighted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_SettingsOption.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_SettingsOption::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_SettingsOption");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776B10
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipInfoPanel.SetData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FYShipLoadoutInfo                           shipLoadoutInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipInfoPanel::SetData(const struct FYShipLoadoutInfo& shipLoadoutInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipInfoPanel.SetData");
		
		UYHUDWidget_ShipInfoPanel_SetData_Params params {};
		params.shipLoadoutInfo = shipLoadoutInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipTierIcon
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipInfoPanel::BP_SetShipTierIcon(class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipTierIcon");
		
		UYHUDWidget_ShipInfoPanel_BP_SetShipTierIcon_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipSubline
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipInfoPanel::BP_SetShipSubline(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipSubline");
		
		UYHUDWidget_ShipInfoPanel_BP_SetShipSubline_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipName
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipInfoPanel::BP_SetShipName(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipName");
		
		UYHUDWidget_ShipInfoPanel_BP_SetShipName_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipClassIcon
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShipInfoPanel::BP_SetShipClassIcon(class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShipInfoPanel.BP_SetShipClassIcon");
		
		UYHUDWidget_ShipInfoPanel_BP_SetShipClassIcon_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ShipInfoPanel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ShipInfoPanel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ShipInfoPanel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775C50
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSelector.SetSpokeList
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UYHUDWidget_ShortCommandSpoke*>       spokeList                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSelector::SetSpokeList(TArray<class UYHUDWidget_ShortCommandSpoke*> spokeList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSelector.SetSpokeList");
		
		UYHUDWidget_ShortCommandSelector_SetSpokeList_Params params {};
		params.spokeList = spokeList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778300
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSelector.SetHighlighted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               isHighlighted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SelectionIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSelector::SetHighlighted(bool isHighlighted, int32_t SelectionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSelector.SetHighlighted");
		
		UYHUDWidget_ShortCommandSelector_SetHighlighted_Params params {};
		params.isHighlighted = isHighlighted;
		params.SelectionIndex = SelectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSelector.BP_PlayOpenAnimation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_ShortCommandSelector::BP_PlayOpenAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSelector.BP_PlayOpenAnimation");
		
		UYHUDWidget_ShortCommandSelector_BP_PlayOpenAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ShortCommandSelector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ShortCommandSelector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ShortCommandSelector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B250
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSpoke.SetSpokeAngle
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSpoke::SetSpokeAngle(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSpoke.SetSpokeAngle");
		
		UYHUDWidget_ShortCommandSpoke_SetSpokeAngle_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetSpokeText
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        spokeText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSpoke::BP_SetSpokeText(const class FText& spokeText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetSpokeText");
		
		UYHUDWidget_ShortCommandSpoke_BP_SetSpokeText_Params params {};
		params.spokeText = spokeText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetSpokeIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  spokeIcon                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSpoke::BP_SetSpokeIcon(class UTexture2D* spokeIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetSpokeIcon");
		
		UYHUDWidget_ShortCommandSpoke_BP_SetSpokeIcon_Params params {};
		params.spokeIcon = spokeIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetSpokeCount
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            maxSpokesShown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSpoke::BP_SetSpokeCount(int32_t maxSpokesShown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetSpokeCount");
		
		UYHUDWidget_ShortCommandSpoke_BP_SetSpokeCount_Params params {};
		params.maxSpokesShown = maxSpokesShown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetAngle
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSpoke::BP_SetAngle(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_SetAngle");
		
		UYHUDWidget_ShortCommandSpoke_BP_SetAngle_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_PlaySelectAnimation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isSelected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSpoke::BP_PlaySelectAnimation(bool isSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_PlaySelectAnimation");
		
		UYHUDWidget_ShortCommandSpoke_BP_PlaySelectAnimation_Params params {};
		params.isSelected = isSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_PlayHighlightAnimation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               isHighlighted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_ShortCommandSpoke::BP_PlayHighlightAnimation(bool isHighlighted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_ShortCommandSpoke.BP_PlayHighlightAnimation");
		
		UYHUDWidget_ShortCommandSpoke_BP_PlayHighlightAnimation_Params params {};
		params.isHighlighted = isHighlighted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_ShortCommandSpoke.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_ShortCommandSpoke::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_ShortCommandSpoke");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770DB0
	 * 		Name   -> Function DreadGame.YHUDWidget_Squad.SendSquadWhisper
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        friendName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Squad::SendSquadWhisper(const class FName& friendName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Squad.SendSquadWhisper");
		
		UYHUDWidget_Squad_SendSquadWhisper_Params params {};
		params.friendName = friendName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00770D30
	 * 		Name   -> Function DreadGame.YHUDWidget_Squad.SendSquadInvite
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        friendName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Squad::SendSquadInvite(const class FName& friendName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Squad.SendSquadInvite");
		
		UYHUDWidget_Squad_SendSquadInvite_Params params {};
		params.friendName = friendName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076AAE0
	 * 		Name   -> Function DreadGame.YHUDWidget_Squad.OnSquadLeave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_Squad::OnSquadLeave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Squad.OnSquadLeave");
		
		UYHUDWidget_Squad_OnSquadLeave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> DelegateFunction DreadGame.YHUDWidget_Squad.OnSquadChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UYHUDWidget_Squad::OnSquadChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DreadGame.YHUDWidget_Squad.OnSquadChanged__DelegateSignature");
		
		UYHUDWidget_Squad_OnSquadChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DAB0
	 * 		Name   -> Function DreadGame.YHUDWidget_Squad.GetAvatarPathFromUserPID
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        userPID                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UYHUDWidget_Squad::GetAvatarPathFromUserPID(const class FName& userPID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Squad.GetAvatarPathFromUserPID");
		
		UYHUDWidget_Squad_GetAvatarPathFromUserPID_Params params {};
		params.userPID = userPID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DA30
	 * 		Name   -> Function DreadGame.YHUDWidget_Squad.GetAvatarImagePaths
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class FString> UYHUDWidget_Squad::GetAvatarImagePaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Squad.GetAvatarImagePaths");
		
		UYHUDWidget_Squad_GetAvatarImagePaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_Squad.BP_EnableSquadMenu
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               shouldEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_Squad::BP_EnableSquadMenu(bool shouldEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_Squad.BP_EnableSquadMenu");
		
		UYHUDWidget_Squad_BP_EnableSquadMenu_Params params {};
		params.shouldEnable = shouldEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_Squad.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_Squad::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_Squad");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_StatRow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_StatRow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_StatRow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_StatRow_Bar.BP_OnStatsChanged
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        statHeader                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      statValue                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_StatRow_Bar::BP_OnStatsChanged(const class FText& statHeader, const class FString& statValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StatRow_Bar.BP_OnStatsChanged");
		
		UYHUDWidget_StatRow_Bar_BP_OnStatsChanged_Params params {};
		params.statHeader = statHeader;
		params.statValue = statValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_StatRow_Bar.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_StatRow_Bar::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_StatRow_Bar");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077C100
	 * 		Name   -> Function DreadGame.YHUDWidget_StatRow_ShipDesc.SetTier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            tier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_StatRow_ShipDesc::SetTier(int32_t tier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StatRow_ShipDesc.SetTier");
		
		UYHUDWidget_StatRow_ShipDesc_SetTier_Params params {};
		params.tier = tier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_StatRow_ShipDesc.BP_OnStatsChanged
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        statData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_StatRow_ShipDesc::BP_OnStatsChanged(const class FText& statData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StatRow_ShipDesc.BP_OnStatsChanged");
		
		UYHUDWidget_StatRow_ShipDesc_BP_OnStatsChanged_Params params {};
		params.statData = statData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_StatRow_ShipDesc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_StatRow_ShipDesc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_StatRow_ShipDesc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_StatRow_ShipName.BP_OnStatsChanged
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        statData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_StatRow_ShipName::BP_OnStatsChanged(const class FText& statData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StatRow_ShipName.BP_OnStatsChanged");
		
		UYHUDWidget_StatRow_ShipName_BP_OnStatsChanged_Params params {};
		params.statData = statData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_StatRow_ShipName.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_StatRow_ShipName::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_StatRow_ShipName");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_StatRow_SingleText.BP_OnStatsChanged
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        statData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_StatRow_SingleText::BP_OnStatsChanged(const class FText& statData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StatRow_SingleText.BP_OnStatsChanged");
		
		UYHUDWidget_StatRow_SingleText_BP_OnStatsChanged_Params params {};
		params.statData = statData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_StatRow_SingleText.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_StatRow_SingleText::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_StatRow_SingleText");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759980
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetTeamEliminationIcon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUITeamEliminationIcon                            elimIconType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYHUDWidget_StyleContainer::GetTeamEliminationIcon(EYUITeamEliminationIcon elimIconType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetTeamEliminationIcon");
		
		UYHUDWidget_StyleContainer_GetTeamEliminationIcon_Params params {};
		params.elimIconType = elimIconType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759490
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetStyleColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EYUIColorStyle                                     colorStyle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FColor UYHUDWidget_StyleContainer::GetStyleColor(EYUIColorStyle colorStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetStyleColor");
		
		UYHUDWidget_StyleContainer_GetStyleColor_Params params {};
		params.colorStyle = colorStyle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758BD0
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetShortCommandIcon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUIShortCommands                                  shortCommand                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYHUDWidget_StyleContainer::GetShortCommandIcon(EYUIShortCommands shortCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetShortCommandIcon");
		
		UYHUDWidget_StyleContainer_GetShortCommandIcon_Params params {};
		params.shortCommand = shortCommand;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007584D0
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetShipClassIcon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYShipBaseClass                                    baseclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYHUDWidget_StyleContainer::GetShipClassIcon(EYShipBaseClass baseclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetShipClassIcon");
		
		UYHUDWidget_StyleContainer_GetShipClassIcon_Params params {};
		params.baseclass = baseclass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007575D0
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetQuestMarkerIcon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUIQuestMarker                                    questMarker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYHUDWidget_StyleContainer::GetQuestMarkerIcon(EYUIQuestMarker questMarker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetQuestMarkerIcon");
		
		UYHUDWidget_StyleContainer_GetQuestMarkerIcon_Params params {};
		params.questMarker = questMarker;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757500
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetQuestMarkerDescription
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYUIQuestMarker                                    questMarker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYHUDWidget_StyleContainer::GetQuestMarkerDescription(EYUIQuestMarker questMarker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetQuestMarkerDescription");
		
		UYHUDWidget_StyleContainer_GetQuestMarkerDescription_Params params {};
		params.questMarker = questMarker;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00757470
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetQuestMarkerColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EYUIQuestMarker                                    questMarker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FColor UYHUDWidget_StyleContainer::GetQuestMarkerColor(EYUIQuestMarker questMarker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetQuestMarkerColor");
		
		UYHUDWidget_StyleContainer_GetQuestMarkerColor_Params params {};
		params.questMarker = questMarker;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00752360
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetHUDOverlayInstruction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            controllerConfigIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYHelperHUDInstructionType                         instructionType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UYHUDWidget_StyleContainer::GetHUDOverlayInstruction(int32_t controllerConfigIndex, EYHelperHUDInstructionType instructionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetHUDOverlayInstruction");
		
		UYHUDWidget_StyleContainer_GetHUDOverlayInstruction_Params params {};
		params.controllerConfigIndex = controllerConfigIndex;
		params.instructionType = instructionType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007518B0
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetEnergyWheelIcon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYEnergyWheelSelection                             energySelection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYHUDWidget_StyleContainer::GetEnergyWheelIcon(EYEnergyWheelSelection energySelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetEnergyWheelIcon");
		
		UYHUDWidget_StyleContainer_GetEnergyWheelIcon_Params params {};
		params.energySelection = energySelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00750330
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetControllerInputIcon
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        inKey                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYHUDWidget_StyleContainer::GetControllerInputIcon(const class FName& inKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetControllerInputIcon");
		
		UYHUDWidget_StyleContainer_GetControllerInputIcon_Params params {};
		params.inKey = inKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074DFC0
	 * 		Name   -> Function DreadGame.YHUDWidget_StyleContainer.GetBuffTypeIcon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYBuffType                                         buffType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UYHUDWidget_StyleContainer::GetBuffTypeIcon(EYBuffType buffType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_StyleContainer.GetBuffTypeIcon");
		
		UYHUDWidget_StyleContainer_GetBuffTypeIcon_Params params {};
		params.buffType = buffType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_StyleContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_StyleContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_StyleContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00780AB0
	 * 		Name   -> Function DreadGame.YHUDWidget_TabSwitcherBar_PC.TabSelected
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            tabIdx                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TabSwitcherBar_PC::TabSelected(int32_t tabIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TabSwitcherBar_PC.TabSelected");
		
		UYHUDWidget_TabSwitcherBar_PC_TabSelected_Params params {};
		params.tabIdx = tabIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TabSwitcherBar_PC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TabSwitcherBar_PC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TabSwitcherBar_PC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TabSwitcherBar_PS4.BP_OnTabSelected
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            tabIdx                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TabSwitcherBar_PS4::BP_OnTabSelected(int32_t tabIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TabSwitcherBar_PS4.BP_OnTabSelected");
		
		UYHUDWidget_TabSwitcherBar_PS4_BP_OnTabSelected_Params params {};
		params.tabIdx = tabIdx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TabSwitcherBar_PS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TabSwitcherBar_PS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TabSwitcherBar_PS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076DD70
	 * 		Name   -> Function DreadGame.YHUDWidget_TargetIndicator.PostBlueprintLinksCreated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYHUDWidget_TargetIndicator::PostBlueprintLinksCreated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TargetIndicator.PostBlueprintLinksCreated");
		
		UYHUDWidget_TargetIndicator_PostBlueprintLinksCreated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00753DB0
	 * 		Name   -> Function DreadGame.YHUDWidget_TargetIndicator.GetMarkerDistance
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	float UYHUDWidget_TargetIndicator::GetMarkerDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TargetIndicator.GetMarkerDistance");
		
		UYHUDWidget_TargetIndicator_GetMarkerDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TargetIndicator.BP_EventRevealCommandPanel
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_TargetIndicator::BP_EventRevealCommandPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TargetIndicator.BP_EventRevealCommandPanel");
		
		UYHUDWidget_TargetIndicator_BP_EventRevealCommandPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TargetIndicator.BP_EventHideCommandPanel
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_TargetIndicator::BP_EventHideCommandPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TargetIndicator.BP_EventHideCommandPanel");
		
		UYHUDWidget_TargetIndicator_BP_EventHideCommandPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TargetIndicator.BP_EventAbilityLocked
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            abilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UImage*                                      abilityIcon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TargetIndicator::BP_EventAbilityLocked(int32_t abilityIndex, class UImage* abilityIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TargetIndicator.BP_EventAbilityLocked");
		
		UYHUDWidget_TargetIndicator_BP_EventAbilityLocked_Params params {};
		params.abilityIndex = abilityIndex;
		params.abilityIcon = abilityIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TargetIndicator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TargetIndicator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TargetIndicator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TargetManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TargetManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TargetManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamCompManager.BP_SetTeamCompSlotPositions
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYHUDWidget_TeamCompManager::BP_SetTeamCompSlotPositions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamCompManager.BP_SetTeamCompSlotPositions");
		
		UYHUDWidget_TeamCompManager_BP_SetTeamCompSlotPositions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TeamCompManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TeamCompManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TeamCompManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamCompSlot.BP_OnShipCountChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            newShipCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamCompSlot::BP_OnShipCountChanged(int32_t newShipCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamCompSlot.BP_OnShipCountChanged");
		
		UYHUDWidget_TeamCompSlot_BP_OnShipCountChanged_Params params {};
		params.newShipCount = newShipCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamCompSlot.BP_OnSetCompositionClass
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYShipBaseClass                                    compClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamCompSlot::BP_OnSetCompositionClass(EYShipBaseClass compClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamCompSlot.BP_OnSetCompositionClass");
		
		UYHUDWidget_TeamCompSlot_BP_OnSetCompositionClass_Params params {};
		params.compClass = compClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TeamCompSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TeamCompSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TeamCompSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758D60
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatMgr.GetSlotForPlayer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        uniqueNetID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UYHUDWidget_TeamVoiceChatSlot* UYHUDWidget_TeamVoiceChatMgr::GetSlotForPlayer(const class FName& uniqueNetID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatMgr.GetSlotForPlayer");
		
		UYHUDWidget_TeamVoiceChatMgr_GetSlotForPlayer_Params params {};
		params.uniqueNetID = uniqueNetID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007490B0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatMgr.CreateAndPopulatePlayerSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        uniqueNetID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      readableName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYShipBaseClass                                    baseclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsLocal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UYHUDWidget_TeamVoiceChatSlot* UYHUDWidget_TeamVoiceChatMgr::CreateAndPopulatePlayerSlot(const class FName& uniqueNetID, const class FString& readableName, EYShipBaseClass baseclass, bool bIsLocal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatMgr.CreateAndPopulatePlayerSlot");
		
		UYHUDWidget_TeamVoiceChatMgr_CreateAndPopulatePlayerSlot_Params params {};
		params.uniqueNetID = uniqueNetID;
		params.readableName = readableName;
		params.baseclass = baseclass;
		params.bIsLocal = bIsLocal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatMgr.BP_EventRearrangeActiveTeammateList
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class UYHUDWidget_TeamVoiceChatSlot*>       currentActiveSlots                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatMgr::BP_EventRearrangeActiveTeammateList(TArray<class UYHUDWidget_TeamVoiceChatSlot*> currentActiveSlots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatMgr.BP_EventRearrangeActiveTeammateList");
		
		UYHUDWidget_TeamVoiceChatMgr_BP_EventRearrangeActiveTeammateList_Params params {};
		params.currentActiveSlots = currentActiveSlots;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TeamVoiceChatMgr.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TeamVoiceChatMgr::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TeamVoiceChatMgr");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077FA90
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.StartDebugChatTest
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::StartDebugChatTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.StartDebugChatTest");
		
		UYHUDWidget_TeamVoiceChatSlot_StartDebugChatTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B150
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetSlotPlayerShipClass
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EYShipBaseClass                                    shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::SetSlotPlayerShipClass(EYShipBaseClass shipclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetSlotPlayerShipClass");
		
		UYHUDWidget_TeamVoiceChatSlot_SetSlotPlayerShipClass_Params params {};
		params.shipclass = shipclass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077B050
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetSlotPlayerName
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        uniqueNetID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      PlayerName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::SetSlotPlayerName(const class FName& uniqueNetID, const class FString& PlayerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetSlotPlayerName");
		
		UYHUDWidget_TeamVoiceChatSlot_SetSlotPlayerName_Params params {};
		params.uniqueNetID = uniqueNetID;
		params.PlayerName = PlayerName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077AFC0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetSlotChatting
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bIsChatting                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::SetSlotChatting(bool bIsChatting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetSlotChatting");
		
		UYHUDWidget_TeamVoiceChatSlot_SetSlotChatting_Params params {};
		params.bIsChatting = bIsChatting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007785F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetIsSquadmate
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bIsSquadmate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::SetIsSquadmate(bool bIsSquadmate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetIsSquadmate");
		
		UYHUDWidget_TeamVoiceChatSlot_SetIsSquadmate_Params params {};
		params.bIsSquadmate = bIsSquadmate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778560
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetIsEnemy
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bIsEnemy                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::SetIsEnemy(bool bIsEnemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.SetIsEnemy");
		
		UYHUDWidget_TeamVoiceChatSlot_SetIsEnemy_Params params {};
		params.bIsEnemy = bIsEnemy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075FB00
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsSquadmate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_TeamVoiceChatSlot::IsSquadmate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsSquadmate");
		
		UYHUDWidget_TeamVoiceChatSlot_IsSquadmate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075F090
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsLocalPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_TeamVoiceChatSlot::IsLocalPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsLocalPlayer");
		
		UYHUDWidget_TeamVoiceChatSlot_IsLocalPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E770
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsForPlayer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        uniqueNetID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UYHUDWidget_TeamVoiceChatSlot::IsForPlayer(const class FName& uniqueNetID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsForPlayer");
		
		UYHUDWidget_TeamVoiceChatSlot_IsForPlayer_Params params {};
		params.uniqueNetID = uniqueNetID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E6F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsEnemy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_TeamVoiceChatSlot::IsEnemy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsEnemy");
		
		UYHUDWidget_TeamVoiceChatSlot_IsEnemy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075E390
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsChatting
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool UYHUDWidget_TeamVoiceChatSlot::IsChatting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.IsChatting");
		
		UYHUDWidget_TeamVoiceChatSlot_IsChatting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D0C0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.InitSlot
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UYHUDWidget_TeamVoiceChatMgr*                manager                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsLocal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::InitSlot(class UYHUDWidget_TeamVoiceChatMgr* manager, bool bIsLocal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.InitSlot");
		
		UYHUDWidget_TeamVoiceChatSlot_InitSlot_Params params {};
		params.manager = manager;
		params.bIsLocal = bIsLocal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075C550
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.HasPlayerData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UYHUDWidget_TeamVoiceChatSlot::HasPlayerData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.HasPlayerData");
		
		UYHUDWidget_TeamVoiceChatSlot_HasPlayerData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074B850
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.EndDebugChatTest
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::EndDebugChatTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.EndDebugChatTest");
		
		UYHUDWidget_TeamVoiceChatSlot_EndDebugChatTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007499B0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.DeactivateSlot
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::DeactivateSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.DeactivateSlot");
		
		UYHUDWidget_TeamVoiceChatSlot_DeactivateSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SlotDeactivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_SlotDeactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SlotDeactivated");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_SlotDeactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SlotActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_SlotActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SlotActivated");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_SlotActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SetIsSquadmate
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsSquadmate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_SetIsSquadmate(bool IsSquadmate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SetIsSquadmate");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_SetIsSquadmate_Params params {};
		params.IsSquadmate = IsSquadmate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SetIsLocalPlayer
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsLocalPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_SetIsLocalPlayer(bool IsLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SetIsLocalPlayer");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_SetIsLocalPlayer_Params params {};
		params.IsLocalPlayer = IsLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SetIsEnemy
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsEnemy                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_SetIsEnemy(bool IsEnemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_SetIsEnemy");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_SetIsEnemy_Params params {};
		params.IsEnemy = IsEnemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_EventSetSlotShipClass
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYShipBaseClass                                    shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_EventSetSlotShipClass(EYShipBaseClass shipclass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_EventSetSlotShipClass");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_EventSetSlotShipClass_Params params {};
		params.shipclass = shipclass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_EventSetSlotPlayerName
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      PlayerName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_EventSetSlotPlayerName(const class FString& PlayerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_EventSetSlotPlayerName");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_EventSetSlotPlayerName_Params params {};
		params.PlayerName = PlayerName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_EventSetSlotChatting
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsChatting                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::BP_EventSetSlotChatting(bool bIsChatting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.BP_EventSetSlotChatting");
		
		UYHUDWidget_TeamVoiceChatSlot_BP_EventSetSlotChatting_Params params {};
		params.bIsChatting = bIsChatting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073D6D0
	 * 		Name   -> Function DreadGame.YHUDWidget_TeamVoiceChatSlot.ActivateSlot
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYHUDWidget_TeamVoiceChatSlot::ActivateSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YHUDWidget_TeamVoiceChatSlot.ActivateSlot");
		
		UYHUDWidget_TeamVoiceChatSlot_ActivateSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYHUDWidget_TeamVoiceChatSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYHUDWidget_TeamVoiceChatSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YHUDWidget_TeamVoiceChatSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00759C30
	 * 		Name   -> Function DreadGame.YWidget_TextField.GetTextFromField
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UYWidget_TextField::GetTextFromField()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_TextField.GetTextFromField");
		
		UYWidget_TextField_GetTextFromField_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_TextField.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_TextField::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_TextField");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00777370
	 * 		Name   -> Function DreadGame.YWidget_CurrencyComponent.SetFadeInSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_CurrencyComponent::SetFadeInSpeed(float speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_CurrencyComponent.SetFadeInSpeed");
		
		UYWidget_CurrencyComponent_SetFadeInSpeed_Params params {};
		params.speed = speed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776C60
	 * 		Name   -> Function DreadGame.YWidget_CurrencyComponent.SetData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            currencyValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUICurrency                                       currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               treatAsPercentage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWidget_CurrencyComponent::SetData(int32_t currencyValue, EYUICurrency currencyType, bool treatAsPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_CurrencyComponent.SetData");
		
		UYWidget_CurrencyComponent_SetData_Params params {};
		params.currencyValue = currencyValue;
		params.currencyType = currencyType;
		params.treatAsPercentage = treatAsPercentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007765A0
	 * 		Name   -> Function DreadGame.YWidget_CurrencyComponent.SetComponentsColor
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSlateColor                                 newColorAndOpacity                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYWidget_CurrencyComponent::SetComponentsColor(const struct FSlateColor& newColorAndOpacity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_CurrencyComponent.SetComponentsColor");
		
		UYWidget_CurrencyComponent_SetComponentsColor_Params params {};
		params.newColorAndOpacity = newColorAndOpacity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00775A80
	 * 		Name   -> Function DreadGame.YWidget_CurrencyComponent.SetAnimationToFinalState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYWidget_CurrencyComponent::SetAnimationToFinalState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_CurrencyComponent.SetAnimationToFinalState");
		
		UYWidget_CurrencyComponent_SetAnimationToFinalState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763C10
	 * 		Name   -> Function DreadGame.YWidget_CurrencyComponent.OnFadeInStarted
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_CurrencyComponent::OnFadeInStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_CurrencyComponent.OnFadeInStarted");
		
		UYWidget_CurrencyComponent_OnFadeInStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00BBD570
	 * 		Name   -> Function DreadGame.YWidget_CurrencyComponent.OnFadeInFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_CurrencyComponent::OnFadeInFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_CurrencyComponent.OnFadeInFinished");
		
		UYWidget_CurrencyComponent_OnFadeInFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_CurrencyComponent.BP_InitializeCurrencyIcon
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYUICurrency                                       currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_CurrencyComponent::BP_InitializeCurrencyIcon(EYUICurrency currencyType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_CurrencyComponent.BP_InitializeCurrencyIcon");
		
		UYWidget_CurrencyComponent_BP_InitializeCurrencyIcon_Params params {};
		params.currencyType = currencyType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_CurrencyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_CurrencyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_CurrencyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00778CD0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchMatchOutcome.SetMatchOutcome
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EYMatchOutcome                                     matchOutcome                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchMatchOutcome::SetMatchOutcome(EYMatchOutcome matchOutcome)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchMatchOutcome.SetMatchOutcome");
		
		UYWidget_EndOfMatchMatchOutcome_SetMatchOutcome_Params params {};
		params.matchOutcome = matchOutcome;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchMatchOutcome.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchMatchOutcome::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchMatchOutcome");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchMVPEntry.BP_HighlightbyMVPType
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EYMVPType                                          mvpType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchMVPEntry::BP_HighlightbyMVPType(EYMVPType mvpType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchMVPEntry.BP_HighlightbyMVPType");
		
		UYWidget_EndOfMatchMVPEntry_BP_HighlightbyMVPType_Params params {};
		params.mvpType = mvpType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchMVPEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchMVPEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchMVPEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763C50
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchPage.OnFadeOutAnimationFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatchPage::OnFadeOutAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchPage.OnFadeOutAnimationFinished");
		
		UYWidget_EndOfMatchPage_OnFadeOutAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763BD0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchPage.OnFadeInAnimationFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatchPage::OnFadeInAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchPage.OnFadeInAnimationFinished");
		
		UYWidget_EndOfMatchPage_OnFadeInAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00783B60
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_RewardsPage.UpdateProgressBar
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UProgressBar*                                progressBarToAnimate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYPVERewardType                                    rewardType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYPVERewardLevel                                   rewardLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatch_PVE_RewardsPage::UpdateProgressBar(class UProgressBar* progressBarToAnimate, EYPVERewardType rewardType, EYPVERewardLevel rewardLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_RewardsPage.UpdateProgressBar");
		
		UYWidget_EndOfMatch_PVE_RewardsPage_UpdateProgressBar_Params params {};
		params.progressBarToAnimate = progressBarToAnimate;
		params.rewardType = rewardType;
		params.rewardLevel = rewardLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769E10
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_RewardsPage.OnRewardIntroAnimationFinished
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EYPVERewardType                                    rewardType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYPVERewardLevel                                   rewardLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatch_PVE_RewardsPage::OnRewardIntroAnimationFinished(EYPVERewardType rewardType, EYPVERewardLevel rewardLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_RewardsPage.OnRewardIntroAnimationFinished");
		
		UYWidget_EndOfMatch_PVE_RewardsPage_OnRewardIntroAnimationFinished_Params params {};
		params.rewardType = rewardType;
		params.rewardLevel = rewardLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768600
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_RewardsPage.OnProgressBarAnimationFinished
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EYPVERewardType                                    rewardType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYPVERewardLevel                                   rewardLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatch_PVE_RewardsPage::OnProgressBarAnimationFinished(EYPVERewardType rewardType, EYPVERewardLevel rewardLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_RewardsPage.OnProgressBarAnimationFinished");
		
		UYWidget_EndOfMatch_PVE_RewardsPage_OnProgressBarAnimationFinished_Params params {};
		params.rewardType = rewardType;
		params.rewardLevel = rewardLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatch_PVE_RewardsPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatch_PVE_RewardsPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatch_PVE_RewardsPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B500
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_ScorePage.OnTeamScoreFadeInAnimationFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatch_PVE_ScorePage::OnTeamScoreFadeInAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_ScorePage.OnTeamScoreFadeInAnimationFinished");
		
		UYWidget_EndOfMatch_PVE_ScorePage_OnTeamScoreFadeInAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007640D0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_ScorePage.OnGameModeElementsFadeInAnimationFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatch_PVE_ScorePage::OnGameModeElementsFadeInAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_ScorePage.OnGameModeElementsFadeInAnimationFinished");
		
		UYWidget_EndOfMatch_PVE_ScorePage_OnGameModeElementsFadeInAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_ScorePage.BP_CreateBonusEntry
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent)
	 */
	class UYWidget_EndOfMatch_PVE_ScoreBonusEntry* UYWidget_EndOfMatch_PVE_ScorePage::BP_CreateBonusEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_ScorePage.BP_CreateBonusEntry");
		
		UYWidget_EndOfMatch_PVE_ScorePage_BP_CreateBonusEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatch_PVE_ScorePage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatch_PVE_ScorePage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatch_PVE_ScorePage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_TeamPage.BP_StartPageIntroAnimation
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent)
	 */
	void UYWidget_EndOfMatch_PVE_TeamPage::BP_StartPageIntroAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_TeamPage.BP_StartPageIntroAnimation");
		
		UYWidget_EndOfMatch_PVE_TeamPage_BP_StartPageIntroAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_TeamPage.BP_CreateTeamPlayerEntry
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        PlayerName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class UYWidget* UYWidget_EndOfMatch_PVE_TeamPage::BP_CreateTeamPlayerEntry(const class FText& PlayerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_TeamPage.BP_CreateTeamPlayerEntry");
		
		UYWidget_EndOfMatch_PVE_TeamPage_BP_CreateTeamPlayerEntry_Params params {};
		params.PlayerName = PlayerName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatch_PVE_TeamPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatch_PVE_TeamPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatch_PVE_TeamPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchMVPPage.BP_CreateMVPEntry
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent)
	 */
	class UYWidget_EndOfMatchMVPEntry* UYWidget_EndOfMatchMVPPage::BP_CreateMVPEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchMVPPage.BP_CreateMVPEntry");
		
		UYWidget_EndOfMatchMVPPage_BP_CreateMVPEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchMVPPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchMVPPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchMVPPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchPlayerStatsPage.BP_CreateStatEntry
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent)
	 */
	class UYWidget_EndOfMatchPlayerStat* UYWidget_EndOfMatchPlayerStatsPage::BP_CreateStatEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchPlayerStatsPage.BP_CreateStatEntry");
		
		UYWidget_EndOfMatchPlayerStatsPage_BP_CreateStatEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchPlayerStatsPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchPlayerStatsPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchPlayerStatsPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00769ED0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRewardsPage.OnRewardWidgetAnimationFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYWidget_EndOfMatchRewardsPage::OnRewardWidgetAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRewardsPage.OnRewardWidgetAnimationFinished");
		
		UYWidget_EndOfMatchRewardsPage_OnRewardWidgetAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763300
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRewardsPage.OnColumnAnimationFinished
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UYWidget_EndOfMatchRewardColumn*             column                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchRewardsPage::OnColumnAnimationFinished(class UYWidget_EndOfMatchRewardColumn* column)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRewardsPage.OnColumnAnimationFinished");
		
		UYWidget_EndOfMatchRewardsPage_OnColumnAnimationFinished_Params params {};
		params.column = column;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRewardsPage.BP_PS4_SetUpEliteTeamContributors
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        percentBonusFromEliteText                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        eliteFromTeamText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumElitePlayers                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchRewardsPage::BP_PS4_SetUpEliteTeamContributors(const class FText& percentBonusFromEliteText, const class FText& eliteFromTeamText, int32_t NumElitePlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRewardsPage.BP_PS4_SetUpEliteTeamContributors");
		
		UYWidget_EndOfMatchRewardsPage_BP_PS4_SetUpEliteTeamContributors_Params params {};
		params.percentBonusFromEliteText = percentBonusFromEliteText;
		params.eliteFromTeamText = eliteFromTeamText;
		params.NumElitePlayers = NumElitePlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRewardsPage.BP_InitializeEliteFromTeamHint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        eliteFromTeamHintHeadline                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        eliteFromTeamHintText                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchRewardsPage::BP_InitializeEliteFromTeamHint(const class FText& eliteFromTeamHintHeadline, const class FText& eliteFromTeamHintText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRewardsPage.BP_InitializeEliteFromTeamHint");
		
		UYWidget_EndOfMatchRewardsPage_BP_InitializeEliteFromTeamHint_Params params {};
		params.eliteFromTeamHintHeadline = eliteFromTeamHintHeadline;
		params.eliteFromTeamHintText = eliteFromTeamHintText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchRewardsPage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchRewardsPage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchRewardsPage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007686E0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRequeueing.OnPurchaseBattleBonus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYWidget_EndOfMatchRequeueing::OnPurchaseBattleBonus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRequeueing.OnPurchaseBattleBonus");
		
		UYWidget_EndOfMatchRequeueing_OnPurchaseBattleBonus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768210
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRequeueing.OnPlayerRequeueing
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UYWidget_EndOfMatchRequeueing::OnPlayerRequeueing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRequeueing.OnPlayerRequeueing");
		
		UYWidget_EndOfMatchRequeueing_OnPlayerRequeueing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchRequeueing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchRequeueing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchRequeueing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768210
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.OnPlayerRequeueing
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UYWidget_EndOfMatchRequeueing_PS4::OnPlayerRequeueing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.OnPlayerRequeueing");
		
		UYWidget_EndOfMatchRequeueing_PS4_OnPlayerRequeueing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.BP_ShowBattleBonusPurchaseBar
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               canBuyBattleBonus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchRequeueing_PS4::BP_ShowBattleBonusPurchaseBar(bool canBuyBattleBonus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.BP_ShowBattleBonusPurchaseBar");
		
		UYWidget_EndOfMatchRequeueing_PS4_BP_ShowBattleBonusPurchaseBar_Params params {};
		params.canBuyBattleBonus = canBuyBattleBonus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.BP_SetRequeueingStateBar
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYRequeuingState                                   requeueState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isReadyToMatchMake                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchRequeueing_PS4::BP_SetRequeueingStateBar(EYRequeuingState requeueState, bool isReadyToMatchMake)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.BP_SetRequeueingStateBar");
		
		UYWidget_EndOfMatchRequeueing_PS4_BP_SetRequeueingStateBar_Params params {};
		params.requeueState = requeueState;
		params.isReadyToMatchMake = isReadyToMatchMake;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.BP_SetDisplayForCustomMatchEOMScreen
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UYWidget_EndOfMatchRequeueing_PS4::BP_SetDisplayForCustomMatchEOMScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRequeueing_PS4.BP_SetDisplayForCustomMatchEOMScreen");
		
		UYWidget_EndOfMatchRequeueing_PS4_BP_SetDisplayForCustomMatchEOMScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchRequeueing_PS4.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchRequeueing_PS4::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchRequeueing_PS4");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchSkippable.BP_SetIntroAnimationToFinalState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYWidget_EndOfMatchSkippable::BP_SetIntroAnimationToFinalState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchSkippable.BP_SetIntroAnimationToFinalState");
		
		UYWidget_EndOfMatchSkippable_BP_SetIntroAnimationToFinalState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchSkippable.BP_ForceFinishIntroAnimation
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYWidget_EndOfMatchSkippable::BP_ForceFinishIntroAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchSkippable.BP_ForceFinishIntroAnimation");
		
		UYWidget_EndOfMatchSkippable_BP_ForceFinishIntroAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchSkippable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchSkippable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchSkippable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CE30
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.SetupCurrencyAndRewardTextWidgets
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FYPVEEventRewardMeta                        rewardData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatch_PVE_RewardEntry::SetupCurrencyAndRewardTextWidgets(const struct FYPVEEventRewardMeta& rewardData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.SetupCurrencyAndRewardTextWidgets");
		
		UYWidget_EndOfMatch_PVE_RewardEntry_SetupCurrencyAndRewardTextWidgets_Params params {};
		params.rewardData = rewardData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007767F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.SetCurrencyData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FYPVEEventRewardMeta                        rewardData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatch_PVE_RewardEntry::SetCurrencyData(const struct FYPVEEventRewardMeta& rewardData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.SetCurrencyData");
		
		UYWidget_EndOfMatch_PVE_RewardEntry_SetCurrencyData_Params params {};
		params.rewardData = rewardData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076B7F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.OnUnlockAnimationFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatch_PVE_RewardEntry::OnUnlockAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.OnUnlockAnimationFinished");
		
		UYWidget_EndOfMatch_PVE_RewardEntry_OnUnlockAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.BP_RewardSetupFinished
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYWidget_EndOfMatch_PVE_RewardEntry::BP_RewardSetupFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatch_PVE_RewardEntry.BP_RewardSetupFinished");
		
		UYWidget_EndOfMatch_PVE_RewardEntry_BP_RewardSetupFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatch_PVE_RewardEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatch_PVE_RewardEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatch_PVE_RewardEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatch_PVE_ScoreBonusEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatch_PVE_ScoreBonusEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatch_PVE_ScoreBonusEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074BEC0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchPlayerStat.FadeStatColor
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FadeTime                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchPlayerStat::FadeStatColor(float FadeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchPlayerStat.FadeStatColor");
		
		UYWidget_EndOfMatchPlayerStat_FadeStatColor_Params params {};
		params.FadeTime = FadeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchPlayerStat.BP_StatSetupFinished
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UYWidget_EndOfMatchPlayerStat::BP_StatSetupFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchPlayerStat.BP_StatSetupFinished");
		
		UYWidget_EndOfMatchPlayerStat_BP_StatSetupFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchPlayerStat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchPlayerStat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchPlayerStat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_ShipClassIcon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_ShipClassIcon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_ShipClassIcon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00742610
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchRewardColumn.BroadcastColumnAnimationFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UYWidget_EndOfMatchRewardColumn::BroadcastColumnAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchRewardColumn.BroadcastColumnAnimationFinished");
		
		UYWidget_EndOfMatchRewardColumn_BroadcastColumnAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchRewardColumn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchRewardColumn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchRewardColumn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00776D60
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchTotalRewardBox.SetData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            currencyValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EYUICurrency                                       currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amountFromHeroShips                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_EndOfMatchTotalRewardBox::SetData(int32_t currencyValue, EYUICurrency currencyType, int32_t amountFromHeroShips)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchTotalRewardBox.SetData");
		
		UYWidget_EndOfMatchTotalRewardBox_SetData_Params params {};
		params.currencyValue = currencyValue;
		params.currencyType = currencyType;
		params.amountFromHeroShips = amountFromHeroShips;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763C30
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchTotalRewardBox.OnFadeInStarted
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatchTotalRewardBox::OnFadeInStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchTotalRewardBox.OnFadeInStarted");
		
		UYWidget_EndOfMatchTotalRewardBox_OnFadeInStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00763BF0
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchTotalRewardBox.OnFadeInFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatchTotalRewardBox::OnFadeInFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchTotalRewardBox.OnFadeInFinished");
		
		UYWidget_EndOfMatchTotalRewardBox_OnFadeInFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00762640
	 * 		Name   -> Function DreadGame.YWidget_EndOfMatchTotalRewardBox.OnAnimateInDelayed
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYWidget_EndOfMatchTotalRewardBox::OnAnimateInDelayed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_EndOfMatchTotalRewardBox.OnAnimateInDelayed");
		
		UYWidget_EndOfMatchTotalRewardBox_OnAnimateInDelayed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_EndOfMatchTotalRewardBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_EndOfMatchTotalRewardBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_EndOfMatchTotalRewardBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0076A310
	 * 		Name   -> Function DreadGame.YWidget_GenericDropdown.OnSelectedItem
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      SelectedItem                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_GenericDropdown::OnSelectedItem(const class FString& SelectedItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_GenericDropdown.OnSelectedItem");
		
		UYWidget_GenericDropdown_OnSelectedItem_Params params {};
		params.SelectedItem = SelectedItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_GenericDropdown.BP_SetSelectedItem
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      SelectedItem                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_GenericDropdown::BP_SetSelectedItem(const class FString& SelectedItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_GenericDropdown.BP_SetSelectedItem");
		
		UYWidget_GenericDropdown_BP_SetSelectedItem_Params params {};
		params.SelectedItem = SelectedItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_GenericDropdown.BP_SetItems
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class FString>                              items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYWidget_GenericDropdown::BP_SetItems(TArray<class FString> items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_GenericDropdown.BP_SetItems");
		
		UYWidget_GenericDropdown_BP_SetItems_Params params {};
		params.items = items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_GenericDropdown.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_GenericDropdown::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_GenericDropdown");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0074A6C0
	 * 		Name   -> Function DreadGame.YWidget_GenericPopup.Deny
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYWidget_GenericPopup::Deny()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_GenericPopup.Deny");
		
		UYWidget_GenericPopup_Deny_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_GenericPopup.BP_OnSetData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FYGenericPopupData                          Data                                                       (Parm, NativeAccessSpecifierPublic)
	 */
	void UYWidget_GenericPopup::BP_OnSetData(const struct FYGenericPopupData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_GenericPopup.BP_OnSetData");
		
		UYWidget_GenericPopup_BP_OnSetData_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0073CC20
	 * 		Name   -> Function DreadGame.YWidget_GenericPopup.Accept
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UYWidget_GenericPopup::Accept()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_GenericPopup.Accept");
		
		UYWidget_GenericPopup_Accept_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_GenericPopup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_GenericPopup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_GenericPopup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_ShipCard.BP_PS4_SetTierIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            tier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UYWidget_ShipCard::BP_PS4_SetTierIcon(int32_t tier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_ShipCard.BP_PS4_SetTierIcon");
		
		UYWidget_ShipCard_BP_PS4_SetTierIcon_Params params {};
		params.tier = tier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D5B4F0
	 * 		Name   -> Function DreadGame.YWidget_ShipCard.BP_PS4_SetShipIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EYShipBaseClass                                    shipclass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsHeroShipStatus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IsVeteranStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UYWidget_ShipCard::BP_PS4_SetShipIcon(EYShipBaseClass shipclass, bool IsHeroShipStatus, bool IsVeteranStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_ShipCard.BP_PS4_SetShipIcon");
		
		UYWidget_ShipCard_BP_PS4_SetShipIcon_Params params {};
		params.shipclass = shipclass;
		params.IsHeroShipStatus = IsHeroShipStatus;
		params.IsVeteranStatus = IsVeteranStatus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_ShipCard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_ShipCard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_ShipCard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0077CF80
	 * 		Name   -> Function DreadGame.YWidget_SimpleToolTip.SetupToolTip
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        headlineText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        descriptionText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UYWidget_SimpleToolTip::SetupToolTip(const class FText& headlineText, const class FText& descriptionText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YWidget_SimpleToolTip.SetupToolTip");
		
		UYWidget_SimpleToolTip_SetupToolTip_Params params {};
		params.headlineText = headlineText;
		params.descriptionText = descriptionText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYWidget_SimpleToolTip.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYWidget_SimpleToolTip::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWidget_SimpleToolTip");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AYWorldSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AYWorldSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YWorldSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00768F80
	 * 		Name   -> Function DreadGame.YXPManager.OnRep_ReplicateMatchXPInfo
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UYXPManager::OnRep_ReplicateMatchXPInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YXPManager.OnRep_ReplicateMatchXPInfo");
		
		UYXPManager_OnRep_ReplicateMatchXPInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0075D310
	 * 		Name   -> Function DreadGame.YXPManager.Initialize
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UYXPManager::Initialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YXPManager.Initialize");
		
		UYXPManager_Initialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00758A60
	 * 		Name   -> Function DreadGame.YXPManager.GetShipXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            shipID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UYXPManager::GetShipXP(int32_t shipID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YXPManager.GetShipXP");
		
		UYXPManager_GetShipXP_Params params {};
		params.shipID = shipID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00751F90
	 * 		Name   -> Function DreadGame.YXPManager.GetFreeXP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UYXPManager::GetFreeXP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DreadGame.YXPManager.GetFreeXP");
		
		UYXPManager_GetFreeXP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UYXPManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UYXPManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DreadGame.YXPManager");
		return ptr;
	}

}


